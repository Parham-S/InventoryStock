'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = require('postcss');

var postcss__default = _interopDefault(postcss);

function shiftNodesBeforeParent(node) {
  var parent = node.parent;
  var index = parent.index(node); // conditionally move previous siblings into a clone of the parent

  if (index) {
    parent.cloneBefore().removeAll().append(parent.nodes.slice(0, index));
  } // move the current node before the parent (and after the conditional clone)


  parent.before(node);
  return parent;
}

function cleanupParent(parent) {
  if (!parent.nodes.length) {
    parent.remove();
  }
} // a valid selector is an ampersand followed by a non-word character or nothing


var validSelector = /&(?:[^\w-|]|$)/;
var replaceable = /&/g;

function mergeSelectors(fromSelectors, toSelectors) {
  return fromSelectors.reduce(function (selectors, fromSelector) {
    return selectors.concat(toSelectors.map(function (toSelector) {
      return toSelector.replace(replaceable, fromSelector);
    }));
  }, []);
}

function transformRuleWithinRule(node) {
  // move previous siblings and the node to before the parent
  var parent = shiftNodesBeforeParent(node); // update the selectors of the node to be merged with the parent

  node.selectors = mergeSelectors(parent.selectors, node.selectors); // merge similar rules back together
  // eslint-disable-next-line no-extra-parens

  var areSameRule = node.type === 'rule' && parent.type === 'rule' && node.selector === parent.selector || node.type === 'atrule' && parent.type === 'atrule' && node.params === parent.params;

  if (areSameRule) {
    node.append.apply(node, _toConsumableArray(parent.nodes));
  } // conditionally cleanup an empty parent rule


  cleanupParent(parent);
}

var isRuleWithinRule = function isRuleWithinRule(node) {
  return node.type === 'rule' && Object(node.parent).type === 'rule' && node.selectors.every(function (selector) {
    return selector.trim().lastIndexOf('&') === 0 && validSelector.test(selector);
  });
};

var comma = postcss.list.comma;

function transformNestRuleWithinRule(node) {
  // move previous siblings and the node to before the parent
  var parent = shiftNodesBeforeParent(node); // clone the parent as a new rule with children appended to it

  var rule = parent.clone().removeAll().append(node.nodes); // replace the node with the new rule

  node.replaceWith(rule); // update the selectors of the node to be merged with the parent

  rule.selectors = mergeSelectors(parent.selectors, comma(node.params)); // conditionally cleanup an empty parent rule

  cleanupParent(parent); // walk the children of the new rule

  walk(rule);
}

var isNestRuleWithinRule = function isNestRuleWithinRule(node) {
  return node.type === 'atrule' && node.name === 'nest' && Object(node.parent).type === 'rule' && comma(node.params).every(function (selector) {
    return selector.split('&').length === 2 && validSelector.test(selector);
  });
};

var validAtrules = ['document', 'media', 'supports'];
/*
 * DEPRECATED: In v7.0.0 these features will be removed as they are not part of
 * the nesting proposal.
 */

function atruleWithinRule(node) {
  // move previous siblings and the node to before the parent
  var parent = shiftNodesBeforeParent(node); // clone the parent as a new rule with children appended to it

  var rule = parent.clone().removeAll().append(node.nodes); // append the new rule to the node

  node.append(rule); // conditionally cleanup an empty parent rule

  cleanupParent(parent); // walk the children of the new rule

  walk(rule);
}

var isAtruleWithinRule = function isAtruleWithinRule(node) {
  return node.type === 'atrule' && validAtrules.indexOf(node.name) !== -1 && Object(node.parent).type === 'rule';
};

var comma$1 = postcss.list.comma;

function mergeParams(fromParams, toParams) {
  return comma$1(fromParams).map(function (params1) {
    return comma$1(toParams).map(function (params2) {
      return "".concat(params1, " and ").concat(params2);
    }).join(', ');
  }).join(', ');
}
/*
 * DEPRECATED: In v7.0.0 these features will be removed as they are not part of
 * the nesting proposal.
 */


function transformAtruleWithinAtrule(node) {
  // move previous siblings and the node to before the parent
  var parent = shiftNodesBeforeParent(node); // update the params of the node to be merged with the parent

  node.params = mergeParams(parent.params, node.params); // conditionally cleanup an empty parent rule

  cleanupParent(parent);
}

var isAtruleWithinAtrule = function isAtruleWithinAtrule(node) {
  return node.type === 'atrule' && validAtrules.indexOf(node.name) !== -1 && Object(node.parent).type === 'atrule' && node.name === node.parent.name;
};

function walk(node) {
  node.nodes.slice(0).forEach(function (child) {
    if (child.parent === node) {
      if (isRuleWithinRule(child)) {
        transformRuleWithinRule(child);
      } else if (isNestRuleWithinRule(child)) {
        transformNestRuleWithinRule(child);
      } else if (isAtruleWithinRule(child)) {
        atruleWithinRule(child);
      } else if (isAtruleWithinAtrule(child)) {
        transformAtruleWithinAtrule(child);
      }

      if (Object(child.nodes).length) {
        walk(child);
      }
    }
  });
}

var index = postcss__default.plugin('postcss-nesting', function () {
  return walk;
});
module.exports = index;