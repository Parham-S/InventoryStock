"use strict";
/**
 * trace-event - A library to create a trace of your node app per
 * Google's Trace Event format:
 * // JSSTYLED
 *      https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tracer = void 0;

var stream_1 = require("stream");

function evCommon() {
  var hrtime = process.hrtime(); // [seconds, nanoseconds]

  var ts = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000); // microseconds

  return {
    ts: ts,
    pid: process.pid,
    tid: process.pid // no meaningful tid for node.js

  };
}

var Tracer =
/*#__PURE__*/
function (_stream_1$Readable) {
  _inherits(Tracer, _stream_1$Readable);

  function Tracer() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Tracer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tracer).call(this));
    _this.noStream = false;
    _this.events = [];

    if (_typeof(opts) !== "object") {
      throw new Error("Invalid options passed (must be an object)");
    }

    if (opts.parent != null && _typeof(opts.parent) !== "object") {
      throw new Error("Invalid option (parent) passed (must be an object)");
    }

    if (opts.fields != null && _typeof(opts.fields) !== "object") {
      throw new Error("Invalid option (fields) passed (must be an object)");
    }

    if (opts.objectMode != null && opts.objectMode !== true && opts.objectMode !== false) {
      throw new Error("Invalid option (objectsMode) passed (must be a boolean)");
    }

    _this.noStream = opts.noStream || false;
    _this.parent = opts.parent;

    if (_this.parent) {
      _this.fields = Object.assign({}, opts.parent && opts.parent.fields);
    } else {
      _this.fields = {};
    }

    if (opts.fields) {
      Object.assign(_this.fields, opts.fields);
    }

    if (!_this.fields.cat) {
      // trace-viewer *requires* `cat`, so let's have a fallback.
      _this.fields.cat = "default";
    } else if (Array.isArray(_this.fields.cat)) {
      _this.fields.cat = _this.fields.cat.join(",");
    }

    if (!_this.fields.args) {
      // trace-viewer *requires* `args`, so let's have a fallback.
      _this.fields.args = {};
    }

    if (_this.parent) {
      // TODO: Not calling Readable ctor here. Does that cause probs?
      //      Probably if trying to pipe from the child.
      //      Might want a serpate TracerChild class for these guys.
      _this._push = _this.parent._push.bind(_this.parent);
    } else {
      _this._objectMode = Boolean(opts.objectMode);
      var streamOpts = {
        objectMode: _this._objectMode
      };

      if (_this._objectMode) {
        _this._push = _this.push;
      } else {
        _this._push = _this._pushString;
        streamOpts.encoding = "utf8";
      }

      stream_1.Readable.call(_assertThisInitialized(_this), streamOpts);
    }

    return _this;
  }
  /**
   * If in no streamMode in order to flush out the trace
   * you need to call flush.
   */


  _createClass(Tracer, [{
    key: "flush",
    value: function flush() {
      if (this.noStream === true) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var evt = _step.value;

            this._push(evt);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this._flush();
      }
    }
  }, {
    key: "_read",
    value: function _read(_) {}
  }, {
    key: "_pushString",
    value: function _pushString(ev) {
      var separator = "";

      if (!this.firstPush) {
        this.push("[");
        this.firstPush = true;
      } else {
        separator = ",\n";
      }

      this.push(separator + JSON.stringify(ev), "utf8");
    }
  }, {
    key: "_flush",
    value: function _flush() {
      if (!this._objectMode) {
        this.push("]");
      }
    }
  }, {
    key: "child",
    value: function child(fields) {
      return new Tracer({
        parent: this,
        fields: fields
      });
    }
  }, {
    key: "begin",
    value: function begin(fields) {
      return this.mkEventFunc("b")(fields);
    }
  }, {
    key: "end",
    value: function end(fields) {
      return this.mkEventFunc("e")(fields);
    }
  }, {
    key: "completeEvent",
    value: function completeEvent(fields) {
      return this.mkEventFunc("X")(fields);
    }
  }, {
    key: "instantEvent",
    value: function instantEvent(fields) {
      return this.mkEventFunc("I")(fields);
    }
  }, {
    key: "mkEventFunc",
    value: function mkEventFunc(ph) {
      var _this2 = this;

      return function (fields) {
        var ev = evCommon(); // Assign the event phase.

        ev.ph = ph;

        if (fields) {
          if (typeof fields === "string") {
            ev.name = fields;
          } else {
            for (var _i = 0, _Object$keys = Object.keys(fields); _i < _Object$keys.length; _i++) {
              var k = _Object$keys[_i];

              if (k === "cat") {
                ev.cat = fields.cat.join(",");
              } else {
                ev[k] = fields[k];
              }
            }
          }
        }

        if (!_this2.noStream) {
          _this2._push(ev);
        } else {
          _this2.events.push(ev);
        }
      };
    }
  }]);

  return Tracer;
}(stream_1.Readable);

exports.Tracer = Tracer;
/*
 * These correspond to the "Async events" in the Trace Events doc.
 *
 * Required fields:
 * - name
 * - id
 *
 * Optional fields:
 * - cat (array)
 * - args (object)
 * - TODO: stack fields, other optional fields?
 *
 * Dev Note: We don't explicitly assert that correct fields are
 * used for speed (premature optimization alert!).
 */