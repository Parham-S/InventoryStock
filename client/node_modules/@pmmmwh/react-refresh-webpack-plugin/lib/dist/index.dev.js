"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var validateOptions = require('schema-utils');

var _require = require('webpack'),
    DefinePlugin = _require.DefinePlugin,
    ModuleFilenameHelpers = _require.ModuleFilenameHelpers,
    ProvidePlugin = _require.ProvidePlugin,
    Template = _require.Template;

var ConstDependency = require('webpack/lib/dependencies/ConstDependency');

var _require2 = require('./globals'),
    refreshGlobal = _require2.refreshGlobal,
    webpackRequire = _require2.webpackRequire,
    webpackVersion = _require2.webpackVersion;

var _require3 = require('./utils'),
    createError = _require3.createError,
    getParserHelpers = _require3.getParserHelpers,
    getRefreshGlobal = _require3.getRefreshGlobal,
    getSocketIntegration = _require3.getSocketIntegration,
    injectRefreshEntry = _require3.injectRefreshEntry,
    injectRefreshLoader = _require3.injectRefreshLoader,
    normalizeOptions = _require3.normalizeOptions;

var schema = require('./options.json'); // Mapping of react-refresh globals to Webpack runtime globals


var REPLACEMENTS = {
  $RefreshRuntime$: {
    expr: "".concat(refreshGlobal, ".runtime"),
    req: [webpackRequire, "".concat(refreshGlobal, ".runtime")],
    type: 'object'
  },
  $RefreshSetup$: {
    expr: "".concat(refreshGlobal, ".setup"),
    req: [webpackRequire, "".concat(refreshGlobal, ".setup")],
    type: 'function'
  },
  $RefreshCleanup$: {
    expr: "".concat(refreshGlobal, ".cleanup"),
    req: [webpackRequire, "".concat(refreshGlobal, ".cleanup")],
    type: 'function'
  },
  $RefreshReg$: {
    expr: "".concat(refreshGlobal, ".register"),
    req: [webpackRequire, "".concat(refreshGlobal, ".register")],
    type: 'function'
  },
  $RefreshSig$: {
    expr: "".concat(refreshGlobal, ".signature"),
    req: [webpackRequire, "".concat(refreshGlobal, ".signature")],
    type: 'function'
  }
};

var ReactRefreshPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {import('./types').ReactRefreshPluginOptions} [options] Options for react-refresh-plugin.
   */
  function ReactRefreshPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReactRefreshPlugin);

    validateOptions(schema, options, {
      name: 'React Refresh Plugin',
      baseDataPath: 'options'
    });
    /**
     * @readonly
     * @type {import('./types').NormalizedPluginOptions}
     */

    this.options = normalizeOptions(options);
  }
  /**
   * Applies the plugin.
   * @param {import('webpack').Compiler} compiler A webpack compiler object.
   * @returns {void}
   */


  _createClass(ReactRefreshPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      // Throw if we encounter an unsupported Webpack version,
      // since things will most likely not work.
      if (webpackVersion !== 4 && webpackVersion !== 5) {
        throw createError("Webpack v".concat(webpackVersion, " is not supported!"));
      } // Skip processing in non-development mode, but allow manual force-enabling


      if ( // Webpack do not set process.env.NODE_ENV, so we need to check for mode.
      // Ref: https://github.com/webpack/webpack/issues/7074
      (compiler.options.mode !== 'development' || // We also check for production process.env.NODE_ENV,
      // in case it was set and mode is non-development (e.g. 'none')
      process.env.NODE_ENV && process.env.NODE_ENV === 'production') && !this.options.forceEnable) {
        return;
      } // Inject react-refresh context to all Webpack entry points


      compiler.options.entry = injectRefreshEntry(compiler.options.entry, this.options); // Inject necessary modules to bundle's global scope

      /** @type {Record<string, string>} */

      var providedModules = {
        __react_refresh_utils__: require.resolve('./runtime/RefreshUtils')
      };

      if (this.options.overlay === false) {
        // Stub errorOverlay module so calls to it can be erased
        var definePlugin = new DefinePlugin({
          __react_refresh_error_overlay__: false,
          __react_refresh_init_socket__: false
        });
        definePlugin.apply(compiler);
      } else {
        providedModules = _objectSpread({}, providedModules, {}, this.options.overlay.module && {
          __react_refresh_error_overlay__: require.resolve(this.options.overlay.module)
        }, {}, this.options.overlay.sockIntegration && {
          __react_refresh_init_socket__: getSocketIntegration(this.options.overlay.sockIntegration)
        });
      }

      var providePlugin = new ProvidePlugin(providedModules);
      providePlugin.apply(compiler);
      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, this.options);

      var _getParserHelpers = getParserHelpers(),
          evaluateToString = _getParserHelpers.evaluateToString,
          toConstantDependency = _getParserHelpers.toConstantDependency;

      compiler.hooks.compilation.tap(this.constructor.name, function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;

        // Only hook into the current compiler
        if (compilation.compiler !== compiler) {
          return;
        } // Set template for ConstDependency which is used by parser hooks


        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template()); // Tap into version-specific compilation hooks

        switch (webpackVersion) {
          case 4:
            {
              var outputOptions = compilation.mainTemplate.outputOptions;

              compilation.mainTemplate.hooks.require.tap(_this.constructor.name, // Constructs the module template for react-refresh
              function (source, chunk, hash) {
                // Check for the output filename
                // This is to ensure we are processing a JS-related chunk
                var filename = outputOptions.filename;

                if (typeof filename === 'function') {
                  // Only usage of the `chunk` property is documented by Webpack.
                  // However, some internal Webpack plugins uses other properties,
                  // so we also pass them through to be on the safe side.
                  filename = filename({
                    contentHashType: 'javascript',
                    chunk: chunk,
                    hash: hash
                  });
                } // Check whether the current compilation is outputting to JS,
                // since other plugins can trigger compilations for other file types too.
                // If we apply the transform to them, their compilation will break fatally.
                // One prominent example of this is the HTMLWebpackPlugin.
                // If filename is falsy, something is terribly wrong and there's nothing we can do.


                if (!filename || !filename.includes('.js')) {
                  return source;
                } // Split template source code into lines for easier processing


                var lines = source.split('\n'); // Webpack generates this line when the MainTemplate is called

                var moduleInitializationLineNumber = lines.findIndex(function (line) {
                  return line.includes('modules[moduleId].call(');
                }); // Unable to find call to module execution -
                // this happens if the current module does not call MainTemplate.
                // In this case, we will return the original source and won't mess with it.

                if (moduleInitializationLineNumber === -1) {
                  return source;
                }

                var moduleInterceptor = Template.asString(["".concat(refreshGlobal, ".init();"), 'try {', Template.indent(lines[moduleInitializationLineNumber]), '} finally {', Template.indent("".concat(refreshGlobal, ".cleanup(moduleId);")), '}']);
                return Template.asString([].concat(_toConsumableArray(lines.slice(0, moduleInitializationLineNumber)), ['', outputOptions.strictModuleExceptionHandling ? Template.indent(moduleInterceptor) : moduleInterceptor, ''], _toConsumableArray(lines.slice(moduleInitializationLineNumber + 1, lines.length))));
              });

              compilation.mainTemplate.hooks.requireExtensions.tap(_this.constructor.name, // Setup react-refresh globals as extensions to Webpack's require function
              function (source) {
                return Template.asString([source, '', getRefreshGlobal()]);
              });
              normalModuleFactory.hooks.afterResolve.tap(_this.constructor.name, // Add react-refresh loader to process files that matches specified criteria
              function (data) {
                return injectRefreshLoader(data, matchObject);
              });
              compilation.hooks.normalModuleLoader.tap( // `Infinity` ensures this check will run only after all other taps
              {
                name: _this.constructor.name,
                stage: Infinity
              }, // Check for existence of the HMR runtime -
              // it is the foundation to this plugin working correctly
              function (context) {
                if (!context.hot) {
                  throw createError(['Hot Module Replacement (HMR) is not enabled!', 'React Refresh requires HMR to function properly.'].join(' '));
                }
              });
              break;
            }

          case 5:
            {
              var NormalModule = require('webpack/lib/NormalModule');

              var RuntimeGlobals = require('webpack/lib/RuntimeGlobals');

              var ReactRefreshRuntimeModule = require('./runtime/RefreshRuntimeModule');

              compilation.hooks.additionalTreeRuntimeRequirements.tap(_this.constructor.name, // Setup react-refresh globals with a Webpack runtime module
              function (chunk, runtimeRequirements) {
                runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);
                compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());
              });
              normalModuleFactory.hooks.afterResolve.tap(_this.constructor.name, // Add react-refresh loader to process files that matches specified criteria
              function (resolveData) {
                injectRefreshLoader(resolveData.createData, matchObject);
              });
              NormalModule.getCompilationHooks(compilation).loader.tap( // `Infinity` ensures this check will run only after all other taps
              {
                name: _this.constructor.name,
                stage: Infinity
              }, // Check for existence of the HMR runtime -
              // it is the foundation to this plugin working correctly
              function (context) {
                if (!context.hot) {
                  throw createError(['Hot Module Replacement (HMR) is not enabled!', 'React Refresh requires HMR to function properly.'].join(' '));
                }
              });
              break;
            }

          default:
            {
              throw createError("Encountered unexpected Webpack version (v".concat(webpackVersion, ")"));
            }
        }
        /**
         * Transform global calls into Webpack runtime calls.
         * @param {*} parser
         * @returns {void}
         */


        var parserHandler = function parserHandler(parser) {
          Object.entries(REPLACEMENTS).forEach(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                key = _ref3[0],
                info = _ref3[1];

            parser.hooks.expression["for"](key).tap(_this.constructor.name, toConstantDependency(parser, info.expr, info.req));

            if (info.type) {
              parser.hooks.evaluateTypeof["for"](key).tap(_this.constructor.name, evaluateToString(info.type));
            }
          });
        };

        normalModuleFactory.hooks.parser["for"]('javascript/auto').tap(_this.constructor.name, parserHandler);
        normalModuleFactory.hooks.parser["for"]('javascript/dynamic').tap(_this.constructor.name, parserHandler);
        normalModuleFactory.hooks.parser["for"]('javascript/esm').tap(_this.constructor.name, parserHandler);
      });
    }
  }]);

  return ReactRefreshPlugin;
}();

module.exports.ReactRefreshPlugin = ReactRefreshPlugin;
module.exports = ReactRefreshPlugin;