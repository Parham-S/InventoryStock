"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// This is a patch for mozilla/source-map#349 -
// internally, it uses the existence of the `fetch` global to toggle browser behaviours.
// That check, however, will break when `fetch` polyfills are used for SSR setups.
// We "reset" the polyfill here to ensure it won't interfere with source-map generation.
var originalFetch = global.fetch;
delete global.fetch;

var _require = require('source-map'),
    SourceMapConsumer = _require.SourceMapConsumer,
    SourceMapGenerator = _require.SourceMapGenerator,
    SourceNode = _require.SourceNode;

var _require2 = require('webpack'),
    Template = _require2.Template;
/**
 * Generates an identity source map from a source file.
 * @param {string} source The content of the source file.
 * @param {string} resourcePath The name of the source file.
 * @returns {import('source-map').RawSourceMap} The identity source map.
 */


function getIdentitySourceMap(source, resourcePath) {
  var sourceMap = new SourceMapGenerator();
  sourceMap.setSourceContent(resourcePath, source);
  source.split('\n').forEach(function (line, index) {
    sourceMap.addMapping({
      source: resourcePath,
      original: {
        line: index + 1,
        column: 0
      },
      generated: {
        line: index + 1,
        column: 0
      }
    });
  });
  return sourceMap.toJSON();
}
/**
 * Gets a runtime template from provided function.
 * @param {function(): void} fn A function containing the runtime template.
 * @returns {string} The "sanitized" runtime template.
 */


function getTemplate(fn) {
  return Template.getFunctionContent(fn).trim().replace(/^ {2}/gm, '');
}

var RefreshSetupRuntime = getTemplate(require('./RefreshSetup.runtime')).replace('$RefreshRuntimePath$', require.resolve('react-refresh/runtime').replace(/\\/g, '/'));
var RefreshModuleRuntime = getTemplate(require('./RefreshModule.runtime'));
/**
 * A simple Webpack loader to inject react-refresh HMR code into modules.
 *
 * [Reference for Loader API](https://webpack.js.org/api/loaders/)
 * @this {import('webpack').loader.LoaderContext}
 * @param {string} source The original module source code.
 * @param {import('source-map').RawSourceMap} [inputSourceMap] The source map of the module.
 * @param {*} [meta] The loader metadata passed in.
 * @returns {void}
 */

function ReactRefreshLoader(source, inputSourceMap, meta) {
  var callback = this.async();
  /**
   * @this {import('webpack').loader.LoaderContext}
   * @param {string} source
   * @param {import('source-map').RawSourceMap} [inputSourceMap]
   * @returns {Promise<[string, import('source-map').RawSourceMap]>}
   */

  function _loader(source, inputSourceMap) {
    var originalSourceMap, node, _node$toStringWithSou, code, map;

    return regeneratorRuntime.async(function _loader$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!this.sourceMap) {
              _context.next = 15;
              break;
            }

            originalSourceMap = inputSourceMap;

            if (!originalSourceMap) {
              originalSourceMap = getIdentitySourceMap(source, this.resourcePath);
            }

            _context.t0 = SourceNode;
            _context.t1 = source;
            _context.next = 7;
            return regeneratorRuntime.awrap(new SourceMapConsumer(originalSourceMap));

          case 7:
            _context.t2 = _context.sent;
            node = _context.t0.fromStringWithSourceMap.call(_context.t0, _context.t1, _context.t2);
            node.prepend([RefreshSetupRuntime, '\n\n']);
            node.add(['\n\n', RefreshModuleRuntime]);
            _node$toStringWithSou = node.toStringWithSourceMap(), code = _node$toStringWithSou.code, map = _node$toStringWithSou.map;
            return _context.abrupt("return", [code, map.toJSON()]);

          case 15:
            return _context.abrupt("return", [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\n\n'), inputSourceMap]);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, null, this);
  }

  _loader.call(this, source, inputSourceMap).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        code = _ref2[0],
        map = _ref2[1];

    callback(null, code, map, meta);
  }, function (error) {
    callback(error);
  });
}

module.exports = ReactRefreshLoader; // Restore the original value of the `fetch` global, if it exists

if (originalFetch) {
  global.fetch = originalFetch;
}