"use strict";
/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.Workbox = void 0;
var Deferred_js_1 = require("workbox-core/_private/Deferred.js");
var dontWaitFor_js_1 = require("workbox-core/_private/dontWaitFor.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var messageSW_js_1 = require("./messageSW.js");
var WorkboxEventTarget_js_1 = require("./utils/WorkboxEventTarget.js");
var urlsMatch_js_1 = require("./utils/urlsMatch.js");
var WorkboxEvent_js_1 = require("./utils/WorkboxEvent.js");
require("./_version.js");
// The time a SW must be in the waiting phase before we can conclude
// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically
// chosen, but it seems to avoid false positives in my testing.
var WAITING_TIMEOUT_DURATION = 200;
// The amount of time after a registration that we can reasonably conclude
// that the registration didn't trigger an update.
var REGISTRATION_TIMEOUT_DURATION = 60000;
/**
 * A class to aid in handling service worker registration, updates, and
 * reacting to service worker lifecycle events.
 *
 * @fires [message]{@link module:workbox-window.Workbox#message}
 * @fires [installed]{@link module:workbox-window.Workbox#installed}
 * @fires [waiting]{@link module:workbox-window.Workbox#waiting}
 * @fires [controlling]{@link module:workbox-window.Workbox#controlling}
 * @fires [activated]{@link module:workbox-window.Workbox#activated}
 * @fires [redundant]{@link module:workbox-window.Workbox#redundant}
 * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}
 * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}
 * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}
 * @memberof module:workbox-window
 */
var Workbox = /** @class */ (function (_super) {
    __extends(Workbox, _super);
    /**
     * Creates a new Workbox instance with a script URL and service worker
     * options. The script URL and options are the same as those used when
     * calling `navigator.serviceWorker.register(scriptURL, options)`. See:
     * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register
     *
     * @param {string} scriptURL The service worker script associated with this
     *     instance.
     * @param {Object} [registerOptions] The service worker options associated
     *     with this instance.
     */
    function Workbox(scriptURL, registerOptions) {
        if (registerOptions === void 0) { registerOptions = {}; }
        var _this = _super.call(this) || this;
        _this._registerOptions = {};
        _this._updateFoundCount = 0;
        // Deferreds we can resolve later.
        _this._swDeferred = new Deferred_js_1.Deferred();
        _this._activeDeferred = new Deferred_js_1.Deferred();
        _this._controllingDeferred = new Deferred_js_1.Deferred();
        _this._registrationTime = 0;
        _this._ownSWs = new Set();
        /**
         * @private
         */
        _this._onUpdateFound = function () {
            // `this._registration` will never be `undefined` after an update is found.
            var registration = _this._registration;
            var installingSW = registration.installing;
            // If the script URL passed to `navigator.serviceWorker.register()` is
            // different from the current controlling SW's script URL, we know any
            // successful registration calls will trigger an `updatefound` event.
            // But if the registered script URL is the same as the current controlling
            // SW's script URL, we'll only get an `updatefound` event if the file
            // changed since it was last registered. This can be a problem if the user
            // opens up the same page in a different tab, and that page registers
            // a SW that triggers an update. It's a problem because this page has no
            // good way of knowing whether the `updatefound` event came from the SW
            // script it registered or from a registration attempt made by a newer
            // version of the page running in another tab.
            // To minimize the possibility of a false positive, we use the logic here:
            var updateLikelyTriggeredExternally = 
            // Since we enforce only calling `register()` once, and since we don't
            // add the `updatefound` event listener until the `register()` call, if
            // `_updateFoundCount` is > 0 then it means this method has already
            // been called, thus this SW must be external
            _this._updateFoundCount > 0 ||
                // If the script URL of the installing SW is different from this
                // instance's script URL, we know it's definitely not from our
                // registration.
                !urlsMatch_js_1.urlsMatch(installingSW.scriptURL, _this._scriptURL) ||
                // If all of the above are false, then we use a time-based heuristic:
                // Any `updatefound` event that occurs long after our registration is
                // assumed to be external.
                (performance.now() >
                    _this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?
                // If any of the above are not true, we assume the update was
                // triggered by this instance.
                true : false;
            if (updateLikelyTriggeredExternally) {
                _this._externalSW = installingSW;
                registration.removeEventListener('updatefound', _this._onUpdateFound);
            }
            else {
                // If the update was not triggered externally we know the installing
                // SW is the one we registered, so we set it.
                _this._sw = installingSW;
                _this._ownSWs.add(installingSW);
                _this._swDeferred.resolve(installingSW);
                // The `installing` state isn't something we have a dedicated
                // callback for, but we do log messages for it in development.
                if (process.env.NODE_ENV !== 'production') {
                    if (navigator.serviceWorker.controller) {
                        logger_js_1.logger.log('Updated service worker found. Installing now...');
                    }
                    else {
                        logger_js_1.logger.log('Service worker is installing...');
                    }
                }
            }
            // Increment the `updatefound` count, so future invocations of this
            // method can be sure they were triggered externally.
            ++_this._updateFoundCount;
            // Add a `statechange` listener regardless of whether this update was
            // triggered externally, since we have callbacks for both.
            installingSW.addEventListener('statechange', _this._onStateChange);
        };
        /**
         * @private
         * @param {Event} originalEvent
         */
        _this._onStateChange = function (originalEvent) {
            // `this._registration` will never be `undefined` after an update is found.
            var registration = _this._registration;
            var sw = originalEvent.target;
            var state = sw.state;
            var isExternal = sw === _this._externalSW;
            var eventPrefix = isExternal ? 'external' : '';
            var eventProps = {
                sw: sw,
                originalEvent: originalEvent
            };
            if (!isExternal && _this._isUpdate) {
                eventProps.isUpdate = true;
            }
            _this.dispatchEvent(new WorkboxEvent_js_1.WorkboxEvent(eventPrefix + state, eventProps));
            if (state === 'installed') {
                // This timeout is used to ignore cases where the service worker calls
                // `skipWaiting()` in the install event, thus moving it directly in the
                // activating state. (Since all service workers *must* go through the
                // waiting phase, the only way to detect `skipWaiting()` called in the
                // install event is to observe that the time spent in the waiting phase
                // is very short.)
                // NOTE: we don't need separate timeouts for the own and external SWs
                // since they can't go through these phases at the same time.
                _this._waitingTimeout = self.setTimeout(function () {
                    // Ensure the SW is still waiting (it may now be redundant).
                    if (state === 'installed' && registration.waiting === sw) {
                        _this.dispatchEvent(new WorkboxEvent_js_1.WorkboxEvent(eventPrefix + 'waiting', eventProps));
                        if (process.env.NODE_ENV !== 'production') {
                            if (isExternal) {
                                logger_js_1.logger.warn('An external service worker has installed but is ' +
                                    'waiting for this client to close before activating...');
                            }
                            else {
                                logger_js_1.logger.warn('The service worker has installed but is waiting ' +
                                    'for existing clients to close before activating...');
                            }
                        }
                    }
                }, WAITING_TIMEOUT_DURATION);
            }
            else if (state === 'activating') {
                clearTimeout(_this._waitingTimeout);
                if (!isExternal) {
                    _this._activeDeferred.resolve(sw);
                }
            }
            if (process.env.NODE_ENV !== 'production') {
                switch (state) {
                    case 'installed':
                        if (isExternal) {
                            logger_js_1.logger.warn('An external service worker has installed. ' +
                                'You may want to suggest users reload this page.');
                        }
                        else {
                            logger_js_1.logger.log('Registered service worker installed.');
                        }
                        break;
                    case 'activated':
                        if (isExternal) {
                            logger_js_1.logger.warn('An external service worker has activated.');
                        }
                        else {
                            logger_js_1.logger.log('Registered service worker activated.');
                            if (sw !== navigator.serviceWorker.controller) {
                                logger_js_1.logger.warn('The registered service worker is active but ' +
                                    'not yet controlling the page. Reload or run ' +
                                    '`clients.claim()` in the service worker.');
                            }
                        }
                        break;
                    case 'redundant':
                        if (sw === _this._compatibleControllingSW) {
                            logger_js_1.logger.log('Previously controlling service worker now redundant!');
                        }
                        else if (!isExternal) {
                            logger_js_1.logger.log('Registered service worker now redundant!');
                        }
                        break;
                }
            }
        };
        /**
         * @private
         * @param {Event} originalEvent
         */
        _this._onControllerChange = function (originalEvent) {
            var sw = _this._sw;
            if (sw === navigator.serviceWorker.controller) {
                _this.dispatchEvent(new WorkboxEvent_js_1.WorkboxEvent('controlling', {
                    sw: sw,
                    originalEvent: originalEvent,
                    isUpdate: _this._isUpdate
                }));
                if (process.env.NODE_ENV !== 'production') {
                    logger_js_1.logger.log('Registered service worker now controlling this page.');
                }
                _this._controllingDeferred.resolve(sw);
            }
        };
        /**
         * @private
         * @param {Event} originalEvent
         */
        _this._onMessage = function (originalEvent) { return __awaiter(_this, void 0, void 0, function () {
            var data, source;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = originalEvent.data, source = originalEvent.source;
                        // Wait until there's an "own" service worker. This is used to buffer
                        // `message` events that may be received prior to calling `register()`.
                        return [4 /*yield*/, this.getSW()];
                    case 1:
                        // Wait until there's an "own" service worker. This is used to buffer
                        // `message` events that may be received prior to calling `register()`.
                        _a.sent();
                        // If the service worker that sent the message is in the list of own
                        // service workers for this instance, dispatch a `message` event.
                        // NOTE: we check for all previously owned service workers rather than
                        // just the current one because some messages (e.g. cache updates) use
                        // a timeout when sent and may be delayed long enough for a service worker
                        // update to be found.
                        if (this._ownSWs.has(source)) {
                            this.dispatchEvent(new WorkboxEvent_js_1.WorkboxEvent('message', {
                                data: data,
                                sw: source,
                                originalEvent: originalEvent
                            }));
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        _this._scriptURL = scriptURL;
        _this._registerOptions = registerOptions;
        // Add a message listener immediately since messages received during
        // page load are buffered only until the DOMContentLoaded event:
        // https://github.com/GoogleChrome/workbox/issues/2202
        navigator.serviceWorker.addEventListener('message', _this._onMessage);
        return _this;
    }
    /**
     * Registers a service worker for this instances script URL and service
     * worker options. By default this method delays registration until after
     * the window has loaded.
     *
     * @param {Object} [options]
     * @param {Function} [options.immediate=false] Setting this to true will
     *     register the service worker immediately, even if the window has
     *     not loaded (not recommended).
     */
    Workbox.prototype.register = function (_a) {
        var _b = (_a === void 0 ? {} : _a).immediate, immediate = _b === void 0 ? false : _b;
        return __awaiter(this, void 0, void 0, function () {
            var _c, waitingSW, currentPageIsOutOfScope;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (process.env.NODE_ENV !== 'production') {
                            if (this._registrationTime) {
                                logger_js_1.logger.error('Cannot re-register a Workbox instance after it has ' +
                                    'been registered. Create a new instance instead.');
                                return [2 /*return*/];
                            }
                        }
                        if (!(!immediate && document.readyState !== 'complete')) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (res) { return window.addEventListener('load', res); })];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        // Set this flag to true if any service worker was controlling the page
                        // at registration time.
                        this._isUpdate = Boolean(navigator.serviceWorker.controller);
                        // Before registering, attempt to determine if a SW is already controlling
                        // the page, and if that SW script (and version, if specified) matches this
                        // instance's script.
                        this._compatibleControllingSW = this._getControllingSWIfCompatible();
                        _c = this;
                        return [4 /*yield*/, this._registerScript()];
                    case 3:
                        _c._registration = _d.sent();
                        // If we have a compatible controller, store the controller as the "own"
                        // SW, resolve active/controlling deferreds and add necessary listeners.
                        if (this._compatibleControllingSW) {
                            this._sw = this._compatibleControllingSW;
                            this._activeDeferred.resolve(this._compatibleControllingSW);
                            this._controllingDeferred.resolve(this._compatibleControllingSW);
                            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });
                        }
                        waitingSW = this._registration.waiting;
                        if (waitingSW && urlsMatch_js_1.urlsMatch(waitingSW.scriptURL, this._scriptURL)) {
                            // Store the waiting SW as the "own" Sw, even if it means overwriting
                            // a compatible controller.
                            this._sw = waitingSW;
                            // Run this in the next microtask, so any code that adds an event
                            // listener after awaiting `register()` will get this event.
                            dontWaitFor_js_1.dontWaitFor(Promise.resolve().then(function () {
                                _this.dispatchEvent(new WorkboxEvent_js_1.WorkboxEvent('waiting', {
                                    sw: waitingSW,
                                    wasWaitingBeforeRegister: true
                                }));
                                if (process.env.NODE_ENV !== 'production') {
                                    logger_js_1.logger.warn('A service worker was already waiting to activate ' +
                                        'before this script was registered...');
                                }
                            }));
                        }
                        // If an "own" SW is already set, resolve the deferred.
                        if (this._sw) {
                            this._swDeferred.resolve(this._sw);
                            this._ownSWs.add(this._sw);
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.log('Successfully registered service worker.', this._scriptURL);
                            if (navigator.serviceWorker.controller) {
                                if (this._compatibleControllingSW) {
                                    logger_js_1.logger.debug('A service worker with the same script URL ' +
                                        'is already controlling this page.');
                                }
                                else {
                                    logger_js_1.logger.debug('A service worker with a different script URL is ' +
                                        'currently controlling the page. The browser is now fetching ' +
                                        'the new script now...');
                                }
                            }
                            currentPageIsOutOfScope = function () {
                                var scopeURL = new URL(_this._registerOptions.scope || _this._scriptURL, document.baseURI);
                                var scopeURLBasePath = new URL('./', scopeURL.href).pathname;
                                return !location.pathname.startsWith(scopeURLBasePath);
                            };
                            if (currentPageIsOutOfScope()) {
                                logger_js_1.logger.warn('The current page is not in scope for the registered ' +
                                    'service worker. Was this a mistake?');
                            }
                        }
                        this._registration.addEventListener('updatefound', this._onUpdateFound);
                        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, { once: true });
                        return [2 /*return*/, this._registration];
                }
            });
        });
    };
    /**
     * Checks for updates of the registered service worker.
     */
    Workbox.prototype.update = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._registration) {
                            if (process.env.NODE_ENV !== 'production') {
                                logger_js_1.logger.error('Cannot update a Workbox instance without ' +
                                    'being registered. Register the Workbox instance first.');
                            }
                            return [2 /*return*/];
                        }
                        // Try to update registration
                        return [4 /*yield*/, this._registration.update()];
                    case 1:
                        // Try to update registration
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(Workbox.prototype, "active", {
        /**
         * Resolves to the service worker registered by this instance as soon as it
         * is active. If a service worker was already controlling at registration
         * time then it will resolve to that if the script URLs (and optionally
         * script versions) match, otherwise it will wait until an update is found
         * and activates.
         *
         * @return {Promise<ServiceWorker>}
         */
        get: function () {
            return this._activeDeferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Workbox.prototype, "controlling", {
        /**
         * Resolves to the service worker registered by this instance as soon as it
         * is controlling the page. If a service worker was already controlling at
         * registration time then it will resolve to that if the script URLs (and
         * optionally script versions) match, otherwise it will wait until an update
         * is found and starts controlling the page.
         * Note: the first time a service worker is installed it will active but
         * not start controlling the page unless `clients.claim()` is called in the
         * service worker.
         *
         * @return {Promise<ServiceWorker>}
         */
        get: function () {
            return this._controllingDeferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Resolves with a reference to a service worker that matches the script URL
     * of this instance, as soon as it's available.
     *
     * If, at registration time, there's already an active or waiting service
     * worker with a matching script URL, it will be used (with the waiting
     * service worker taking precedence over the active service worker if both
     * match, since the waiting service worker would have been registered more
     * recently).
     * If there's no matching active or waiting service worker at registration
     * time then the promise will not resolve until an update is found and starts
     * installing, at which point the installing service worker is used.
     *
     * @return {Promise<ServiceWorker>}
     */
    Workbox.prototype.getSW = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                // If `this._sw` is set, resolve with that as we want `getSW()` to
                // return the correct (new) service worker if an update is found.
                return [2 /*return*/, this._sw !== undefined ? this._sw : this._swDeferred.promise];
            });
        });
    };
    /**
     * Sends the passed data object to the service worker registered by this
     * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves
     * with a response (if any).
     *
     * A response can be set in a message handler in the service worker by
     * calling `event.ports[0].postMessage(...)`, which will resolve the promise
     * returned by `messageSW()`. If no response is set, the promise will never
     * resolve.
     *
     * @param {Object} data An object to send to the service worker
     * @return {Promise<Object>}
     */
    Workbox.prototype.messageSW = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var sw;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSW()];
                    case 1:
                        sw = _a.sent();
                        return [2 /*return*/, messageSW_js_1.messageSW(sw, data)];
                }
            });
        });
    };
    /**
     * Checks for a service worker already controlling the page and returns
     * it if its script URL matches.
     *
     * @private
     * @return {ServiceWorker|undefined}
     */
    Workbox.prototype._getControllingSWIfCompatible = function () {
        var controller = navigator.serviceWorker.controller;
        if (controller && urlsMatch_js_1.urlsMatch(controller.scriptURL, this._scriptURL)) {
            return controller;
        }
        else {
            return undefined;
        }
    };
    /**
     * Registers a service worker for this instances script URL and register
     * options and tracks the time registration was complete.
     *
     * @private
     */
    Workbox.prototype._registerScript = function () {
        return __awaiter(this, void 0, void 0, function () {
            var reg, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, navigator.serviceWorker.register(this._scriptURL, this._registerOptions)];
                    case 1:
                        reg = _a.sent();
                        // Keep track of when registration happened, so it can be used in the
                        // `this._onUpdateFound` heuristic. Also use the presence of this
                        // property as a way to see if `.register()` has been called.
                        this._registrationTime = performance.now();
                        return [2 /*return*/, reg];
                    case 2:
                        error_1 = _a.sent();
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.error(error_1);
                        }
                        // Re-throw the error.
                        throw error_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return Workbox;
}(WorkboxEventTarget_js_1.WorkboxEventTarget));
exports.Workbox = Workbox;
// The jsdoc comments below outline the events this instance may dispatch:
// -----------------------------------------------------------------------
/**
 * The `message` event is dispatched any time a `postMessage` is received.
 *
 * @event module:workbox-window.Workbox#message
 * @type {WorkboxEvent}
 * @property {*} data The `data` property from the original `message` event.
 * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
 *     event.
 * @property {string} type `message`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `installed` event is dispatched if the state of a
 * [`Workbox`]{@link module:workbox-window.Workbox} instance's
 * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to `installed`.
 *
 * Then can happen either the very first time a service worker is installed,
 * or after an update to the current service worker is found. In the case
 * of an update being found, the event's `isUpdate` property will be `true`.
 *
 * @event module:workbox-window.Workbox#installed
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this `Workbox` instance called `register()`.
 * @property {string} type `installed`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `waiting` event is dispatched if the state of a
 * [`Workbox`]{@link module:workbox-window.Workbox} instance's
 * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to `installed` and then doesn't immediately change to `activating`.
 * It may also be dispatched if a service worker with the same
 * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}
 * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}
 * method was called.
 *
 * @event module:workbox-window.Workbox#waiting
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event|undefined} originalEvent The original
 *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event, or `undefined` in the case where the service worker was waiting
 *     to before `.register()` was called.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this `Workbox` instance called `register()`.
 * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with
 *     a matching `scriptURL` was already waiting when this `Workbox`
 *     instance called `register()`.
 * @property {string} type `waiting`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `controlling` event is dispatched if a
 * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}
 * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}
 * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}
 * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}
 * matches the `scriptURL` of the `Workbox` instance's
 * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.
 *
 * @event module:workbox-window.Workbox#controlling
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this service worker was registered.
 * @property {string} type `controlling`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `activated` event is dispatched if the state of a
 * [`Workbox`]{@link module:workbox-window.Workbox} instance's
 * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to `activated`.
 *
 * @event module:workbox-window.Workbox#activated
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this `Workbox` instance called `register()`.
 * @property {string} type `activated`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `redundant` event is dispatched if the state of a
 * [`Workbox`]{@link module:workbox-window.Workbox} instance's
 * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}
 * changes to `redundant`.
 *
 * @event module:workbox-window.Workbox#redundant
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {boolean|undefined} isUpdate True if a service worker was already
 *     controlling when this `Workbox` instance called `register()`.
 * @property {string} type `redundant`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `externalinstalled` event is dispatched if the state of an
 * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}
 * changes to `installed`.
 *
 * @event module:workbox-window.Workbox#externalinstalled
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type `externalinstalled`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `externalwaiting` event is dispatched if the state of an
 * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}
 * changes to `waiting`.
 *
 * @event module:workbox-window.Workbox#externalwaiting
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type `externalwaiting`.
 * @property {Workbox} target The `Workbox` instance.
 */
/**
 * The `externalactivated` event is dispatched if the state of an
 * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}
 * changes to `activated`.
 *
 * @event module:workbox-window.Workbox#externalactivated
 * @type {WorkboxEvent}
 * @property {ServiceWorker} sw The service worker instance.
 * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}
 *     event.
 * @property {string} type `externalactivated`.
 * @property {Workbox} target The `Workbox` instance.
 */
