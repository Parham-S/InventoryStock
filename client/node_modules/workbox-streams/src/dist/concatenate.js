"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
exports.__esModule = true;
exports.concatenate = void 0;
var logger_js_1 = require("workbox-core/_private/logger.js");
var assert_js_1 = require("workbox-core/_private/assert.js");
var Deferred_js_1 = require("workbox-core/_private/Deferred.js");
require("./_version.js");
/**
 * Takes either a Response, a ReadableStream, or a
 * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the
 * ReadableStreamReader object associated with it.
 *
 * @param {module:workbox-streams.StreamSource} source
 * @return {ReadableStreamReader}
 * @private
 */
function _getReaderFromSource(source) {
    if (source instanceof Response) {
        return source.body.getReader();
    }
    if (source instanceof ReadableStream) {
        return source.getReader();
    }
    return new Response(source).body.getReader();
}
/**
 * Takes multiple source Promises, each of which could resolve to a Response, a
 * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).
 *
 * Returns an object exposing a ReadableStream with each individual stream's
 * data returned in sequence, along with a Promise which signals when the
 * stream is finished (useful for passing to a FetchEvent's waitUntil()).
 *
 * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises
 * @return {Object<{done: Promise, stream: ReadableStream}>}
 *
 * @memberof module:workbox-streams
 */
function concatenate(sourcePromises) {
    if (process.env.NODE_ENV !== 'production') {
        assert_js_1.assert.isArray(sourcePromises, {
            moduleName: 'workbox-streams',
            funcName: 'concatenate',
            paramName: 'sourcePromises'
        });
    }
    var readerPromises = sourcePromises.map(function (sourcePromise) {
        return Promise.resolve(sourcePromise).then(function (source) {
            return _getReaderFromSource(source);
        });
    });
    var streamDeferred = new Deferred_js_1.Deferred();
    var i = 0;
    var logMessages = [];
    var stream = new ReadableStream({
        pull: function (controller) {
            var _this = this;
            return readerPromises[i]
                .then(function (reader) { return reader.read(); })
                .then(function (result) {
                if (result.done) {
                    if (process.env.NODE_ENV !== 'production') {
                        logMessages.push(['Reached the end of source:',
                            sourcePromises[i]]);
                    }
                    i++;
                    if (i >= readerPromises.length) {
                        // Log all the messages in the group at once in a single group.
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.groupCollapsed("Concatenating " + readerPromises.length + " sources.");
                            for (var _i = 0, logMessages_1 = logMessages; _i < logMessages_1.length; _i++) {
                                var message = logMessages_1[_i];
                                if (Array.isArray(message)) {
                                    logger_js_1.logger.log.apply(logger_js_1.logger, message);
                                }
                                else {
                                    logger_js_1.logger.log(message);
                                }
                            }
                            logger_js_1.logger.log('Finished reading all sources.');
                            logger_js_1.logger.groupEnd();
                        }
                        controller.close();
                        streamDeferred.resolve();
                        return;
                    }
                    // The `pull` method is defined because we're inside it.
                    return _this.pull(controller);
                }
                else {
                    controller.enqueue(result.value);
                }
            })["catch"](function (error) {
                if (process.env.NODE_ENV !== 'production') {
                    logger_js_1.logger.error('An error occurred:', error);
                }
                streamDeferred.reject(error);
                throw error;
            });
        },
        cancel: function () {
            if (process.env.NODE_ENV !== 'production') {
                logger_js_1.logger.warn('The ReadableStream was cancelled.');
            }
            streamDeferred.resolve();
        }
    });
    return { done: streamDeferred.promise, stream: stream };
}
exports.concatenate = concatenate;
