"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.NavigationRoute = void 0;
var assert_js_1 = require("workbox-core/_private/assert.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var Route_js_1 = require("./Route.js");
require("./_version.js");
/**
 * NavigationRoute makes it easy to create a
 * [Route]{@link module:workbox-routing.Route} that matches for browser
 * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.
 *
 * It will only match incoming Requests whose
 * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}
 * is set to `navigate`.
 *
 * You can optionally only apply this route to a subset of navigation requests
 * by using one or both of the `denylist` and `allowlist` parameters.
 *
 * @memberof module:workbox-routing
 * @extends module:workbox-routing.Route
 */
var NavigationRoute = /** @class */ (function (_super) {
    __extends(NavigationRoute, _super);
    /**
     * If both `denylist` and `allowlist` are provided, the `denylist` will
     * take precedence and the request will not match this route.
     *
     * The regular expressions in `allowlist` and `denylist`
     * are matched against the concatenated
     * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}
     * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}
     * portions of the requested URL.
     *
     * @param {module:workbox-routing~handlerCallback} handler A callback
     * function that returns a Promise resulting in a Response.
     * @param {Object} options
     * @param {Array<RegExp>} [options.denylist] If any of these patterns match,
     * the route will not handle the request (even if a allowlist RegExp matches).
     * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns
     * match the URL's pathname and search parameter, the route will handle the
     * request (assuming the denylist doesn't match).
     */
    function NavigationRoute(handler, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.allowlist, allowlist = _c === void 0 ? [/./] : _c, _d = _b.denylist, denylist = _d === void 0 ? [] : _d;
        var _this = this;
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isArrayOfClass(allowlist, RegExp, {
                moduleName: 'workbox-routing',
                className: 'NavigationRoute',
                funcName: 'constructor',
                paramName: 'options.allowlist'
            });
            assert_js_1.assert.isArrayOfClass(denylist, RegExp, {
                moduleName: 'workbox-routing',
                className: 'NavigationRoute',
                funcName: 'constructor',
                paramName: 'options.denylist'
            });
        }
        _this = _super.call(this, function (options) { return _this._match(options); }, handler) || this;
        _this._allowlist = allowlist;
        _this._denylist = denylist;
        return _this;
    }
    /**
     * Routes match handler.
     *
     * @param {Object} options
     * @param {URL} options.url
     * @param {Request} options.request
     * @return {boolean}
     *
     * @private
     */
    NavigationRoute.prototype._match = function (_a) {
        var url = _a.url, request = _a.request;
        if (request && request.mode !== 'navigate') {
            return false;
        }
        var pathnameAndSearch = url.pathname + url.search;
        for (var _i = 0, _b = this._denylist; _i < _b.length; _i++) {
            var regExp = _b[_i];
            if (regExp.test(pathnameAndSearch)) {
                if (process.env.NODE_ENV !== 'production') {
                    logger_js_1.logger.log("The navigation route " + pathnameAndSearch + " is not " +
                        "being used, since the URL matches this denylist pattern: " +
                        ("" + regExp));
                }
                return false;
            }
        }
        if (this._allowlist.some(function (regExp) { return regExp.test(pathnameAndSearch); })) {
            if (process.env.NODE_ENV !== 'production') {
                logger_js_1.logger.debug("The navigation route " + pathnameAndSearch + " " +
                    "is being used.");
            }
            return true;
        }
        if (process.env.NODE_ENV !== 'production') {
            logger_js_1.logger.log("The navigation route " + pathnameAndSearch + " is not " +
                "being used, since the URL being navigated to doesn't " +
                "match the allowlist.");
        }
        return false;
    };
    return NavigationRoute;
}(Route_js_1.Route));
exports.NavigationRoute = NavigationRoute;
