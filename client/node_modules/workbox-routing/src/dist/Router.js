"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.Router = void 0;
var assert_js_1 = require("workbox-core/_private/assert.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var WorkboxError_js_1 = require("workbox-core/_private/WorkboxError.js");
var getFriendlyURL_js_1 = require("workbox-core/_private/getFriendlyURL.js");
var normalizeHandler_js_1 = require("./utils/normalizeHandler.js");
require("./_version.js");
/**
 * The Router can be used to process a FetchEvent through one or more
 * [Routes]{@link module:workbox-routing.Route} responding  with a Request if
 * a matching route exists.
 *
 * If no route matches a given a request, the Router will use a "default"
 * handler if one is defined.
 *
 * Should the matching Route throw an error, the Router will use a "catch"
 * handler if one is defined to gracefully deal with issues and respond with a
 * Request.
 *
 * If a request matches multiple routes, the **earliest** registered route will
 * be used to respond to the request.
 *
 * @memberof module:workbox-routing
 */
var Router = /** @class */ (function () {
    /**
     * Initializes a new Router.
     */
    function Router() {
        this._routes = new Map();
    }
    Object.defineProperty(Router.prototype, "routes", {
        /**
         * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP
         * method name ('GET', etc.) to an array of all the corresponding `Route`
         * instances that are registered.
         */
        get: function () {
            return this._routes;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds a fetch event listener to respond to events when a route matches
     * the event's request.
     */
    Router.prototype.addFetchListener = function () {
        var _this = this;
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('fetch', (function (event) {
            var request = event.request;
            var responsePromise = _this.handleRequest({ request: request, event: event });
            if (responsePromise) {
                event.respondWith(responsePromise);
            }
        }));
    };
    /**
     * Adds a message event listener for URLs to cache from the window.
     * This is useful to cache resources loaded on the page prior to when the
     * service worker started controlling it.
     *
     * The format of the message data sent from the window should be as follows.
     * Where the `urlsToCache` array may consist of URL strings or an array of
     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
     *
     * ```
     * {
     *   type: 'CACHE_URLS',
     *   payload: {
     *     urlsToCache: [
     *       './script1.js',
     *       './script2.js',
     *       ['./script3.js', {mode: 'no-cors'}],
     *     ],
     *   },
     * }
     * ```
     */
    Router.prototype.addCacheListener = function () {
        var _this = this;
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('message', (function (event) {
            if (event.data && event.data.type === 'CACHE_URLS') {
                var payload = event.data.payload;
                if (process.env.NODE_ENV !== 'production') {
                    logger_js_1.logger.debug("Caching URLs from the window", payload.urlsToCache);
                }
                var requestPromises = Promise.all(payload.urlsToCache.map(function (entry) {
                    if (typeof entry === 'string') {
                        entry = [entry];
                    }
                    var request = new (Request.bind.apply(Request, __spreadArrays([void 0], entry)))();
                    return _this.handleRequest({ request: request });
                    // TODO(philipwalton): TypeScript errors without this typecast for
                    // some reason (probably a bug). The real type here should work but
                    // doesn't: `Array<Promise<Response> | undefined>`.
                })); // TypeScript
                event.waitUntil(requestPromises);
                // If a MessageChannel was used, reply to the message on success.
                if (event.ports && event.ports[0]) {
                    requestPromises.then(function () { return event.ports[0].postMessage(true); });
                }
            }
        }));
    };
    /**
     * Apply the routing rules to a FetchEvent object to get a Response from an
     * appropriate Route's handler.
     *
     * @param {Object} options
     * @param {Request} options.request The request to handle (this is usually
     *     from a fetch event, but it does not have to be).
     * @param {FetchEvent} [options.event] The event that triggered the request,
     *     if applicable.
     * @return {Promise<Response>|undefined} A promise is returned if a
     *     registered route can handle the request. If there is no matching
     *     route and there's no `defaultHandler`, `undefined` is returned.
     */
    Router.prototype.handleRequest = function (_a) {
        var _this = this;
        var request = _a.request, event = _a.event;
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isInstance(request, Request, {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'handleRequest',
                paramName: 'options.request'
            });
        }
        var url = new URL(request.url, location.href);
        if (!url.protocol.startsWith('http')) {
            if (process.env.NODE_ENV !== 'production') {
                logger_js_1.logger.debug("Workbox Router only supports URLs that start with 'http'.");
            }
            return;
        }
        var _b = this.findMatchingRoute({ url: url, request: request, event: event }), params = _b.params, route = _b.route;
        var handler = route && route.handler;
        var debugMessages = [];
        if (process.env.NODE_ENV !== 'production') {
            if (handler) {
                debugMessages.push([
                    "Found a route to handle this request:",
                    route,
                ]);
                if (params) {
                    debugMessages.push([
                        "Passing the following params to the route's handler:",
                        params,
                    ]);
                }
            }
        }
        // If we don't have a handler because there was no matching route, then
        // fall back to defaultHandler if that's defined.
        if (!handler && this._defaultHandler) {
            if (process.env.NODE_ENV !== 'production') {
                debugMessages.push("Failed to find a matching route. Falling " +
                    "back to the default handler.");
            }
            handler = this._defaultHandler;
        }
        if (!handler) {
            if (process.env.NODE_ENV !== 'production') {
                // No handler so Workbox will do nothing. If logs is set of debug
                // i.e. verbose, we should print out this information.
                logger_js_1.logger.debug("No route found for: " + getFriendlyURL_js_1.getFriendlyURL(url));
            }
            return;
        }
        if (process.env.NODE_ENV !== 'production') {
            // We have a handler, meaning Workbox is going to handle the route.
            // print the routing details to the console.
            logger_js_1.logger.groupCollapsed("Router is responding to: " + getFriendlyURL_js_1.getFriendlyURL(url));
            debugMessages.forEach(function (msg) {
                if (Array.isArray(msg)) {
                    logger_js_1.logger.log.apply(logger_js_1.logger, msg);
                }
                else {
                    logger_js_1.logger.log(msg);
                }
            });
            logger_js_1.logger.groupEnd();
        }
        // Wrap in try and catch in case the handle method throws a synchronous
        // error. It should still callback to the catch handler.
        var responsePromise;
        try {
            responsePromise = handler.handle({ url: url, request: request, event: event, params: params });
        }
        catch (err) {
            responsePromise = Promise.reject(err);
        }
        if (responsePromise instanceof Promise && this._catchHandler) {
            responsePromise = responsePromise["catch"](function (err) {
                if (process.env.NODE_ENV !== 'production') {
                    // Still include URL here as it will be async from the console group
                    // and may not make sense without the URL
                    logger_js_1.logger.groupCollapsed("Error thrown when responding to: " +
                        (" " + getFriendlyURL_js_1.getFriendlyURL(url) + ". Falling back to Catch Handler."));
                    logger_js_1.logger.error("Error thrown by:", route);
                    logger_js_1.logger.error(err);
                    logger_js_1.logger.groupEnd();
                }
                return _this._catchHandler.handle({ url: url, request: request, event: event });
            });
        }
        return responsePromise;
    };
    /**
     * Checks a request and URL (and optionally an event) against the list of
     * registered routes, and if there's a match, returns the corresponding
     * route along with any params generated by the match.
     *
     * @param {Object} options
     * @param {URL} options.url
     * @param {Request} options.request The request to match.
     * @param {Event} [options.event] The corresponding event (unless N/A).
     * @return {Object} An object with `route` and `params` properties.
     *     They are populated if a matching route was found or `undefined`
     *     otherwise.
     */
    Router.prototype.findMatchingRoute = function (_a) {
        var url = _a.url, request = _a.request, event = _a.event;
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isInstance(url, URL, {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'findMatchingRoute',
                paramName: 'options.url'
            });
            assert_js_1.assert.isInstance(request, Request, {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'findMatchingRoute',
                paramName: 'options.request'
            });
        }
        var routes = this._routes.get(request.method) || [];
        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
            var route = routes_1[_i];
            var params = void 0;
            var matchResult = route.match({ url: url, request: request, event: event });
            if (matchResult) {
                // See https://github.com/GoogleChrome/workbox/issues/2079
                params = matchResult;
                if (Array.isArray(matchResult) && matchResult.length === 0) {
                    // Instead of passing an empty array in as params, use undefined.
                    params = undefined;
                }
                else if ((matchResult.constructor === Object &&
                    Object.keys(matchResult).length === 0)) {
                    // Instead of passing an empty object in as params, use undefined.
                    params = undefined;
                }
                else if (typeof matchResult === 'boolean') {
                    // For the boolean value true (rather than just something truth-y),
                    // don't set params.
                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
                    params = undefined;
                }
                // Return early if have a match.
                return { route: route, params: params };
            }
        }
        // If no match was found above, return and empty object.
        return {};
    };
    /**
     * Define a default `handler` that's called when no routes explicitly
     * match the incoming request.
     *
     * Without a default handler, unmatched requests will go against the
     * network as if there were no service worker present.
     *
     * @param {module:workbox-routing~handlerCallback} handler A callback
     * function that returns a Promise resulting in a Response.
     */
    Router.prototype.setDefaultHandler = function (handler) {
        this._defaultHandler = normalizeHandler_js_1.normalizeHandler(handler);
    };
    /**
     * If a Route throws an error while handling a request, this `handler`
     * will be called and given a chance to provide a response.
     *
     * @param {module:workbox-routing~handlerCallback} handler A callback
     * function that returns a Promise resulting in a Response.
     */
    Router.prototype.setCatchHandler = function (handler) {
        this._catchHandler = normalizeHandler_js_1.normalizeHandler(handler);
    };
    /**
     * Registers a route with the router.
     *
     * @param {module:workbox-routing.Route} route The route to register.
     */
    Router.prototype.registerRoute = function (route) {
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isType(route, 'object', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route'
            });
            assert_js_1.assert.hasMethod(route, 'match', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route'
            });
            assert_js_1.assert.isType(route.handler, 'object', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route'
            });
            assert_js_1.assert.hasMethod(route.handler, 'handle', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route.handler'
            });
            assert_js_1.assert.isType(route.method, 'string', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route.method'
            });
        }
        if (!this._routes.has(route.method)) {
            this._routes.set(route.method, []);
        }
        // Give precedence to all of the earlier routes by adding this additional
        // route to the end of the array.
        this._routes.get(route.method).push(route);
    };
    /**
     * Unregisters a route with the router.
     *
     * @param {module:workbox-routing.Route} route The route to unregister.
     */
    Router.prototype.unregisterRoute = function (route) {
        if (!this._routes.has(route.method)) {
            throw new WorkboxError_js_1.WorkboxError('unregister-route-but-not-found-with-method', {
                method: route.method
            });
        }
        var routeIndex = this._routes.get(route.method).indexOf(route);
        if (routeIndex > -1) {
            this._routes.get(route.method).splice(routeIndex, 1);
        }
        else {
            throw new WorkboxError_js_1.WorkboxError('unregister-route-route-not-registered');
        }
    };
    return Router;
}());
exports.Router = Router;
