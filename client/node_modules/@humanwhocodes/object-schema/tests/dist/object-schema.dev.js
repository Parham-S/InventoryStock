/**
 * @filedescription Object Schema Tests
 */

/* global it, describe, beforeEach */
"use strict"; //-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

var assert = require("chai").assert;

var _require = require("../src/"),
    ObjectSchema = _require.ObjectSchema; //-----------------------------------------------------------------------------
// Class
//-----------------------------------------------------------------------------


describe("ObjectSchema", function () {
  var schema;
  describe("new ObjectSchema()", function () {
    it("should add a new key when a strategy is passed", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {},
          validate: function validate() {}
        }
      });
      assert.isTrue(schema.hasKey("foo"));
    });
    it("should throw an error when a strategy is missing a merge() method", function () {
      assert["throws"](function () {
        schema = new ObjectSchema({
          foo: {
            validate: function validate() {}
          }
        });
      }, /Definition for key "foo" must have a merge property/);
    });
    it("should throw an error when a strategy is missing a merge() method", function () {
      assert["throws"](function () {
        schema = new ObjectSchema();
      }, /Schema definitions missing/);
    });
    it("should throw an error when a strategy is missing a validate() method", function () {
      assert["throws"](function () {
        schema = new ObjectSchema({
          foo: {
            merge: function merge() {}
          }
        });
      }, /Definition for key "foo" must have a validate\(\) method/);
    });
    it("should throw an error when merge is an invalid string", function () {
      assert["throws"](function () {
        new ObjectSchema({
          foo: {
            merge: "bar",
            validate: function validate() {}
          }
        });
      }, /key "foo" missing valid merge strategy/);
    });
    it("should throw an error when validate is an invalid string", function () {
      assert["throws"](function () {
        new ObjectSchema({
          foo: {
            merge: "assign",
            validate: "s"
          }
        });
      }, /key "foo" missing valid validation strategy/);
    });
  });
  describe("merge()", function () {
    it("should throw an error when an unexpected key is found", function () {
      var schema = new ObjectSchema({});
      assert["throws"](function () {
        schema.merge({
          foo: true
        }, {
          foo: true
        });
      }, /Unexpected key "foo"/);
    });
    it("should throw an error when merge() throws an error", function () {
      var schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            throw new Error("Boom!");
          },
          validate: function validate() {}
        }
      });
      assert["throws"](function () {
        schema.merge({
          foo: true
        }, {
          foo: true
        });
      }, /Key "foo": Boom!/);
    });
    it("should call the merge() strategy for one key when called", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: true
      }, {
        foo: false
      });
      assert.propertyVal(result, "foo", "bar");
    });
    it("should not call the merge() strategy when both objects don't contain the key", function () {
      var called = false;
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            called = true;
          },
          validate: function validate() {}
        }
      });
      schema.merge({}, {});
      assert.isFalse(called, "The merge() strategy should not have been called.");
    });
    it("should omit returning the key when the merge() strategy returns undefined", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return undefined;
          },
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: true
      }, {
        foo: false
      });
      assert.notProperty(result, "foo");
    });
    it("should call the merge() strategy for two keys when called", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        },
        bar: {
          merge: function merge() {
            return "baz";
          },
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: true,
        bar: 1
      }, {
        foo: true,
        bar: 2
      });
      assert.propertyVal(result, "foo", "bar");
      assert.propertyVal(result, "bar", "baz");
    });
    it("should call the merge() strategy for two keys when called on three objects", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        },
        bar: {
          merge: function merge() {
            return "baz";
          },
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: true,
        bar: 1
      }, {
        foo: true,
        bar: 3
      }, {
        foo: false,
        bar: 2
      });
      assert.propertyVal(result, "foo", "bar");
      assert.propertyVal(result, "bar", "baz");
    });
    it("should call the merge() strategy when defined as 'overwrite'", function () {
      schema = new ObjectSchema({
        foo: {
          merge: "overwrite",
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: true
      }, {
        foo: false
      });
      assert.propertyVal(result, "foo", false);
    });
    it("should call the merge() strategy when defined as 'assign'", function () {
      schema = new ObjectSchema({
        foo: {
          merge: "assign",
          validate: function validate() {}
        }
      });
      var result = schema.merge({
        foo: {
          bar: true
        }
      }, {
        foo: {
          baz: false
        }
      });
      assert.strictEqual(result.foo.bar, true);
      assert.strictEqual(result.foo.baz, false);
    });
    it("should call the merge strategy when there's a subschema", function () {
      schema = new ObjectSchema({
        name: {
          schema: {
            first: {
              merge: "replace",
              validate: "string"
            },
            last: {
              merge: "replace",
              validate: "string"
            }
          }
        }
      });
      var result = schema.merge({
        name: {
          first: "n",
          last: "z"
        }
      }, {
        name: {
          first: "g"
        }
      });
      assert.strictEqual(result.name.first, "g");
      assert.strictEqual(result.name.last, "z");
    });
    it("should not error when calling the merge strategy when there's a subschema and no matching key in second object", function () {
      schema = new ObjectSchema({
        name: {
          schema: {
            first: {
              merge: "replace",
              validate: "string"
            },
            last: {
              merge: "replace",
              validate: "string"
            }
          }
        }
      });
      var result = schema.merge({
        name: {
          first: "n",
          last: "z"
        }
      }, {});
      assert.strictEqual(result.name.first, "n");
      assert.strictEqual(result.name.last, "z");
    });
  });
  describe("validate()", function () {
    it("should throw an error when an unexpected key is found", function () {
      var schema = new ObjectSchema({});
      assert["throws"](function () {
        schema.validate({
          foo: true
        });
      }, /Unexpected key "foo"/);
    });
    it("should not throw an error when an expected key is found", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        }
      });
      schema.validate({
        foo: true
      });
    });
    it("should pass the property value into validate() when key is found", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate(value) {
            assert.isTrue(value);
          }
        }
      });
      schema.validate({
        foo: true
      });
    });
    it("should not throw an error when expected keys are found", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        },
        bar: {
          merge: function merge() {
            return "baz";
          },
          validate: function validate() {}
        }
      });
      schema.validate({
        foo: true,
        bar: true
      });
    });
    it("should not throw an error when expected keys are found with required keys", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        },
        bar: {
          requires: ["foo"],
          merge: function merge() {
            return "baz";
          },
          validate: function validate() {}
        }
      });
      schema.validate({
        foo: true,
        bar: true
      });
    });
    it("should throw an error when expected keys are found without required keys", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        },
        baz: {
          merge: function merge() {
            return "baz";
          },
          validate: function validate() {}
        },
        bar: {
          name: "bar",
          requires: ["foo", "baz"],
          merge: function merge() {},
          validate: function validate() {}
        }
      });
      assert["throws"](function () {
        schema.validate({
          bar: true
        });
      }, /Key "bar" requires keys "foo", "baz"./);
    });
    it("should throw an error when an expected key is found but is invalid", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {
            throw new Error("Invalid key.");
          }
        }
      });
      assert["throws"](function () {
        schema.validate({
          foo: true
        });
      }, /Key "foo": Invalid key/);
    });
    it("should throw an error when an expected key is found but is invalid with a string validator", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: "string"
        }
      });
      assert["throws"](function () {
        schema.validate({
          foo: true
        });
      }, /Key "foo": Expected a string/);
    });
    it("should throw an error when an expected key is found but is invalid with a number validator", function () {
      schema = new ObjectSchema({
        foo: {
          merge: function merge() {
            return "bar";
          },
          validate: "number"
        }
      });
      assert["throws"](function () {
        schema.validate({
          foo: true
        });
      }, /Key "foo": Expected a number/);
    });
    it("should throw an error when a required key is missing", function () {
      schema = new ObjectSchema({
        foo: {
          required: true,
          merge: function merge() {
            return "bar";
          },
          validate: function validate() {}
        }
      });
      assert["throws"](function () {
        schema.validate({});
      }, /Missing required key "foo"/);
    });
    it("should throw an error when a subschema is provided and the value doesn't validate", function () {
      schema = new ObjectSchema({
        name: {
          schema: {
            first: {
              merge: "replace",
              validate: "string"
            },
            last: {
              merge: "replace",
              validate: "string"
            }
          }
        }
      });
      assert["throws"](function () {
        schema.validate({
          name: {
            first: 123,
            last: "z"
          }
        });
      }, /Key "name": Key "first": Expected a string/);
    });
    it("should not throw an error when a subschema is provided and the value validates", function () {
      schema = new ObjectSchema({
        name: {
          schema: {
            first: {
              merge: "replace",
              validate: "string"
            },
            last: {
              merge: "replace",
              validate: "string"
            }
          }
        }
      });
      schema.validate({
        name: {
          first: "n",
          last: "z"
        }
      });
    });
  });
});