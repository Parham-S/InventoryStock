/**
 * @filedescription Object Schema
 */
"use strict"; //-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require("./merge-strategy"),
    MergeStrategy = _require.MergeStrategy;

var _require2 = require("./validation-strategy"),
    ValidationStrategy = _require2.ValidationStrategy; //-----------------------------------------------------------------------------
// Private
//-----------------------------------------------------------------------------


var strategies = Symbol("strategies");
var requiredKeys = Symbol("requiredKeys");
/**
 * Validates a schema strategy.
 * @param {string} name The name of the key this strategy is for.
 * @param {Object} strategy The strategy for the object key.
 * @param {boolean} [strategy.required=true] Whether the key is required.
 * @param {string[]} [strategy.requires] Other keys that are required when
 *      this key is present.
 * @param {Function} strategy.merge A method to call when merging two objects
 *      with the same key.
 * @param {Function} strategy.validate A method to call when validating an
 *      object with the key.
 * @returns {void}
 * @throws {Error} When the strategy is missing a name.
 * @throws {Error} When the strategy is missing a merge() method.
 * @throws {Error} When the strategy is missing a validate() method.
 */

function validateDefinition(name, strategy) {
  var hasSchema = false;

  if (strategy.schema) {
    if (_typeof(strategy.schema) === "object") {
      hasSchema = true;
    } else {
      throw new TypeError("Schema must be an object.");
    }
  }

  if (typeof strategy.merge === "string") {
    if (!(strategy.merge in MergeStrategy)) {
      throw new TypeError("Definition for key \"".concat(name, "\" missing valid merge strategy."));
    }
  } else if (!hasSchema && typeof strategy.merge !== "function") {
    throw new TypeError("Definition for key \"".concat(name, "\" must have a merge property."));
  }

  if (typeof strategy.validate === "string") {
    if (!(strategy.validate in ValidationStrategy)) {
      throw new TypeError("Definition for key \"".concat(name, "\" missing valid validation strategy."));
    }
  } else if (!hasSchema && typeof strategy.validate !== "function") {
    throw new TypeError("Definition for key \"".concat(name, "\" must have a validate() method."));
  }
} //-----------------------------------------------------------------------------
// Class
//-----------------------------------------------------------------------------

/**
 * Represents an object validation/merging schema.
 */


var ObjectSchema =
/*#__PURE__*/
function () {
  /**
   * Creates a new instance.
   */
  function ObjectSchema(definitions) {
    _classCallCheck(this, ObjectSchema);

    if (!definitions) {
      throw new Error("Schema definitions missing.");
    }
    /**
     * Track all strategies in the schema by key.
     * @type {Map}
     * @property strategies
     */


    this[strategies] = new Map();
    /**
     * Separately track any keys that are required for faster validation.
     * @type {Map}
     * @property requiredKeys
     */

    this[requiredKeys] = new Map(); // add in all strategies

    for (var _i = 0, _Object$keys = Object.keys(definitions); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      validateDefinition(key, definitions[key]); // normalize merge and validate methods if subschema is present

      if (_typeof(definitions[key].schema) === "object") {
        (function () {
          var schema = new ObjectSchema(definitions[key].schema);
          definitions[key] = _objectSpread({}, definitions[key], {
            merge: function merge(first, second) {
              if (first && second) {
                return schema.merge(first, second);
              }

              return MergeStrategy.assign(first, second);
            },
            validate: function validate(value) {
              ValidationStrategy.object(value);
              schema.validate(value);
            }
          });
        })();
      } // normalize the merge method in case there's a string


      if (typeof definitions[key].merge === "string") {
        definitions[key] = _objectSpread({}, definitions[key], {
          merge: MergeStrategy[definitions[key].merge]
        });
      }

      ; // normalize the validate method in case there's a string

      if (typeof definitions[key].validate === "string") {
        definitions[key] = _objectSpread({}, definitions[key], {
          validate: ValidationStrategy[definitions[key].validate]
        });
      }

      ;
      this[strategies].set(key, definitions[key]);

      if (definitions[key].required) {
        this[requiredKeys].set(key, definitions[key]);
      }
    }
  }
  /**
   * Determines if a strategy has been registered for the given object key.
   * @param {string} key The object key to find a strategy for.
   * @returns {boolean} True if the key has a strategy registered, false if not. 
   */


  _createClass(ObjectSchema, [{
    key: "hasKey",
    value: function hasKey(key) {
      return this[strategies].has(key);
    }
    /**
     * Merges objects together to create a new object comprised of the keys
     * of the all objects. Keys are merged based on the each key's merge
     * strategy.
     * @param {...Object} objects The objects to merge.
     * @returns {Object} A new object with a mix of all objects' keys.
     * @throws {Error} If any object is invalid.
     */

  }, {
    key: "merge",
    value: function merge() {
      var _this = this;

      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }

      // double check arguments
      if (objects.length < 2) {
        throw new Error("merge() requires at least two arguments.");
      }

      if (objects.some(function (object) {
        return object == null || _typeof(object) !== "object";
      })) {
        throw new Error("All arguments must be objects.");
      }

      return objects.reduce(function (result, object) {
        _this.validate(object);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _this[strategies][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                strategy = _step$value[1];

            try {
              if (key in result || key in object) {
                var value = strategy.merge.call(_this, result[key], object[key]);

                if (value !== undefined) {
                  result[key] = value;
                }
              }
            } catch (ex) {
              ex.message = "Key \"".concat(key, "\": ") + ex.message;
              throw ex;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return result;
      }, {});
    }
    /**
     * Validates an object's keys based on the validate strategy for each key.
     * @param {Object} object The object to validate.
     * @returns {void}
     * @throws {Error} When the object is invalid. 
     */

  }, {
    key: "validate",
    value: function validate(object) {
      // check existing keys first
      for (var _i2 = 0, _Object$keys2 = Object.keys(object); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];

        // check to see if the key is defined
        if (!this.hasKey(key)) {
          throw new Error("Unexpected key \"".concat(key, "\" found."));
        } // validate existing keys


        var strategy = this[strategies].get(key); // first check to see if any other keys are required

        if (Array.isArray(strategy.requires)) {
          if (!strategy.requires.every(function (otherKey) {
            return otherKey in object;
          })) {
            throw new Error("Key \"".concat(key, "\" requires keys \"").concat(strategy.requires.join("\", \""), "\"."));
          }
        } // now apply remaining validation strategy


        try {
          strategy.validate.call(strategy, object[key]);
        } catch (ex) {
          ex.message = "Key \"".concat(key, "\": ") + ex.message;
          throw ex;
        }
      } // ensure required keys aren't missing


      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this[requiredKeys][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 1),
              _key2 = _step2$value[0];

          if (!(_key2 in object)) {
            throw new Error("Missing required key \"".concat(_key2, "\"."));
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);

  return ObjectSchema;
}();

exports.ObjectSchema = ObjectSchema;