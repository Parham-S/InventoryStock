'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var path = _interopDefault(require('path'));

var minimatch = _interopDefault(require('minimatch'));

var createDebug = _interopDefault(require('debug'));

var objectSchema = require('@humanwhocodes/object-schema');
/**
 * @fileoverview ConfigSchema
 * @author Nicholas C. Zakas
 */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Assets that a given value is an array.
 * @param {*} value The value to check.
 * @returns {void}
 * @throws {TypeError} When the value is not an array. 
 */


function assertIsArray(value) {
  if (!Array.isArray(value)) {
    throw new TypeError('Expected value to be an array.');
  }
}
/**
 * Assets that a given value is an array containing only strings and functions.
 * @param {*} value The value to check.
 * @returns {void}
 * @throws {TypeError} When the value is not an array of strings and functions.
 */


function assertIsArrayOfStringsAndFunctions(value, name) {
  assertIsArray(value);

  if (value.some(function (item) {
    return typeof item !== 'string' && typeof item !== 'function';
  })) {
    throw new TypeError('Expected array to only contain strings.');
  }
} //------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The base schema that every ConfigArray uses.
 * @type Object
 */


var baseSchema = Object.freeze({
  name: {
    required: false,
    merge: function merge() {
      return undefined;
    },
    validate: function validate(value) {
      if (typeof value !== 'string') {
        throw new TypeError('Property must be a string.');
      }
    }
  },
  files: {
    required: false,
    merge: function merge() {
      return undefined;
    },
    validate: function validate(value) {
      // first check if it's an array
      assertIsArray(value); // then check each member

      value.forEach(function (item) {
        if (Array.isArray(item)) {
          assertIsArrayOfStringsAndFunctions(item);
        } else if (typeof item !== 'string' && typeof item !== 'function') {
          throw new TypeError('Items must be a string, a function, or an array of strings and functions.');
        }
      });
    }
  },
  ignores: {
    required: false,
    merge: function merge() {
      return undefined;
    },
    validate: assertIsArrayOfStringsAndFunctions
  }
});
/**
 * @fileoverview ConfigArray
 * @author Nicholas C. Zakas
 */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

var debug = createDebug('@hwc/config-array');
var MINIMATCH_OPTIONS = {
  matchBase: true
};
/**
 * Shorthand for checking if a value is a string.
 * @param {any} value The value to check.
 * @returns {boolean} True if a string, false if not. 
 */

function isString(value) {
  return typeof value === 'string';
}
/**
 * Normalizes a `ConfigArray` by flattening it and executing any functions
 * that are found inside.
 * @param {Array} items The items in a `ConfigArray`.
 * @param {Object} context The context object to pass into any function
 *      found.
 * @returns {Array} A flattened array containing only config objects.
 * @throws {TypeError} When a config function returns a function.
 */


function _normalize(items, context) {
  var _marked, flatTraverse;

  return regeneratorRuntime.async(function normalize$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          flatTraverse = function _ref(array) {
            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

            return regeneratorRuntime.wrap(function flatTraverse$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _iteratorError = undefined;
                    _context.prev = 3;
                    _iterator = array[Symbol.iterator]();

                  case 5:
                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                      _context.next = 21;
                      break;
                    }

                    item = _step.value;

                    if (typeof item === 'function') {
                      item = item(context);
                    }

                    if (!Array.isArray(item)) {
                      _context.next = 12;
                      break;
                    }

                    return _context.delegateYield(flatTraverse(item), "t0", 10);

                  case 10:
                    _context.next = 18;
                    break;

                  case 12:
                    if (!(typeof item === 'function')) {
                      _context.next = 16;
                      break;
                    }

                    throw new TypeError('A config function can only return an object or array.');

                  case 16:
                    _context.next = 18;
                    return item;

                  case 18:
                    _iteratorNormalCompletion = true;
                    _context.next = 5;
                    break;

                  case 21:
                    _context.next = 27;
                    break;

                  case 23:
                    _context.prev = 23;
                    _context.t1 = _context["catch"](3);
                    _didIteratorError = true;
                    _iteratorError = _context.t1;

                  case 27:
                    _context.prev = 27;
                    _context.prev = 28;

                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }

                  case 30:
                    _context.prev = 30;

                    if (!_didIteratorError) {
                      _context.next = 33;
                      break;
                    }

                    throw _iteratorError;

                  case 33:
                    return _context.finish(30);

                  case 34:
                    return _context.finish(27);

                  case 35:
                  case "end":
                    return _context.stop();
                }
              }
            }, _marked, null, [[3, 23, 27, 35], [28,, 30, 34]]);
          };

          _marked =
          /*#__PURE__*/
          regeneratorRuntime.mark(flatTraverse);
          return _context2.abrupt("return", _toConsumableArray(flatTraverse(items)));

        case 3:
        case "end":
          return _context2.stop();
      }
    }
  });
}
/**
 * Determines if a given file path is matched by a config. If the config
 * has no `files` field, then it matches; otherwise, if a `files` field
 * is present then we match the globs in `files` and exclude any globs in
 * `ignores`.
 * @param {string} filePath The absolute file path to check.
 * @param {Object} config The config object to check.
 * @returns {boolean} True if the file path is matched by the config,
 *      false if not.
 */


function pathMatches(filePath, basePath, config) {
  // a config without a `files` field always matches
  if (!config.files) {
    return true;
  } // if files isn't an array, throw an error


  if (!Array.isArray(config.files) || config.files.length === 0) {
    throw new TypeError('The files key must be a non-empty array.');
  }

  var relativeFilePath = path.relative(basePath, filePath); // match both strings and functions

  var match = function match(pattern) {
    if (isString(pattern)) {
      return minimatch(relativeFilePath, pattern, MINIMATCH_OPTIONS);
    }

    if (typeof pattern === 'function') {
      return pattern(filePath);
    }
  }; // check for all matches to config.files


  var matches = config.files.some(function (pattern) {
    if (Array.isArray(pattern)) {
      return pattern.every(match);
    }

    return match(pattern);
  });
  /*
   * If the file path matches the config.files patterns, then check to see
   * if there are any files to ignore.
   */

  if (matches && config.ignores) {
    matches = !config.ignores.some(function (pattern) {
      return minimatch(filePath, pattern, MINIMATCH_OPTIONS);
    });
  }

  return matches;
}
/**
 * Ensures that a ConfigArray has been normalized.
 * @param {ConfigArray} configArray The ConfigArray to check. 
 * @returns {void}
 * @throws {Error} When the `ConfigArray` is not normalized.
 */


function assertNormalized(configArray) {
  // TODO: Throw more verbose error
  if (!configArray.isNormalized()) {
    throw new Error('ConfigArray must be normalized to perform this operation.');
  }
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


var ConfigArraySymbol = {
  isNormalized: Symbol('isNormalized'),
  configCache: Symbol('configCache'),
  schema: Symbol('schema'),
  finalizeConfig: Symbol('finalizeConfig'),
  preprocessConfig: Symbol('preprocessConfig')
};
/**
 * Represents an array of config objects and provides method for working with
 * those config objects.
 */

var ConfigArray =
/*#__PURE__*/
function (_Array) {
  _inherits(ConfigArray, _Array);

  /**
   * Creates a new instance of ConfigArray.
   * @param {Iterable|Function|Object} configs An iterable yielding config
   *      objects, or a config function, or a config object.
   * @param {string} [options.basePath=""] The path of the config file
   * @param {boolean} [options.normalized=false] Flag indicating if the
   *      configs have already been normalized.
   * @param {Object} [options.schema] The additional schema 
   *      definitions to use for the ConfigArray schema.
   */
  function ConfigArray(configs) {
    var _this;

    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$basePath = _ref2.basePath,
        basePath = _ref2$basePath === void 0 ? '' : _ref2$basePath,
        _ref2$normalized = _ref2.normalized,
        normalized = _ref2$normalized === void 0 ? false : _ref2$normalized,
        customSchema = _ref2.schema;

    _classCallCheck(this, ConfigArray);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConfigArray).call(this));
    /**
     * Tracks if the array has been normalized.
     * @property isNormalized
     * @type boolean
     * @private
     */

    _this[ConfigArraySymbol.isNormalized] = normalized;
    /**
     * The schema used for validating and merging configs.
     * @property schema
     * @type ObjectSchema
     * @private
     */

    _this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(_objectSpread({}, customSchema, {}, baseSchema));
    /**
     * The path of the config file that this array was loaded from.
     * This is used to calculate filename matches.
     * @property basePath
     * @type string
     */

    _this.basePath = basePath;
    /**
     * A cache to store calculated configs for faster repeat lookup.
     * @property configCache
     * @type Map
     * @private
     */

    _this[ConfigArraySymbol.configCache] = new Map(); // load the configs into this array

    if (Array.isArray(configs)) {
      var _this2;

      (_this2 = _this).push.apply(_this2, _toConsumableArray(configs));
    } else {
      _this.push(configs);
    }

    return _this;
  }
  /**
   * Prevent normal array methods from creating a new `ConfigArray` instance.
   * This is to ensure that methods such as `slice()` won't try to create a 
   * new instance of `ConfigArray` behind the scenes as doing so may throw
   * an error due to the different constructor signature.
   * @returns {Function} The `Array` constructor.
   */


  _createClass(ConfigArray, [{
    key: "isNormalized",

    /**
     * Indicates if the config array has been normalized.
     * @returns {boolean} True if the config array is normalized, false if not.
     */
    value: function isNormalized() {
      return this[ConfigArraySymbol.isNormalized];
    }
    /**
     * Normalizes a config array by flattening embedded arrays and executing
     * config functions.
     * @param {ConfigContext} context The context object for config functions.
     * @returns {ConfigArray} A new ConfigArray instance that is normalized.
     */

  }, {
    key: "normalize",
    value: function normalize() {
      var context,
          normalizedConfigs,
          _args3 = arguments;
      return regeneratorRuntime.async(function normalize$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};

              if (this.isNormalized()) {
                _context3.next = 9;
                break;
              }

              _context3.next = 4;
              return regeneratorRuntime.awrap(_normalize(this, context));

            case 4:
              normalizedConfigs = _context3.sent;
              this.length = 0;
              this.push.apply(this, _toConsumableArray(normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig])));
              this[ConfigArraySymbol.isNormalized] = true; // prevent further changes

              Object.freeze(this);

            case 9:
              return _context3.abrupt("return", this);

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * Finalizes the state of a config before being cached and returned by
     * `getConfig()`. Does nothing by default but is provided to be
     * overridden by subclasses as necessary.
     * @param {Object} config The config to finalize.
     * @returns {Object} The finalized config.
     */

  }, {
    key: ConfigArraySymbol.finalizeConfig,
    value: function value(config) {
      return config;
    }
    /**
     * Preprocesses a config during the normalization process. This is the
     * method to override if you want to convert an array item before it is
     * validated for the first time. For example, if you want to replace a
     * string with an object, this is the method to override.
     * @param {Object} config The config to preprocess.
     * @returns {Object} The config to use in place of the argument.
     */

  }, {
    key: ConfigArraySymbol.preprocessConfig,
    value: function value(config) {
      return config;
    }
    /**
     * Returns the config object for a given file path.
     * @param {string} filePath The complete path of a file to get a config for.
     * @returns {Object} The config object for this file.
     */

  }, {
    key: "getConfig",
    value: function getConfig(filePath) {
      var _this3 = this;

      assertNormalized(this); // first check the cache to avoid duplicate work

      var finalConfig = this[ConfigArraySymbol.configCache].get(filePath);

      if (finalConfig) {
        return finalConfig;
      } // No config found in cache, so calculate a new one


      var matchingConfigs = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var config = _step2.value;

          if (pathMatches(filePath, this.basePath, config)) {
            debug("Matching config found for ".concat(filePath));
            matchingConfigs.push(config);
          } else {
            debug("No matching config found for ".concat(filePath));
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      finalConfig = matchingConfigs.reduce(function (result, config) {
        return _this3[ConfigArraySymbol.schema].merge(result, config);
      }, {}, this);
      finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);
      this[ConfigArraySymbol.configCache].set(filePath, finalConfig);
      return finalConfig;
    }
  }, {
    key: "files",

    /**
     * Returns the `files` globs from every config object in the array.
     * Negated patterns (those beginning with `!`) are not returned.
     * This can be used to determine which files will be matched by a
     * config array or to use as a glob pattern when no patterns are provided
     * for a command line interface.
     * @returns {string[]} An array of string patterns.
     */
    get: function get() {
      assertNormalized(this);
      var result = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var config = _step3.value;

          if (config.files) {
            config.files.forEach(function (filePattern) {
              if (Array.isArray(filePattern)) {
                result.push.apply(result, _toConsumableArray(filePattern.filter(function (pattern) {
                  return isString(pattern) && !pattern.startsWith('!');
                })));
              } else if (isString(filePattern) && !filePattern.startsWith('!')) {
                result.push(filePattern);
              }
            });
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return result;
    }
    /**
     * Returns the file globs that should always be ignored regardless of
     * the matching `files` fields in any configs. This is necessary to mimic
     * the behavior of things like .gitignore and .eslintignore, allowing a
     * globbing operation to be faster.
     * @returns {string[]} An array of string patterns to be ignored.
     */

  }, {
    key: "ignores",
    get: function get() {
      assertNormalized(this);
      var result = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var config = _step4.value;

          if (config.ignores && !config.files) {
            result.push.apply(result, _toConsumableArray(config.ignores.filter(isString)));
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return result;
    }
  }], [{
    key: Symbol.species,
    get: function get() {
      return Array;
    }
  }]);

  return ConfigArray;
}(_wrapNativeSuper(Array));

exports.ConfigArray = ConfigArray;
exports.ConfigArraySymbol = ConfigArraySymbol;