"use strict";
exports.__esModule = true;
exports["default"] = void 0;
var estree_walker_1 = require("estree-walker");
var extractAssignedNames_1 = require("./extractAssignedNames");
var blockDeclarations = {
    "const": true,
    let: true
};
var Scope = /** @class */ (function () {
    function Scope(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.parent = options.parent;
        this.isBlockScope = !!options.block;
        this.declarations = Object.create(null);
        if (options.params) {
            options.params.forEach(function (param) {
                extractAssignedNames_1["default"](param).forEach(function (name) {
                    _this.declarations[name] = true;
                });
            });
        }
    }
    Scope.prototype.addDeclaration = function (node, isBlockDeclaration, isVar) {
        var _this = this;
        if (!isBlockDeclaration && this.isBlockScope) {
            // it's a `var` or function node, and this
            // is a block scope, so we need to go up
            this.parent.addDeclaration(node, isBlockDeclaration, isVar);
        }
        else if (node.id) {
            extractAssignedNames_1["default"](node.id).forEach(function (name) {
                _this.declarations[name] = true;
            });
        }
    };
    Scope.prototype.contains = function (name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
    };
    return Scope;
}());
var attachScopes = function attachScopes(ast, propertyName) {
    if (propertyName === void 0) { propertyName = 'scope'; }
    var scope = new Scope();
    estree_walker_1.walk(ast, {
        enter: function (node, parent) {
            // function foo () {...}
            // class Foo {...}
            if (/(Function|Class)Declaration/.test(node.type)) {
                scope.addDeclaration(node, false, false);
            }
            // var foo = 1
            if (node.type === 'VariableDeclaration') {
                var kind = node.kind;
                var isBlockDeclaration_1 = blockDeclarations[kind];
                node.declarations.forEach(function (declaration) {
                    scope.addDeclaration(declaration, isBlockDeclaration_1, true);
                });
            }
            var newScope;
            // create new function scope
            if (/Function/.test(node.type)) {
                newScope = new Scope({
                    parent: scope,
                    block: false,
                    params: node.params
                });
                // named function expressions - the name is considered
                // part of the function's scope
                if (node.type === 'FunctionExpression' && node.id) {
                    newScope.addDeclaration(node, false, false);
                }
            }
            // create new block scope
            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {
                newScope = new Scope({
                    parent: scope,
                    block: true
                });
            }
            // catch clause has its own block scope
            if (node.type === 'CatchClause') {
                newScope = new Scope({
                    parent: scope,
                    params: node.param ? [node.param] : [],
                    block: true
                });
            }
            if (newScope) {
                Object.defineProperty(node, propertyName, {
                    value: newScope,
                    configurable: true
                });
                scope = newScope;
            }
        },
        leave: function (node) {
            if (node[propertyName])
                scope = scope.parent;
        }
    });
    return scope;
};
exports["default"] = attachScopes;
