'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = _interopDefault(require('postcss'));

var parser = _interopDefault(require('postcss-selector-parser'));

var anyAnyLinkMatch = /:any-link/;
var index = postcss.plugin('postcss-pseudo-class-any-link', function (opts) {
  var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;
  return function (root) {
    // walk each matching rule
    root.walkRules(anyAnyLinkMatch, function (rule) {
      var rawSelector = rule.raws.selector && rule.raws.selector.raw || rule.selector; // workaround for https://github.com/postcss/postcss-selector-parser/issues/28#issuecomment-171910556

      if (rawSelector[rawSelector.length - 1] !== ':') {
        // update the selector
        var updatedSelector = parser(function (selectors) {
          // cache variables
          var node;
          var nodeIndex;
          var selector;
          var selectorLink;
          var selectorVisited; // cache the selector index

          var selectorIndex = -1; // for each selector

          while (selector = selectors.nodes[++selectorIndex]) {
            // reset the node index
            nodeIndex = -1; // for each node

            while (node = selector.nodes[++nodeIndex]) {
              // if the node value matches the any-link value
              if (node.value === ':any-link') {
                // clone the selector
                selectorLink = selector.clone();
                selectorVisited = selector.clone(); // update the matching clone values

                selectorLink.nodes[nodeIndex].value = ':link';
                selectorVisited.nodes[nodeIndex].value = ':visited'; // replace the selector with the clones and roll back the selector index

                selectors.nodes.splice(selectorIndex--, 1, selectorLink, selectorVisited); // stop updating the selector

                break;
              }
            }
          }
        }).processSync(rawSelector);

        if (updatedSelector !== rawSelector) {
          if (preserve) {
            rule.cloneBefore({
              selector: updatedSelector
            });
          } else {
            rule.selector = updatedSelector;
          }
        }
      }
    });
  };
});
module.exports = index;