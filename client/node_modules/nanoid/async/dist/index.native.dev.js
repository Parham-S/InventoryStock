"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.random = exports.customAlphabet = exports.nanoid = void 0;

var _expoRandom = require("expo-random");

var _index = require("../url-alphabet/index.js");

var random = _expoRandom.getRandomBytesAsync;
exports.random = random;

var customAlphabet = function customAlphabet(alphabet, size) {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  var mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1; // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.
  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.
  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).

  var step = Math.ceil(1.6 * mask * size / alphabet.length);

  var tick = function tick(id) {
    return random(step).then(function (bytes) {
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      var i = step;

      while (i--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[i] & mask] || '';
        if (id.length === size) return id;
      }

      return tick(id);
    });
  };

  return function () {
    return tick('');
  };
};

exports.customAlphabet = customAlphabet;

var nanoid = function nanoid() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
  return random(size).then(function (bytes) {
    var id = ''; // A compact alternative for `for (var i = 0; i < step; i++)`.

    while (size--) {
      // It is incorrect to use bytes exceeding the alphabet size.
      // The following mask reduces the random byte in the 0-255 value
      // range to the 0-63 value range. Therefore, adding hacks, such
      // as empty string fallback or magic numbers, is unneccessary because
      // the bitmask trims bytes down to the alphabet size.
      id += _index.urlAlphabet[bytes[size] & 63];
    }

    return id;
  });
};

exports.nanoid = nanoid;