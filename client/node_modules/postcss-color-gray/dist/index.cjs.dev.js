'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = _interopDefault(require('postcss'));

var parser = _interopDefault(require('postcss-values-parser'));

var convertColors = require('@csstools/convert-colors');

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var index = postcss.plugin('postcss-color-gray', function (opts) {
  return function (root) {
    // walk all declarations likely containing a gray() function
    root.walkDecls(function (decl) {
      if (hasGrayFunction(decl)) {
        var originalValue = decl.value; // parse the declaration value

        var ast = parser(originalValue).parse(); // walk every node in the value that contains a gray() function

        ast.walk(function (node) {
          var _getFunctionGrayArgs = getFunctionGrayArgs(node),
              _getFunctionGrayArgs2 = _slicedToArray(_getFunctionGrayArgs, 2),
              lightness = _getFunctionGrayArgs2[0],
              alpha = _getFunctionGrayArgs2[1];

          if (lightness !== undefined) {
            // rename the gray() function to rgb()
            node.value = 'rgb'; // convert the lab gray lightness into rgb

            var _lab2rgb$map = convertColors.lab2rgb(lightness, 0, 0).map(function (channel) {
              return Math.max(Math.min(Math.round(channel * 2.55), 255), 0);
            }),
                _lab2rgb$map2 = _slicedToArray(_lab2rgb$map, 3),
                r = _lab2rgb$map2[0],
                g = _lab2rgb$map2[1],
                b = _lab2rgb$map2[2]; // preserve the slash nodes within rgb()


            var openingSlash = node.first;
            var closingSlash = node.last;
            node.removeAll() // replace the contents of rgb with `(r,g,b`
            .append(openingSlash).append(parser.number({
              value: r
            })).append(parser.comma({
              value: ','
            })).append(parser.number({
              value: g
            })).append(parser.comma({
              value: ','
            })).append(parser.number({
              value: b
            })); // if an alpha channel was defined

            if (alpha < 1) {
              // rename the rgb() function to rgba()
              node.value += 'a';
              node // append the contents of rgba with `,a`
              .append(parser.comma({
                value: ','
              })).append(parser.number({
                value: alpha
              }));
            } // append the contents of rgb/rgba with `)`


            node.append(closingSlash);
          }
        });
        var modifiedValue = ast.toString(); // if the modified value has changed from the original value

        if (originalValue !== modifiedValue) {
          // if the original gray() color is to be preserved
          if (Object(opts).preserve) {
            // insert the declaration value with the fallback before the current declaration
            decl.cloneBefore({
              value: modifiedValue
            });
          } else {
            // otherwise, overwrite the declaration value with the fallback
            decl.value = modifiedValue;
          }
        }
      }
    });
  };
}); // return whether a string contains a gray() function

var hasGrayFunctionRegExp = /(^|[^\w-])gray\(/i;

var hasGrayFunction = function hasGrayFunction(decl) {
  return hasGrayFunctionRegExp.test(Object(decl).value);
}; // return whether a node matches a specific type


var isNumber = function isNumber(node) {
  return Object(node).type === 'number';
};

var isOperator = function isOperator(node) {
  return Object(node).type === 'operator';
};

var isFunction = function isFunction(node) {
  return Object(node).type === 'func';
};

var isCalcRegExp = /^calc$/i;

var isFunctionCalc = function isFunctionCalc(node) {
  return isFunction(node) && isCalcRegExp.test(node.value);
};

var isGrayRegExp = /^gray$/i;

var isFunctionGrayWithArgs = function isFunctionGrayWithArgs(node) {
  return isFunction(node) && isGrayRegExp.test(node.value) && node.nodes && node.nodes.length;
};

var isNumberPercentage = function isNumberPercentage(node) {
  return isNumber(node) && node.unit === '%';
};

var isNumberUnitless = function isNumberUnitless(node) {
  return isNumber(node) && node.unit === '';
};

var isOperatorSlash = function isOperatorSlash(node) {
  return isOperator(node) && node.value === '/';
}; // return valid values from a node, otherwise undefined


var getNumberUnitless = function getNumberUnitless(node) {
  return isNumberUnitless(node) ? Number(node.value) : undefined;
};

var getOperatorSlash = function getOperatorSlash(node) {
  return isOperatorSlash(node) ? null : undefined;
};

var getAlpha = function getAlpha(node) {
  return isFunctionCalc(node) ? String(node) : isNumberUnitless(node) ? Number(node.value) : isNumberPercentage(node) ? Number(node.value) / 100 : undefined;
}; // return valid arguments from a gray() function


var functionalGrayArgs = [getNumberUnitless, getOperatorSlash, getAlpha];

var getFunctionGrayArgs = function getFunctionGrayArgs(node) {
  var validArgs = []; // if the node is a gray() function with arguments

  if (isFunctionGrayWithArgs(node)) {
    // get all the gray() function arguments between `(` and `)`
    var nodes = node.nodes.slice(1, -1); // validate each argument

    for (var _index in nodes) {
      var arg = typeof functionalGrayArgs[_index] === 'function' ? functionalGrayArgs[_index](nodes[_index]) : undefined; // if the argument was validated

      if (arg !== undefined) {
        // push any non-null argument to the valid arguments array
        if (arg !== null) {
          validArgs.push(arg);
        }
      } else {
        // otherwise, return an empty array
        return [];
      }
    } // return the valid arguments array


    return validArgs;
  } else {
    // otherwise, return an empty array
    return [];
  }
};

module.exports = index;