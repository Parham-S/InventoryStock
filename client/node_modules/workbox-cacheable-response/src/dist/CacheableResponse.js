"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
exports.__esModule = true;
exports.CacheableResponse = void 0;
var assert_js_1 = require("workbox-core/_private/assert.js");
var WorkboxError_js_1 = require("workbox-core/_private/WorkboxError.js");
var getFriendlyURL_js_1 = require("workbox-core/_private/getFriendlyURL.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
require("./_version.js");
/**
 * This class allows you to set up rules determining what
 * status codes and/or headers need to be present in order for a
 * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)
 * to be considered cacheable.
 *
 * @memberof module:workbox-cacheable-response
 */
var CacheableResponse = /** @class */ (function () {
    /**
     * To construct a new CacheableResponse instance you must provide at least
     * one of the `config` properties.
     *
     * If both `statuses` and `headers` are specified, then both conditions must
     * be met for the `Response` to be considered cacheable.
     *
     * @param {Object} config
     * @param {Array<number>} [config.statuses] One or more status codes that a
     * `Response` can have and be considered cacheable.
     * @param {Object<string,string>} [config.headers] A mapping of header names
     * and expected values that a `Response` can have and be considered cacheable.
     * If multiple headers are provided, only one needs to be present.
     */
    function CacheableResponse(config) {
        if (config === void 0) { config = {}; }
        if (process.env.NODE_ENV !== 'production') {
            if (!(config.statuses || config.headers)) {
                throw new WorkboxError_js_1.WorkboxError('statuses-or-headers-required', {
                    moduleName: 'workbox-cacheable-response',
                    className: 'CacheableResponse',
                    funcName: 'constructor'
                });
            }
            if (config.statuses) {
                assert_js_1.assert.isArray(config.statuses, {
                    moduleName: 'workbox-cacheable-response',
                    className: 'CacheableResponse',
                    funcName: 'constructor',
                    paramName: 'config.statuses'
                });
            }
            if (config.headers) {
                assert_js_1.assert.isType(config.headers, 'object', {
                    moduleName: 'workbox-cacheable-response',
                    className: 'CacheableResponse',
                    funcName: 'constructor',
                    paramName: 'config.headers'
                });
            }
        }
        this._statuses = config.statuses;
        this._headers = config.headers;
    }
    /**
     * Checks a response to see whether it's cacheable or not, based on this
     * object's configuration.
     *
     * @param {Response} response The response whose cacheability is being
     * checked.
     * @return {boolean} `true` if the `Response` is cacheable, and `false`
     * otherwise.
     */
    CacheableResponse.prototype.isResponseCacheable = function (response) {
        var _this = this;
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isInstance(response, Response, {
                moduleName: 'workbox-cacheable-response',
                className: 'CacheableResponse',
                funcName: 'isResponseCacheable',
                paramName: 'response'
            });
        }
        var cacheable = true;
        if (this._statuses) {
            cacheable = this._statuses.includes(response.status);
        }
        if (this._headers && cacheable) {
            cacheable = Object.keys(this._headers).some(function (headerName) {
                return response.headers.get(headerName) === _this._headers[headerName];
            });
        }
        if (process.env.NODE_ENV !== 'production') {
            if (!cacheable) {
                logger_js_1.logger.groupCollapsed("The request for " +
                    ("'" + getFriendlyURL_js_1.getFriendlyURL(response.url) + "' returned a response that does ") +
                    "not meet the criteria for being cached.");
                logger_js_1.logger.groupCollapsed("View cacheability criteria here.");
                logger_js_1.logger.log("Cacheable statuses: " +
                    JSON.stringify(this._statuses));
                logger_js_1.logger.log("Cacheable headers: " +
                    JSON.stringify(this._headers, null, 2));
                logger_js_1.logger.groupEnd();
                var logFriendlyHeaders_1 = {};
                response.headers.forEach(function (value, key) {
                    logFriendlyHeaders_1[key] = value;
                });
                logger_js_1.logger.groupCollapsed("View response status and headers here.");
                logger_js_1.logger.log("Response status: " + response.status);
                logger_js_1.logger.log("Response headers: " +
                    JSON.stringify(logFriendlyHeaders_1, null, 2));
                logger_js_1.logger.groupEnd();
                logger_js_1.logger.groupCollapsed("View full response details here.");
                logger_js_1.logger.log(response.headers);
                logger_js_1.logger.log(response);
                logger_js_1.logger.groupEnd();
                logger_js_1.logger.groupEnd();
            }
        }
        return cacheable;
    };
    return CacheableResponse;
}());
exports.CacheableResponse = CacheableResponse;
