/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */
"use strict";
/* eslint class-methods-use-this: "off" */
//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var util = require("util"),
    configSchema = require("../../conf/config-schema"),
    BuiltInEnvironments = require("../../conf/environments"),
    ConfigOps = require("./config-ops"),
    _require = require("./deprecation-warnings"),
    emitDeprecationWarning = _require.emitDeprecationWarning;

var ajv = require("./ajv")();

var ruleValidators = new WeakMap();
var noop = Function.prototype; //------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var validateSchema;
var severityMap = {
  error: 2,
  warn: 1,
  off: 0
};
var validated = new WeakSet(); //-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

module.exports =
/*#__PURE__*/
function () {
  function ConfigValidator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$builtInRules = _ref.builtInRules,
        builtInRules = _ref$builtInRules === void 0 ? new Map() : _ref$builtInRules;

    _classCallCheck(this, ConfigValidator);

    this.builtInRules = builtInRules;
  }
  /**
   * Gets a complete options schema for a rule.
   * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
   * @returns {Object} JSON Schema for the rule's options.
   */


  _createClass(ConfigValidator, [{
    key: "getRuleOptionsSchema",
    value: function getRuleOptionsSchema(rule) {
      if (!rule) {
        return null;
      }

      var schema = rule.schema || rule.meta && rule.meta.schema; // Given a tuple of schemas, insert warning level at the beginning

      if (Array.isArray(schema)) {
        if (schema.length) {
          return {
            type: "array",
            items: schema,
            minItems: 0,
            maxItems: schema.length
          };
        }

        return {
          type: "array",
          minItems: 0,
          maxItems: 0
        };
      } // Given a full schema, leave it alone


      return schema || null;
    }
    /**
     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
     * @param {options} options The given options for the rule.
     * @returns {number|string} The rule's severity value
     */

  }, {
    key: "validateRuleSeverity",
    value: function validateRuleSeverity(options) {
      var severity = Array.isArray(options) ? options[0] : options;
      var normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

      if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
        return normSeverity;
      }

      throw new Error("\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '".concat(util.inspect(severity).replace(/'/g, "\"").replace(/\n/g, ""), "').\n"));
    }
    /**
     * Validates the non-severity options passed to a rule, based on its schema.
     * @param {{create: Function}} rule The rule to validate
     * @param {Array} localOptions The options for the rule, excluding severity
     * @returns {void}
     */

  }, {
    key: "validateRuleSchema",
    value: function validateRuleSchema(rule, localOptions) {
      if (!ruleValidators.has(rule)) {
        var schema = this.getRuleOptionsSchema(rule);

        if (schema) {
          ruleValidators.set(rule, ajv.compile(schema));
        }
      }

      var validateRule = ruleValidators.get(rule);

      if (validateRule) {
        validateRule(localOptions);

        if (validateRule.errors) {
          throw new Error(validateRule.errors.map(function (error) {
            return "\tValue ".concat(JSON.stringify(error.data), " ").concat(error.message, ".\n");
          }).join(""));
        }
      }
    }
    /**
     * Validates a rule's options against its schema.
     * @param {{create: Function}|null} rule The rule that the config is being validated for
     * @param {string} ruleId The rule's unique name.
     * @param {Array|number} options The given options for the rule.
     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
     * no source is prepended to the message.
     * @returns {void}
     */

  }, {
    key: "validateRuleOptions",
    value: function validateRuleOptions(rule, ruleId, options) {
      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      try {
        var severity = this.validateRuleSeverity(options);

        if (severity !== 0) {
          this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
        }
      } catch (err) {
        var enhancedMessage = "Configuration for rule \"".concat(ruleId, "\" is invalid:\n").concat(err.message);

        if (typeof source === "string") {
          throw new Error("".concat(source, ":\n\t").concat(enhancedMessage));
        } else {
          throw new Error(enhancedMessage);
        }
      }
    }
    /**
     * Validates an environment object
     * @param {Object} environment The environment config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
     * @returns {void}
     */

  }, {
    key: "validateEnvironment",
    value: function validateEnvironment(environment, source) {
      var getAdditionalEnv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

      // not having an environment is ok
      if (!environment) {
        return;
      }

      Object.keys(environment).forEach(function (id) {
        var env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;

        if (!env) {
          var message = "".concat(source, ":\n\tEnvironment key \"").concat(id, "\" is unknown\n");
          throw new Error(message);
        }
      });
    }
    /**
     * Validates a rules config object
     * @param {Object} rulesConfig The rules config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
     * @returns {void}
     */

  }, {
    key: "validateRules",
    value: function validateRules(rulesConfig, source) {
      var _this = this;

      var getAdditionalRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

      if (!rulesConfig) {
        return;
      }

      Object.keys(rulesConfig).forEach(function (id) {
        var rule = getAdditionalRule(id) || _this.builtInRules.get(id) || null;

        _this.validateRuleOptions(rule, id, rulesConfig[id], source);
      });
    }
    /**
     * Validates a `globals` section of a config file
     * @param {Object} globalsConfig The `globals` section
     * @param {string|null} source The name of the configuration source to report in the event of an error.
     * @returns {void}
     */

  }, {
    key: "validateGlobals",
    value: function validateGlobals(globalsConfig) {
      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!globalsConfig) {
        return;
      }

      Object.entries(globalsConfig).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            configuredGlobal = _ref3[0],
            configuredValue = _ref3[1];

        try {
          ConfigOps.normalizeConfigGlobal(configuredValue);
        } catch (err) {
          throw new Error("ESLint configuration of global '".concat(configuredGlobal, "' in ").concat(source, " is invalid:\n").concat(err.message));
        }
      });
    }
    /**
     * Validate `processor` configuration.
     * @param {string|undefined} processorName The processor name.
     * @param {string} source The name of config file.
     * @param {function(id:string): Processor} getProcessor The getter of defined processors.
     * @returns {void}
     */

  }, {
    key: "validateProcessor",
    value: function validateProcessor(processorName, source, getProcessor) {
      if (processorName && !getProcessor(processorName)) {
        throw new Error("ESLint configuration of processor in '".concat(source, "' is invalid: '").concat(processorName, "' was not found."));
      }
    }
    /**
     * Formats an array of schema validation errors.
     * @param {Array} errors An array of error messages to format.
     * @returns {string} Formatted error message
     */

  }, {
    key: "formatErrors",
    value: function formatErrors(errors) {
      return errors.map(function (error) {
        if (error.keyword === "additionalProperties") {
          var formattedPropertyPath = error.dataPath.length ? "".concat(error.dataPath.slice(1), ".").concat(error.params.additionalProperty) : error.params.additionalProperty;
          return "Unexpected top-level property \"".concat(formattedPropertyPath, "\"");
        }

        if (error.keyword === "type") {
          var formattedField = error.dataPath.slice(1);
          var formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
          var formattedValue = JSON.stringify(error.data);
          return "Property \"".concat(formattedField, "\" is the wrong type (expected ").concat(formattedExpectedType, " but got `").concat(formattedValue, "`)");
        }

        var field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
        return "\"".concat(field, "\" ").concat(error.message, ". Value: ").concat(JSON.stringify(error.data));
      }).map(function (message) {
        return "\t- ".concat(message, ".\n");
      }).join("");
    }
    /**
     * Validates the top level properties of the config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @returns {void}
     */

  }, {
    key: "validateConfigSchema",
    value: function validateConfigSchema(config) {
      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      validateSchema = validateSchema || ajv.compile(configSchema);

      if (!validateSchema(config)) {
        throw new Error("ESLint configuration in ".concat(source, " is invalid:\n").concat(this.formatErrors(validateSchema.errors)));
      }

      if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
        emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
      }
    }
    /**
     * Validates an entire config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
     * @returns {void}
     */

  }, {
    key: "validate",
    value: function validate(config, source, getAdditionalRule, getAdditionalEnv) {
      this.validateConfigSchema(config, source);
      this.validateRules(config.rules, source, getAdditionalRule);
      this.validateEnvironment(config.env, source, getAdditionalEnv);
      this.validateGlobals(config.globals, source);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (config.overrides || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var override = _step.value;
          this.validateRules(override.rules, source, getAdditionalRule);
          this.validateEnvironment(override.env, source, getAdditionalEnv);
          this.validateGlobals(config.globals, source);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Validate config array object.
     * @param {ConfigArray} configArray The config array to validate.
     * @returns {void}
     */

  }, {
    key: "validateConfigArray",
    value: function validateConfigArray(configArray) {
      var getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
      var getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
      var getPluginRule = Map.prototype.get.bind(configArray.pluginRules); // Validate.

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = configArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var element = _step2.value;

          if (validated.has(element)) {
            continue;
          }

          validated.add(element);
          this.validateEnvironment(element.env, element.name, getPluginEnv);
          this.validateGlobals(element.globals, element.name);
          this.validateProcessor(element.processor, element.name, getPluginProcessor);
          this.validateRules(element.rules, element.name, getPluginRule);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);

  return ConfigValidator;
}();