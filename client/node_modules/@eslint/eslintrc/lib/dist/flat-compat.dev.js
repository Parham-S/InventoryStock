/**
 * @fileoverview Compatibility class for flat config.
 * @author Nicholas C. Zakas
 */
"use strict"; //-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require("path");

var environments = require("../conf/environments");

var createDebug = require("debug");

var _require = require("./config-array-factory"),
    ConfigArrayFactory = _require.ConfigArrayFactory; //-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

/** @typedef {import("../../shared/types").Environment} Environment */

/** @typedef {import("../../shared/types").Processor} Processor */


var debug = createDebug("eslintrc:flat-compat");
var cafactory = Symbol("cafactory");
/**
 * Translates an ESLintRC-style config object into a flag-config-style config
 * object.
 * @param {Object} eslintrcConfig An ESLintRC-style config object.
 * @param {Object} options Options to help translate the config.
 * @param {string} options.resolveConfigRelativeTo To the directory to resolve
 *      configs from.
 * @param {string} options.resolvePluginsRelativeTo The directory to resolve
 *      plugins from.
 * @param {ReadOnlyMap<string,Environment>} options.pluginEnvironments A map of plugin environment
 *      names to objects.
 * @param {ReadOnlyMap<string,Processor>} options.pluginProcessors A map of plugin processor
 *      names to objects.
 * @returns {Object} A flag-config-style config object.
 */

function translateESLintRC(eslintrcConfig, _ref) {
  var resolveConfigRelativeTo = _ref.resolveConfigRelativeTo,
      resolvePluginsRelativeTo = _ref.resolvePluginsRelativeTo,
      pluginEnvironments = _ref.pluginEnvironments,
      pluginProcessors = _ref.pluginProcessors;
  var flatConfig = {};
  var configs = [];
  var languageOptions = {};
  var linterOptions = {};
  var keysToCopy = ["settings", "rules", "processor"];
  var languageOptionsKeysToCopy = ["globals", "parser", "parserOptions"];
  var linterOptionsKeysToCopy = ["noInlineConfig", "reportUnusedDisableDirectives"]; // check for special settings for eslint:all and eslint:recommended:

  if (eslintrcConfig.settings) {
    if (eslintrcConfig.settings["eslint:all"] === true) {
      return ["eslint:all"];
    }

    if (eslintrcConfig.settings["eslint:recommended"] === true) {
      return ["eslint:recommended"];
    }
  } // copy over simple translations


  for (var _i = 0, _keysToCopy = keysToCopy; _i < _keysToCopy.length; _i++) {
    var key = _keysToCopy[_i];

    if (key in eslintrcConfig && typeof eslintrcConfig[key] !== "undefined") {
      flatConfig[key] = eslintrcConfig[key];
    }
  } // copy over languageOptions


  for (var _i2 = 0, _languageOptionsKeysT = languageOptionsKeysToCopy; _i2 < _languageOptionsKeysT.length; _i2++) {
    var _key = _languageOptionsKeysT[_i2];

    if (_key in eslintrcConfig && typeof eslintrcConfig[_key] !== "undefined") {
      // create the languageOptions key in the flat config
      flatConfig.languageOptions = languageOptions;

      if (_key === "parser") {
        debug("Resolving parser '".concat(languageOptions[_key], "' relative to ").concat(resolveConfigRelativeTo));

        if (eslintrcConfig[_key].error) {
          throw eslintrcConfig[_key].error;
        }

        languageOptions[_key] = eslintrcConfig[_key].definition;
        continue;
      } // clone any object values that are in the eslintrc config


      if (eslintrcConfig[_key] && _typeof(eslintrcConfig[_key]) === "object") {
        languageOptions[_key] = _objectSpread({}, eslintrcConfig[_key]);
      } else {
        languageOptions[_key] = eslintrcConfig[_key];
      }
    }
  } // copy over linterOptions


  for (var _i3 = 0, _linterOptionsKeysToC = linterOptionsKeysToCopy; _i3 < _linterOptionsKeysToC.length; _i3++) {
    var _key2 = _linterOptionsKeysToC[_i3];

    if (_key2 in eslintrcConfig && typeof eslintrcConfig[_key2] !== "undefined") {
      flatConfig.linterOptions = linterOptions;
      linterOptions[_key2] = eslintrcConfig[_key2];
    }
  } // move ecmaVersion a level up


  if (languageOptions.parserOptions) {
    if ("ecmaVersion" in languageOptions.parserOptions) {
      languageOptions.ecmaVersion = languageOptions.parserOptions.ecmaVersion;
      delete languageOptions.parserOptions.ecmaVersion;
    }

    if ("sourceType" in languageOptions.parserOptions) {
      languageOptions.sourceType = languageOptions.parserOptions.sourceType;
      delete languageOptions.parserOptions.sourceType;
    } // check to see if we even need parserOptions anymore and remove it if not


    if (Object.keys(languageOptions.parserOptions).length === 0) {
      delete languageOptions.parserOptions;
    }
  } // overrides


  if (eslintrcConfig.criteria) {
    flatConfig.files = [function (absoluteFilePath) {
      return eslintrcConfig.criteria.test(absoluteFilePath);
    }];
  } // translate plugins


  if (eslintrcConfig.plugins && _typeof(eslintrcConfig.plugins) === "object") {
    debug("Translating plugins: ".concat(eslintrcConfig.plugins));
    flatConfig.plugins = {};

    for (var _i4 = 0, _Object$keys = Object.keys(eslintrcConfig.plugins); _i4 < _Object$keys.length; _i4++) {
      var pluginName = _Object$keys[_i4];
      debug("Translating plugin: ".concat(pluginName));
      debug("Resolving plugin '".concat(pluginName, " relative to ").concat(resolvePluginsRelativeTo));
      var _eslintrcConfig$plugi = eslintrcConfig.plugins[pluginName],
          plugin = _eslintrcConfig$plugi.definition,
          error = _eslintrcConfig$plugi.error;

      if (error) {
        throw error;
      }

      flatConfig.plugins[pluginName] = plugin; // create a config for any processors

      if (plugin.processors) {
        for (var _i5 = 0, _Object$keys2 = Object.keys(plugin.processors); _i5 < _Object$keys2.length; _i5++) {
          var processorName = _Object$keys2[_i5];

          if (processorName.startsWith(".")) {
            debug("Assigning processor: ".concat(pluginName, "/").concat(processorName));
            configs.unshift({
              files: ["**/*".concat(processorName)],
              processor: pluginProcessors.get("".concat(pluginName, "/").concat(processorName))
            });
          }
        }
      }
    }
  } // translate env - must come after plugins


  if (eslintrcConfig.env && _typeof(eslintrcConfig.env) === "object") {
    for (var _i6 = 0, _Object$keys3 = Object.keys(eslintrcConfig.env); _i6 < _Object$keys3.length; _i6++) {
      var envName = _Object$keys3[_i6];

      // only add environments that are true
      if (eslintrcConfig.env[envName]) {
        debug("Translating environment: ".concat(envName));

        if (environments.has(envName)) {
          // built-in environments should be defined first
          configs.unshift.apply(configs, _toConsumableArray(translateESLintRC(environments.get(envName), {
            resolveConfigRelativeTo: resolveConfigRelativeTo,
            resolvePluginsRelativeTo: resolvePluginsRelativeTo
          })));
        } else if (pluginEnvironments.has(envName)) {
          // if the environment comes from a plugin, it should come after the plugin config
          configs.push.apply(configs, _toConsumableArray(translateESLintRC(pluginEnvironments.get(envName), {
            resolveConfigRelativeTo: resolveConfigRelativeTo,
            resolvePluginsRelativeTo: resolvePluginsRelativeTo
          })));
        }
      }
    }
  } // only add if there are actually keys in the config


  if (Object.keys(flatConfig).length > 0) {
    configs.push(flatConfig);
  }

  return configs;
} //-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * A compatibility class for working with configs.
 */


var FlatCompat =
/*#__PURE__*/
function () {
  function FlatCompat() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$baseDirectory = _ref2.baseDirectory,
        baseDirectory = _ref2$baseDirectory === void 0 ? process.cwd() : _ref2$baseDirectory,
        _ref2$resolvePluginsR = _ref2.resolvePluginsRelativeTo,
        resolvePluginsRelativeTo = _ref2$resolvePluginsR === void 0 ? baseDirectory : _ref2$resolvePluginsR;

    _classCallCheck(this, FlatCompat);

    this.baseDirectory = baseDirectory;
    this.resolvePluginsRelativeTo = resolvePluginsRelativeTo;
    this[cafactory] = new ConfigArrayFactory({
      cwd: baseDirectory,
      resolvePluginsRelativeTo: resolvePluginsRelativeTo,
      eslintAllPath: path.resolve(__dirname, "../conf/eslint-all.js"),
      eslintRecommendedPath: path.resolve(__dirname, "../conf/eslint-recommended.js")
    });
  }
  /**
   * Translates an ESLintRC-style config into a flag-config-style config.
   * @param {Object} eslintrcConfig The ESLintRC-style config object.
   * @returns {Object} A flag-config-style config object.
   */


  _createClass(FlatCompat, [{
    key: "config",
    value: function config(eslintrcConfig) {
      var _this = this;

      var eslintrcArray = this[cafactory].create(eslintrcConfig, {
        basePath: this.baseDirectory
      });
      var flatArray = [];
      var hasIgnorePatterns = false;
      eslintrcArray.forEach(function (configData) {
        if (configData.type === "config") {
          hasIgnorePatterns = hasIgnorePatterns || configData.ignorePattern;
          flatArray.push.apply(flatArray, _toConsumableArray(translateESLintRC(configData, {
            resolveConfigRelativeTo: path.join(_this.baseDirectory, "__placeholder.js"),
            resolvePluginsRelativeTo: path.join(_this.resolvePluginsRelativeTo, "__placeholder.js"),
            pluginEnvironments: eslintrcArray.pluginEnvironments,
            pluginProcessors: eslintrcArray.pluginProcessors
          })));
        }
      }); // combine ignorePatterns to emulate ESLintRC behavior better

      if (hasIgnorePatterns) {
        flatArray.unshift({
          ignores: [function (filePath) {
            // Compute the final config for this file.
            // This filters config array elements by `files`/`excludedFiles` then merges the elements.
            var finalConfig = eslintrcArray.extractConfig(filePath); // Test the `ignorePattern` properties of the final config.

            return Boolean(finalConfig.ignores) && finalConfig.ignores(filePath);
          }]
        });
      }

      return flatArray;
    }
    /**
     * Translates the `env` section of an ESLintRC-style config.
     * @param {Object} envConfig The `env` section of an ESLintRC config.
     * @returns {Object} A flag-config object representing the environments.
     */

  }, {
    key: "env",
    value: function env(envConfig) {
      return this.config({
        env: envConfig
      });
    }
    /**
     * Translates the `extends` section of an ESLintRC-style config.
     * @param {...string} configsToExtend The names of the configs to load.
     * @returns {Object} A flag-config object representing the config.
     */

  }, {
    key: "extends",
    value: function _extends() {
      for (var _len = arguments.length, configsToExtend = new Array(_len), _key3 = 0; _key3 < _len; _key3++) {
        configsToExtend[_key3] = arguments[_key3];
      }

      return this.config({
        "extends": configsToExtend
      });
    }
    /**
     * Translates the `plugins` section of an ESLintRC-style config.
     * @param {...string} plugins The names of the plugins to load.
     * @returns {Object} A flag-config object representing the plugins.
     */

  }, {
    key: "plugins",
    value: function plugins() {
      for (var _len2 = arguments.length, _plugins = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {
        _plugins[_key4] = arguments[_key4];
      }

      return this.config({
        plugins: _plugins
      });
    }
  }]);

  return FlatCompat;
}();

exports.FlatCompat = FlatCompat;