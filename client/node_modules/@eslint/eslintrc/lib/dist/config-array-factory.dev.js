/**
 * @fileoverview The factory of `ConfigArray` objects.
 *
 * This class provides methods to create `ConfigArray` instance.
 *
 * - `create(configData, options)`
 *     Create a `ConfigArray` instance from a config data. This is to handle CLI
 *     options except `--config`.
 * - `loadFile(filePath, options)`
 *     Create a `ConfigArray` instance from a config file. This is to handle
 *     `--config` option. If the file was not found, throws the following error:
 *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.
 *      - If the filename was `package.json`, an IO error or an
 *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.
 *      - Otherwise, an IO error such as `ENOENT`.
 * - `loadInDirectory(directoryPath, options)`
 *     Create a `ConfigArray` instance from a config file which is on a given
 *     directory. This tries to load `.eslintrc.*` or `package.json`. If not
 *     found, returns an empty `ConfigArray`.
 * - `loadESLintIgnore(filePath)`
 *     Create a `ConfigArray` instance from a config file that is `.eslintignore`
 *     format. This is to handle `--ignore-path` option.
 * - `loadDefaultESLintIgnore()`
 *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in
 *     the current working directory.
 *
 * `ConfigArrayFactory` class has the responsibility that loads configuration
 * files, including loading `extends`, `parser`, and `plugins`. The created
 * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.
 *
 * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class
 * handles cascading and hierarchy.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require("fs");

var path = require("path");

var importFresh = require("import-fresh");

var stripComments = require("strip-json-comments");

var ConfigValidator = require("./shared/config-validator");

var naming = require("./shared/naming");

var ModuleResolver = require("./shared/relative-module-resolver");

var _require = require("./config-array"),
    ConfigArray = _require.ConfigArray,
    ConfigDependency = _require.ConfigDependency,
    IgnorePattern = _require.IgnorePattern,
    OverrideTester = _require.OverrideTester;

var debug = require("debug")("eslintrc:config-array-factory"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var configFilenames = [".eslintrc.js", ".eslintrc.cjs", ".eslintrc.yaml", ".eslintrc.yml", ".eslintrc.json", ".eslintrc", "package.json"]; // Define types for VSCode IntelliSense.

/** @typedef {import("./shared/types").ConfigData} ConfigData */

/** @typedef {import("./shared/types").OverrideConfigData} OverrideConfigData */

/** @typedef {import("./shared/types").Parser} Parser */

/** @typedef {import("./shared/types").Plugin} Plugin */

/** @typedef {import("./shared/types").Rule} Rule */

/** @typedef {import("./config-array/config-dependency").DependentParser} DependentParser */

/** @typedef {import("./config-array/config-dependency").DependentPlugin} DependentPlugin */

/** @typedef {ConfigArray[0]} ConfigArrayElement */

/**
 * @typedef {Object} ConfigArrayFactoryOptions
 * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.
 * @property {string} [cwd] The path to the current working directory.
 * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.
 * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.
 * @property {Object} [resolver=ModuleResolver] The module resolver object.
 * @property {string} eslintAllPath The path to the definitions for eslint:all.
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.
 */

/**
 * @typedef {Object} ConfigArrayFactoryInternalSlots
 * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.
 * @property {string} cwd The path to the current working directory.
 * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.
 * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.
 * @property {Object} [resolver=ModuleResolver] The module resolver object.
 * @property {string} eslintAllPath The path to the definitions for eslint:all.
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.
 */

/**
 * @typedef {Object} ConfigArrayFactoryLoadingContext
 * @property {string} filePath The path to the current configuration.
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
 * @property {string} name The name of the current configuration.
 * @property {string} pluginBasePath The base path to resolve plugins.
 * @property {"config" | "ignore" | "implicit-processor"} type The type of the current configuration. This is `"config"` in normal. This is `"ignore"` if it came from `.eslintignore`. This is `"implicit-processor"` if it came from legacy file-extension processors.
 */

/**
 * @typedef {Object} ConfigArrayFactoryLoadingContext
 * @property {string} filePath The path to the current configuration.
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
 * @property {string} name The name of the current configuration.
 * @property {"config" | "ignore" | "implicit-processor"} type The type of the current configuration. This is `"config"` in normal. This is `"ignore"` if it came from `.eslintignore`. This is `"implicit-processor"` if it came from legacy file-extension processors.
 */

/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */

var internalSlotsMap = new WeakMap();
/**
 * Check if a given string is a file path.
 * @param {string} nameOrPath A module name or file path.
 * @returns {boolean} `true` if the `nameOrPath` is a file path.
 */

function isFilePath(nameOrPath) {
  return /^\.{1,2}[\/\\]/.test(nameOrPath) || path.isAbsolute(nameOrPath);
}
/**
 * Convenience wrapper for synchronously reading file contents.
 * @param {string} filePath The filename to read.
 * @returns {string} The file contents, with the BOM removed.
 * @private
 */


function readFile(filePath) {
  return fs.readFileSync(filePath, "utf8").replace(/^\uFEFF/, "");
}
/**
 * Loads a YAML configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadYAMLConfigFile(filePath) {
  debug("Loading YAML config file: ".concat(filePath)); // lazy load YAML to improve performance when not used

  var yaml = require("js-yaml");

  try {
    // empty YAML file can be null, so always use
    return yaml.safeLoad(readFile(filePath)) || {};
  } catch (e) {
    debug("Error reading YAML file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a JSON configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadJSONConfigFile(filePath) {
  debug("Loading JSON config file: ".concat(filePath));

  try {
    return JSON.parse(stripComments(readFile(filePath)));
  } catch (e) {
    debug("Error reading JSON file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    e.messageTemplate = "failed-to-read-json";
    e.messageData = {
      path: filePath,
      message: e.message
    };
    throw e;
  }
}
/**
 * Loads a legacy (.eslintrc) configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadLegacyConfigFile(filePath) {
  debug("Loading legacy config file: ".concat(filePath)); // lazy load YAML to improve performance when not used

  var yaml = require("js-yaml");

  try {
    return yaml.safeLoad(stripComments(readFile(filePath))) ||
    /* istanbul ignore next */
    {};
  } catch (e) {
    debug("Error reading YAML file: %s\n%o", filePath, e);
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a JavaScript configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadJSConfigFile(filePath) {
  debug("Loading JS config file: ".concat(filePath));

  try {
    return importFresh(filePath);
  } catch (e) {
    debug("Error reading JavaScript file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a configuration from a package.json file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadPackageJSONConfigFile(filePath) {
  debug("Loading package.json config file: ".concat(filePath));

  try {
    var packageData = loadJSONConfigFile(filePath);

    if (!Object.hasOwnProperty.call(packageData, "eslintConfig")) {
      throw Object.assign(new Error("package.json file doesn't have 'eslintConfig' field."), {
        code: "ESLINT_CONFIG_FIELD_NOT_FOUND"
      });
    }

    return packageData.eslintConfig;
  } catch (e) {
    debug("Error reading package.json file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a `.eslintignore` from a file.
 * @param {string} filePath The filename to load.
 * @returns {string[]} The ignore patterns from the file.
 * @private
 */


function loadESLintIgnoreFile(filePath) {
  debug("Loading .eslintignore file: ".concat(filePath));

  try {
    return readFile(filePath).split(/\r?\n/g).filter(function (line) {
      return line.trim() !== "" && !line.startsWith("#");
    });
  } catch (e) {
    debug("Error reading .eslintignore file: ".concat(filePath));
    e.message = "Cannot read .eslintignore file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Creates an error to notify about a missing config to extend from.
 * @param {string} configName The name of the missing config.
 * @param {string} importerName The name of the config that imported the missing config
 * @param {string} messageTemplate The text template to source error strings from.
 * @returns {Error} The error object to throw
 * @private
 */


function configInvalidError(configName, importerName, messageTemplate) {
  return Object.assign(new Error("Failed to load config \"".concat(configName, "\" to extend from.")), {
    messageTemplate: messageTemplate,
    messageData: {
      configName: configName,
      importerName: importerName
    }
  });
}
/**
 * Loads a configuration file regardless of the source. Inspects the file path
 * to determine the correctly way to load the config file.
 * @param {string} filePath The path to the configuration.
 * @returns {ConfigData|null} The configuration information.
 * @private
 */


function loadConfigFile(filePath) {
  switch (path.extname(filePath)) {
    case ".js":
    case ".cjs":
      return loadJSConfigFile(filePath);

    case ".json":
      if (path.basename(filePath) === "package.json") {
        return loadPackageJSONConfigFile(filePath);
      }

      return loadJSONConfigFile(filePath);

    case ".yaml":
    case ".yml":
      return loadYAMLConfigFile(filePath);

    default:
      return loadLegacyConfigFile(filePath);
  }
}
/**
 * Write debug log.
 * @param {string} request The requested module name.
 * @param {string} relativeTo The file path to resolve the request relative to.
 * @param {string} filePath The resolved file path.
 * @returns {void}
 */


function writeDebugLogForLoading(request, relativeTo, filePath) {
  /* istanbul ignore next */
  if (debug.enabled) {
    var nameAndVersion = null;

    try {
      var packageJsonPath = ModuleResolver.resolve("".concat(request, "/package.json"), relativeTo);

      var _require2 = require(packageJsonPath),
          _require2$version = _require2.version,
          version = _require2$version === void 0 ? "unknown" : _require2$version;

      nameAndVersion = "".concat(request, "@").concat(version);
    } catch (error) {
      debug("package.json was not found:", error.message);
      nameAndVersion = request;
    }

    debug("Loaded: %s (%s)", nameAndVersion, filePath);
  }
}
/**
 * Create a new context with default values.
 * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.
 * @param {"config" | "ignore" | "implicit-processor" | undefined} providedType The type of the current configuration. Default is `"config"`.
 * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.
 * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.
 * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.
 * @returns {ConfigArrayFactoryLoadingContext} The created context.
 */


function createContext(_ref, providedType, providedName, providedFilePath, providedMatchBasePath) {
  var cwd = _ref.cwd,
      resolvePluginsRelativeTo = _ref.resolvePluginsRelativeTo;
  var filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : "";
  var matchBasePath = providedMatchBasePath && path.resolve(cwd, providedMatchBasePath) || filePath && path.dirname(filePath) || cwd;
  var name = providedName || filePath && path.relative(cwd, filePath) || "";
  var pluginBasePath = resolvePluginsRelativeTo || filePath && path.dirname(filePath) || cwd;
  var type = providedType || "config";
  return {
    filePath: filePath,
    matchBasePath: matchBasePath,
    name: name,
    pluginBasePath: pluginBasePath,
    type: type
  };
}
/**
 * Normalize a given plugin.
 * - Ensure the object to have four properties: configs, environments, processors, and rules.
 * - Ensure the object to not have other properties.
 * @param {Plugin} plugin The plugin to normalize.
 * @returns {Plugin} The normalized plugin.
 */


function normalizePlugin(plugin) {
  return {
    configs: plugin.configs || {},
    environments: plugin.environments || {},
    processors: plugin.processors || {},
    rules: plugin.rules || {}
  };
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The factory of `ConfigArray` objects.
 */


var ConfigArrayFactory =
/*#__PURE__*/
function () {
  /**
   * Initialize this instance.
   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.
   */
  function ConfigArrayFactory() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$additionalPlugi = _ref2.additionalPluginPool,
        additionalPluginPool = _ref2$additionalPlugi === void 0 ? new Map() : _ref2$additionalPlugi,
        _ref2$cwd = _ref2.cwd,
        cwd = _ref2$cwd === void 0 ? process.cwd() : _ref2$cwd,
        resolvePluginsRelativeTo = _ref2.resolvePluginsRelativeTo,
        builtInRules = _ref2.builtInRules,
        _ref2$resolver = _ref2.resolver,
        resolver = _ref2$resolver === void 0 ? ModuleResolver : _ref2$resolver,
        eslintAllPath = _ref2.eslintAllPath,
        eslintRecommendedPath = _ref2.eslintRecommendedPath;

    _classCallCheck(this, ConfigArrayFactory);

    internalSlotsMap.set(this, {
      additionalPluginPool: additionalPluginPool,
      cwd: cwd,
      resolvePluginsRelativeTo: resolvePluginsRelativeTo && path.resolve(cwd, resolvePluginsRelativeTo),
      builtInRules: builtInRules,
      resolver: resolver,
      eslintAllPath: eslintAllPath,
      eslintRecommendedPath: eslintRecommendedPath
    });
  }
  /**
   * Create `ConfigArray` instance from a config data.
   * @param {ConfigData|null} configData The config data to create.
   * @param {Object} [options] The options.
   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
   * @param {string} [options.filePath] The path to this config data.
   * @param {string} [options.name] The config name.
   * @returns {ConfigArray} Loaded config.
   */


  _createClass(ConfigArrayFactory, [{
    key: "create",
    value: function create(configData) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          basePath = _ref3.basePath,
          filePath = _ref3.filePath,
          name = _ref3.name;

      if (!configData) {
        return new ConfigArray();
      }

      var slots = internalSlotsMap.get(this);
      var ctx = createContext(slots, "config", name, filePath, basePath);

      var elements = this._normalizeConfigData(configData, ctx);

      return _construct(ConfigArray, _toConsumableArray(elements));
    }
    /**
     * Load a config file.
     * @param {string} filePath The path to a config file.
     * @param {Object} [options] The options.
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
     * @param {string} [options.name] The config name.
     * @returns {ConfigArray} Loaded config.
     */

  }, {
    key: "loadFile",
    value: function loadFile(filePath) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          basePath = _ref4.basePath,
          name = _ref4.name;

      var slots = internalSlotsMap.get(this);
      var ctx = createContext(slots, "config", name, filePath, basePath);
      return _construct(ConfigArray, _toConsumableArray(this._loadConfigData(ctx)));
    }
    /**
     * Load the config file on a given directory if exists.
     * @param {string} directoryPath The path to a directory.
     * @param {Object} [options] The options.
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
     * @param {string} [options.name] The config name.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */

  }, {
    key: "loadInDirectory",
    value: function loadInDirectory(directoryPath) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          basePath = _ref5.basePath,
          name = _ref5.name;

      var slots = internalSlotsMap.get(this);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = configFilenames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var filename = _step.value;
          var ctx = createContext(slots, "config", name, path.join(directoryPath, filename), basePath);

          if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {
            var configData = void 0;

            try {
              configData = loadConfigFile(ctx.filePath);
            } catch (error) {
              if (!error || error.code !== "ESLINT_CONFIG_FIELD_NOT_FOUND") {
                throw error;
              }
            }

            if (configData) {
              debug("Config file found: ".concat(ctx.filePath));
              return _construct(ConfigArray, _toConsumableArray(this._normalizeConfigData(configData, ctx)));
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      debug("Config file not found on ".concat(directoryPath));
      return new ConfigArray();
    }
    /**
     * Check if a config file on a given directory exists or not.
     * @param {string} directoryPath The path to a directory.
     * @returns {string | null} The path to the found config file. If not found then null.
     */

  }, {
    key: "loadESLintIgnore",

    /**
     * Load `.eslintignore` file.
     * @param {string} filePath The path to a `.eslintignore` file to load.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */
    value: function loadESLintIgnore(filePath) {
      var slots = internalSlotsMap.get(this);
      var ctx = createContext(slots, "ignore", void 0, filePath, slots.cwd);
      var ignorePatterns = loadESLintIgnoreFile(ctx.filePath);
      return _construct(ConfigArray, _toConsumableArray(this._normalizeESLintIgnoreData(ignorePatterns, ctx)));
    }
    /**
     * Load `.eslintignore` file in the current working directory.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */

  }, {
    key: "loadDefaultESLintIgnore",
    value: function loadDefaultESLintIgnore() {
      var slots = internalSlotsMap.get(this);
      var eslintIgnorePath = path.resolve(slots.cwd, ".eslintignore");
      var packageJsonPath = path.resolve(slots.cwd, "package.json");

      if (fs.existsSync(eslintIgnorePath)) {
        return this.loadESLintIgnore(eslintIgnorePath);
      }

      if (fs.existsSync(packageJsonPath)) {
        var data = loadJSONConfigFile(packageJsonPath);

        if (Object.hasOwnProperty.call(data, "eslintIgnore")) {
          if (!Array.isArray(data.eslintIgnore)) {
            throw new Error("Package.json eslintIgnore property requires an array of paths");
          }

          var ctx = createContext(slots, "ignore", "eslintIgnore in package.json", packageJsonPath, slots.cwd);
          return _construct(ConfigArray, _toConsumableArray(this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)));
        }
      }

      return new ConfigArray();
    }
    /**
     * Load a given config file.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.
     * @private
     */

  }, {
    key: "_loadConfigData",
    value: function _loadConfigData(ctx) {
      return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);
    }
    /**
     * Normalize a given `.eslintignore` data to config array elements.
     * @param {string[]} ignorePatterns The patterns to ignore files.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeESLintIgnoreData",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeESLintIgnoreData(ignorePatterns, ctx) {
      var elements, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, element;

      return regeneratorRuntime.wrap(function _normalizeESLintIgnoreData$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              elements = this._normalizeObjectConfigData({
                ignorePatterns: ignorePatterns
              }, ctx); // Set `ignorePattern.loose` flag for backward compatibility.

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 4;
              _iterator2 = elements[Symbol.iterator]();

            case 6:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 14;
                break;
              }

              element = _step2.value;

              if (element.ignorePattern) {
                element.ignorePattern.loose = true;
              }

              _context.next = 11;
              return element;

            case 11:
              _iteratorNormalCompletion2 = true;
              _context.next = 6;
              break;

            case 14:
              _context.next = 20;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](4);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t0;

            case 20:
              _context.prev = 20;
              _context.prev = 21;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 23:
              _context.prev = 23;

              if (!_didIteratorError2) {
                _context.next = 26;
                break;
              }

              throw _iteratorError2;

            case 26:
              return _context.finish(23);

            case 27:
              return _context.finish(20);

            case 28:
            case "end":
              return _context.stop();
          }
        }
      }, _normalizeESLintIgnoreData, this, [[4, 16, 20, 28], [21,, 23, 27]]);
    })
    /**
     * Normalize a given config to an array.
     * @param {ConfigData} configData The config data to normalize.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeConfigData",
    value: function _normalizeConfigData(configData, ctx) {
      var validator = new ConfigValidator();
      validator.validateConfigSchema(configData, ctx.name || ctx.filePath);
      return this._normalizeObjectConfigData(configData, ctx);
    }
    /**
     * Normalize a given config to an array.
     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeObjectConfigData",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeObjectConfigData(configData, ctx) {
      var files, excludedFiles, configBody, criteria, elements, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, element;

      return regeneratorRuntime.wrap(function _normalizeObjectConfigData$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              files = configData.files, excludedFiles = configData.excludedFiles, configBody = _objectWithoutProperties(configData, ["files", "excludedFiles"]);
              criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);
              elements = this._normalizeObjectConfigDataBody(configBody, ctx); // Apply the criteria to every element.

              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 6;
              _iterator3 = elements[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context2.next = 17;
                break;
              }

              element = _step3.value;

              /*
               * Merge the criteria.
               * This is for the `overrides` entries that came from the
               * configurations of `overrides[].extends`.
               */
              element.criteria = OverrideTester.and(criteria, element.criteria);
              /*
               * Remove `root` property to ignore `root` settings which came from
               * `extends` in `overrides`.
               */

              if (element.criteria) {
                element.root = void 0;
              }

              _context2.next = 14;
              return element;

            case 14:
              _iteratorNormalCompletion3 = true;
              _context2.next = 8;
              break;

            case 17:
              _context2.next = 23;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](6);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t0;

            case 23:
              _context2.prev = 23;
              _context2.prev = 24;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 26:
              _context2.prev = 26;

              if (!_didIteratorError3) {
                _context2.next = 29;
                break;
              }

              throw _iteratorError3;

            case 29:
              return _context2.finish(26);

            case 30:
              return _context2.finish(23);

            case 31:
            case "end":
              return _context2.stop();
          }
        }
      }, _normalizeObjectConfigData, this, [[6, 19, 23, 31], [24,, 26, 30]]);
    })
    /**
     * Normalize a given config to an array.
     * @param {ConfigData} configData The config data to normalize.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeObjectConfigDataBody",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeObjectConfigDataBody(_ref6, ctx) {
      var env, extend, globals, ignorePatterns, noInlineConfig, parserName, parserOptions, pluginList, processor, reportUnusedDisableDirectives, root, rules, settings, _ref6$overrides, overrideList, extendList, ignorePattern, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, extendName, parser, plugins, i;

      return regeneratorRuntime.wrap(function _normalizeObjectConfigDataBody$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              env = _ref6.env, extend = _ref6["extends"], globals = _ref6.globals, ignorePatterns = _ref6.ignorePatterns, noInlineConfig = _ref6.noInlineConfig, parserName = _ref6.parser, parserOptions = _ref6.parserOptions, pluginList = _ref6.plugins, processor = _ref6.processor, reportUnusedDisableDirectives = _ref6.reportUnusedDisableDirectives, root = _ref6.root, rules = _ref6.rules, settings = _ref6.settings, _ref6$overrides = _ref6.overrides, overrideList = _ref6$overrides === void 0 ? [] : _ref6$overrides;
              extendList = Array.isArray(extend) ? extend : [extend];
              ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath); // Flatten `extends`.

              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context3.prev = 6;
              _iterator4 = extendList.filter(Boolean)[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                _context3.next = 14;
                break;
              }

              extendName = _step4.value;
              return _context3.delegateYield(this._loadExtends(extendName, ctx), "t0", 11);

            case 11:
              _iteratorNormalCompletion4 = true;
              _context3.next = 8;
              break;

            case 14:
              _context3.next = 20;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t1 = _context3["catch"](6);
              _didIteratorError4 = true;
              _iteratorError4 = _context3.t1;

            case 20:
              _context3.prev = 20;
              _context3.prev = 21;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 23:
              _context3.prev = 23;

              if (!_didIteratorError4) {
                _context3.next = 26;
                break;
              }

              throw _iteratorError4;

            case 26:
              return _context3.finish(23);

            case 27:
              return _context3.finish(20);

            case 28:
              // Load parser & plugins.
              parser = parserName && this._loadParser(parserName, ctx);
              plugins = pluginList && this._loadPlugins(pluginList, ctx); // Yield pseudo config data for file extension processors.

              if (!plugins) {
                _context3.next = 32;
                break;
              }

              return _context3.delegateYield(this._takeFileExtensionProcessors(plugins, ctx), "t2", 32);

            case 32:
              _context3.next = 34;
              return {
                // Debug information.
                type: ctx.type,
                name: ctx.name,
                filePath: ctx.filePath,
                // Config data.
                criteria: null,
                env: env,
                globals: globals,
                ignorePattern: ignorePattern,
                noInlineConfig: noInlineConfig,
                parser: parser,
                parserOptions: parserOptions,
                plugins: plugins,
                processor: processor,
                reportUnusedDisableDirectives: reportUnusedDisableDirectives,
                root: root,
                rules: rules,
                settings: settings
              };

            case 34:
              i = 0;

            case 35:
              if (!(i < overrideList.length)) {
                _context3.next = 40;
                break;
              }

              return _context3.delegateYield(this._normalizeObjectConfigData(overrideList[i], _objectSpread({}, ctx, {
                name: "".concat(ctx.name, "#overrides[").concat(i, "]")
              })), "t3", 37);

            case 37:
              ++i;
              _context3.next = 35;
              break;

            case 40:
            case "end":
              return _context3.stop();
          }
        }
      }, _normalizeObjectConfigDataBody, this, [[6, 16, 20, 28], [21,, 23, 27]]);
    })
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtends",
    value: function _loadExtends(extendName, ctx) {
      debug("Loading {extends:%j} relative to %s", extendName, ctx.filePath);

      try {
        if (extendName.startsWith("eslint:")) {
          return this._loadExtendedBuiltInConfig(extendName, ctx);
        }

        if (extendName.startsWith("plugin:")) {
          return this._loadExtendedPluginConfig(extendName, ctx);
        }

        return this._loadExtendedShareableConfig(extendName, ctx);
      } catch (error) {
        error.message += "\nReferenced from: ".concat(ctx.filePath || ctx.name);
        throw error;
      }
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedBuiltInConfig",
    value: function _loadExtendedBuiltInConfig(extendName, ctx) {
      var _internalSlotsMap$get = internalSlotsMap.get(this),
          eslintAllPath = _internalSlotsMap$get.eslintAllPath,
          eslintRecommendedPath = _internalSlotsMap$get.eslintRecommendedPath;

      if (extendName === "eslint:recommended") {
        return this._loadConfigData(_objectSpread({}, ctx, {
          filePath: eslintRecommendedPath,
          name: "".concat(ctx.name, " \xBB ").concat(extendName)
        }));
      }

      if (extendName === "eslint:all") {
        return this._loadConfigData(_objectSpread({}, ctx, {
          filePath: eslintAllPath,
          name: "".concat(ctx.name, " \xBB ").concat(extendName)
        }));
      }

      throw configInvalidError(extendName, ctx.name, "extend-config-missing");
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedPluginConfig",
    value: function _loadExtendedPluginConfig(extendName, ctx) {
      var slashIndex = extendName.lastIndexOf("/");

      if (slashIndex === -1) {
        throw configInvalidError(extendName, ctx.filePath, "plugin-invalid");
      }

      var pluginName = extendName.slice("plugin:".length, slashIndex);
      var configName = extendName.slice(slashIndex + 1);

      if (isFilePath(pluginName)) {
        throw new Error("'extends' cannot use a file path for plugins.");
      }

      var plugin = this._loadPlugin(pluginName, ctx);

      var configData = plugin.definition && plugin.definition.configs[configName];

      if (configData) {
        return this._normalizeConfigData(configData, _objectSpread({}, ctx, {
          filePath: plugin.filePath || ctx.filePath,
          name: "".concat(ctx.name, " \xBB plugin:").concat(plugin.id, "/").concat(configName)
        }));
      }

      throw plugin.error || configInvalidError(extendName, ctx.filePath, "extend-config-missing");
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedShareableConfig",
    value: function _loadExtendedShareableConfig(extendName, ctx) {
      var _internalSlotsMap$get2 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get2.cwd,
          resolver = _internalSlotsMap$get2.resolver;

      var relativeTo = ctx.filePath || path.join(cwd, "__placeholder__.js");
      var request;

      if (isFilePath(extendName)) {
        request = extendName;
      } else if (extendName.startsWith(".")) {
        request = "./".concat(extendName); // For backward compatibility. A ton of tests depended on this behavior.
      } else {
        request = naming.normalizePackageName(extendName, "eslint-config");
      }

      var filePath;

      try {
        filePath = resolver.resolve(request, relativeTo);
      } catch (error) {
        /* istanbul ignore else */
        if (error && error.code === "MODULE_NOT_FOUND") {
          throw configInvalidError(extendName, ctx.filePath, "extend-config-missing");
        }

        throw error;
      }

      writeDebugLogForLoading(request, relativeTo, filePath);
      return this._loadConfigData(_objectSpread({}, ctx, {
        filePath: filePath,
        name: "".concat(ctx.name, " \xBB ").concat(request)
      }));
    }
    /**
     * Load given plugins.
     * @param {string[]} names The plugin names to load.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {Record<string,DependentPlugin>} The loaded parser.
     * @private
     */

  }, {
    key: "_loadPlugins",
    value: function _loadPlugins(names, ctx) {
      var _this = this;

      return names.reduce(function (map, name) {
        if (isFilePath(name)) {
          throw new Error("Plugins array cannot includes file paths.");
        }

        var plugin = _this._loadPlugin(name, ctx);

        map[plugin.id] = plugin;
        return map;
      }, {});
    }
    /**
     * Load a given parser.
     * @param {string} nameOrPath The package name or the path to a parser file.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {DependentParser} The loaded parser.
     */

  }, {
    key: "_loadParser",
    value: function _loadParser(nameOrPath, ctx) {
      debug("Loading parser %j from %s", nameOrPath, ctx.filePath);

      var _internalSlotsMap$get3 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get3.cwd;

      var relativeTo = ctx.filePath || path.join(cwd, "__placeholder__.js");

      try {
        var filePath = ModuleResolver.resolve(nameOrPath, relativeTo);
        writeDebugLogForLoading(nameOrPath, relativeTo, filePath);
        return new ConfigDependency({
          definition: require(filePath),
          filePath: filePath,
          id: nameOrPath,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      } catch (error) {
        // If the parser name is "espree", load the espree of ESLint.
        if (nameOrPath === "espree") {
          debug("Fallback espree.");
          return new ConfigDependency({
            definition: require("espree"),
            filePath: require.resolve("espree"),
            id: nameOrPath,
            importerName: ctx.name,
            importerPath: ctx.filePath
          });
        }

        debug("Failed to load parser '%s' declared in '%s'.", nameOrPath, ctx.name);
        error.message = "Failed to load parser '".concat(nameOrPath, "' declared in '").concat(ctx.name, "': ").concat(error.message);
        return new ConfigDependency({
          error: error,
          id: nameOrPath,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      }
    }
    /**
     * Load a given plugin.
     * @param {string} name The plugin name to load.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {DependentPlugin} The loaded plugin.
     * @private
     */

  }, {
    key: "_loadPlugin",
    value: function _loadPlugin(name, ctx) {
      debug("Loading plugin %j from %s", name, ctx.filePath);

      var _internalSlotsMap$get4 = internalSlotsMap.get(this),
          additionalPluginPool = _internalSlotsMap$get4.additionalPluginPool;

      var request = naming.normalizePackageName(name, "eslint-plugin");
      var id = naming.getShorthandName(request, "eslint-plugin");
      var relativeTo = path.join(ctx.pluginBasePath, "__placeholder__.js");

      if (name.match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/)) {
        var _error = Object.assign(new Error("Whitespace found in plugin name '".concat(name, "'")), {
          messageTemplate: "whitespace-found",
          messageData: {
            pluginName: request
          }
        });

        return new ConfigDependency({
          error: _error,
          id: id,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      } // Check for additional pool.


      var plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);

      if (plugin) {
        return new ConfigDependency({
          definition: normalizePlugin(plugin),
          filePath: "",
          // It's unknown where the plugin came from.
          id: id,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      }

      var filePath;
      var error;

      try {
        filePath = ModuleResolver.resolve(request, relativeTo);
      } catch (resolveError) {
        error = resolveError;
        /* istanbul ignore else */

        if (error && error.code === "MODULE_NOT_FOUND") {
          error.messageTemplate = "plugin-missing";
          error.messageData = {
            pluginName: request,
            resolvePluginsRelativeTo: ctx.pluginBasePath,
            importerName: ctx.name
          };
        }
      }

      if (filePath) {
        try {
          writeDebugLogForLoading(request, relativeTo, filePath);
          var startTime = Date.now();

          var pluginDefinition = require(filePath);

          debug("Plugin ".concat(filePath, " loaded in: ").concat(Date.now() - startTime, "ms"));
          return new ConfigDependency({
            definition: normalizePlugin(pluginDefinition),
            filePath: filePath,
            id: id,
            importerName: ctx.name,
            importerPath: ctx.filePath
          });
        } catch (loadError) {
          error = loadError;
        }
      }

      debug("Failed to load plugin '%s' declared in '%s'.", name, ctx.name);
      error.message = "Failed to load plugin '".concat(name, "' declared in '").concat(ctx.name, "': ").concat(error.message);
      return new ConfigDependency({
        error: error,
        id: id,
        importerName: ctx.name,
        importerPath: ctx.filePath
      });
    }
    /**
     * Take file expression processors as config array elements.
     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.
     * @private
     */

  }, {
    key: "_takeFileExtensionProcessors",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _takeFileExtensionProcessors(plugins, ctx) {
      var _i, _Object$keys, pluginId, processors, _i2, _Object$keys2, processorId;

      return regeneratorRuntime.wrap(function _takeFileExtensionProcessors$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _i = 0, _Object$keys = Object.keys(plugins);

            case 1:
              if (!(_i < _Object$keys.length)) {
                _context4.next = 17;
                break;
              }

              pluginId = _Object$keys[_i];
              processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;

              if (processors) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("continue", 14);

            case 6:
              _i2 = 0, _Object$keys2 = Object.keys(processors);

            case 7:
              if (!(_i2 < _Object$keys2.length)) {
                _context4.next = 14;
                break;
              }

              processorId = _Object$keys2[_i2];

              if (!processorId.startsWith(".")) {
                _context4.next = 11;
                break;
              }

              return _context4.delegateYield(this._normalizeObjectConfigData({
                files: ["*".concat(processorId)],
                processor: "".concat(pluginId, "/").concat(processorId)
              }, _objectSpread({}, ctx, {
                type: "implicit-processor",
                name: "".concat(ctx.name, "#processors[\"").concat(pluginId, "/").concat(processorId, "\"]")
              })), "t0", 11);

            case 11:
              _i2++;
              _context4.next = 7;
              break;

            case 14:
              _i++;
              _context4.next = 1;
              break;

            case 17:
            case "end":
              return _context4.stop();
          }
        }
      }, _takeFileExtensionProcessors, this);
    })
  }], [{
    key: "getPathToConfigFileInDirectory",
    value: function getPathToConfigFileInDirectory(directoryPath) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = configFilenames[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var filename = _step5.value;
          var filePath = path.join(directoryPath, filename);

          if (fs.existsSync(filePath)) {
            if (filename === "package.json") {
              try {
                loadPackageJSONConfigFile(filePath);
                return filePath;
              } catch (_unused) {
                /* ignore */
              }
            } else {
              return filePath;
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return null;
    }
  }]);

  return ConfigArrayFactory;
}();

module.exports = {
  ConfigArrayFactory: ConfigArrayFactory,
  createContext: createContext
};