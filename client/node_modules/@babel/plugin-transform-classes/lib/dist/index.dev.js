"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");

var _helperFunctionName = require("@babel/helper-function-name");

var _helperSplitExportDeclaration = require("@babel/helper-split-export-declaration");

var _core = require("@babel/core");

var _globals = require("globals");

var _transformClass = require("./transformClass");

var getBuiltinClasses = function getBuiltinClasses(category) {
  return Object.keys(_globals[category]).filter(function (name) {
    return /^[A-Z]/.test(name);
  });
};

var builtinClasses = new Set([].concat(_toConsumableArray(getBuiltinClasses("builtin")), _toConsumableArray(getBuiltinClasses("browser"))));

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;

  api.assertVersion(7);
  var loose = options.loose;
  var setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : options.loose;
  var constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : options.loose;
  var superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : options.loose;
  var noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : options.loose;
  var VISITED = Symbol();
  return {
    name: "transform-classes",
    visitor: {
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
        if (!path.get("declaration").isClassDeclaration()) return;
        (0, _helperSplitExportDeclaration["default"])(path);
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var node = path.node;
        var ref = node.id || path.scope.generateUidIdentifier("class");
        path.replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));
      },
      ClassExpression: function ClassExpression(path, state) {
        var node = path.node;
        if (node[VISITED]) return;
        var inferred = (0, _helperFunctionName["default"])(path);

        if (inferred && inferred !== node) {
          path.replaceWith(inferred);
          return;
        }

        node[VISITED] = true;
        path.replaceWith((0, _transformClass["default"])(path, state.file, builtinClasses, loose, {
          setClassMethods: setClassMethods,
          constantSuper: constantSuper,
          superIsCallableConstructor: superIsCallableConstructor,
          noClassCalls: noClassCalls
        }));

        if (path.isCallExpression()) {
          (0, _helperAnnotateAsPure["default"])(path);
          var callee = path.get("callee");

          if (callee.isArrowFunctionExpression()) {
            callee.arrowFunctionToExpression();
          }
        }
      }
    }
  };
});

exports["default"] = _default;