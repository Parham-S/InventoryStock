"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = transformClass;

var _helperFunctionName = require("@babel/helper-function-name");

var _helperReplaceSupers = require("@babel/helper-replace-supers");

var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");

var _core = require("@babel/core");

var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");

var _inlineCreateSuperHelpers = require("./inline-createSuper-helpers");

function buildConstructor(classRef, constructorBody, node) {
  var func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);

  _core.types.inherits(func, node);

  return func;
}

function transformClass(path, file, builtinClasses, isLoose, assumptions) {
  var classState = {
    parent: undefined,
    scope: undefined,
    node: undefined,
    path: undefined,
    file: undefined,
    classId: undefined,
    classRef: undefined,
    superFnId: undefined,
    superName: undefined,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: undefined,
    constructorBody: undefined,
    userConstructor: undefined,
    userConstructorPath: undefined,
    hasConstructor: false,
    staticPropBody: [],
    body: [],
    superThises: [],
    pushedConstructor: false,
    pushedInherits: false,
    protoAlias: null,
    isLoose: false,
    dynamicKeys: new Map(),
    methods: {
      instance: {
        hasComputed: false,
        list: [],
        map: new Map()
      },
      "static": {
        hasComputed: false,
        list: [],
        map: new Map()
      }
    }
  };

  var setState = function setState(newState) {
    Object.assign(classState, newState);
  };

  var findThisesVisitor = _core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
    ThisExpression: function ThisExpression(path) {
      classState.superThises.push(path);
    }
  }]);

  function maybeCreateConstructor() {
    var hasConstructor = false;
    var paths = classState.path.get("body.body");
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _path = _step.value;
        hasConstructor = _path.equals("kind", "constructor");
        if (hasConstructor) break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (hasConstructor) return;
    var params, body;

    if (classState.isDerived) {
      var _constructor = _core.template.expression.ast(_templateObject());

      params = _constructor.params;
      body = _constructor.body;
    } else {
      params = [];
      body = _core.types.blockStatement([]);
    }

    classState.path.get("body").unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
  }

  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();

    if (classState.userConstructor) {
      var _constructorBody$body;

      var constructorBody = classState.constructorBody,
          userConstructor = classState.userConstructor,
          construct = classState.construct;

      (_constructorBody$body = constructorBody.body).push.apply(_constructorBody$body, _toConsumableArray(userConstructor.body.body));

      _core.types.inherits(construct, userConstructor);

      _core.types.inherits(constructorBody, userConstructor.body);
    }

    pushDescriptors();
  }

  function pushBody() {
    var classBodyPaths = classState.path.get("body.body");
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = classBodyPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _path2 = _step2.value;
        var node = _path2.node;

        if (_path2.isClassProperty()) {
          throw _path2.buildCodeFrameError("Missing class properties transform.");
        }

        if (node.decorators) {
          throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
        }

        if (_core.types.isClassMethod(node)) {
          (function () {
            var isConstructor = node.kind === "constructor";
            var replaceSupers = new _helperReplaceSupers["default"]({
              methodPath: _path2,
              objectRef: classState.classRef,
              superRef: classState.superName,
              constantSuper: assumptions.constantSuper,
              file: classState.file,
              refToPreserve: classState.classRef
            });
            replaceSupers.replace();
            var superReturns = [];

            _path2.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
              ReturnStatement: function ReturnStatement(path) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  superReturns.push(path);
                }
              }
            }]));

            if (isConstructor) {
              pushConstructor(superReturns, node, _path2);
            } else {
              pushMethod(node, _path2);
            }
          })();
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  function pushDescriptors() {
    pushInheritsToBody();
    var body = classState.body;
    var props = {
      instance: null,
      "static": null
    };

    for (var _i = 0, _arr = ["static", "instance"]; _i < _arr.length; _i++) {
      var placement = _arr[_i];

      if (classState.methods[placement].list.length) {
        props[placement] = classState.methods[placement].list.map(function (desc) {
          var obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("key"), desc.key)]);

          for (var _i2 = 0, _arr2 = ["get", "set", "value"]; _i2 < _arr2.length; _i2++) {
            var kind = _arr2[_i2];

            if (desc[kind] != null) {
              obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));
            }
          }

          return obj;
        });
      }
    }

    if (props.instance || props["static"]) {
      var args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props["static"] ? _core.types.arrayExpression(props["static"]) : _core.types.nullLiteral()];
      var lastNonNullIndex = 0;

      for (var i = 0; i < args.length; i++) {
        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;
      }

      args = args.slice(0, lastNonNullIndex + 1);
      body.push(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("createClass"), args)));
    }
  }

  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    var bareSuperNode = bareSuper.node;
    var call;

    if (assumptions.superIsCallableConstructor) {
      bareSuperNode.arguments.unshift(_core.types.thisExpression());

      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
        name: "arguments"
      })) {
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"));
      } else {
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call"));
      }

      call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression());
    } else {
      call = (0, _helperOptimiseCallExpression["default"])(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments, false);
    }

    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
      if (classState.superThises.length) {
        call = _core.types.assignmentExpression("=", thisRef(), call);
      }

      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));
    } else {
      bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
    }
  }

  function verifyConstructor() {
    if (!classState.isDerived) return;
    var path = classState.userConstructorPath;
    var body = path.get("body");
    path.traverse(findThisesVisitor);

    var _thisRef = function thisRef() {
      var ref = path.scope.generateDeclaredUidIdentifier("this");

      _thisRef = function thisRef() {
        return _core.types.cloneNode(ref);
      };

      return ref;
    };

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = classState.superThises[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var thisPath = _step3.value;
        var node = thisPath.node,
            parentPath = thisPath.parentPath;

        if (parentPath.isMemberExpression({
          object: node
        })) {
          thisPath.replaceWith(_thisRef());
          continue;
        }

        thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var bareSupers = new Set();
    path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {
      Super: function Super(path) {
        var node = path.node,
            parentPath = path.parentPath;

        if (parentPath.isCallExpression({
          callee: node
        })) {
          bareSupers.add(parentPath);
        }
      }
    }]));
    var guaranteedSuperBeforeFinish = !!bareSupers.size;
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = bareSupers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var bareSuper = _step4.value;
        wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

        if (guaranteedSuperBeforeFinish) {
          bareSuper.find(function (parentPath) {
            if (parentPath === path) {
              return true;
            }

            if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
              guaranteedSuperBeforeFinish = false;
              return true;
            }
          });
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    var wrapReturn;

    if (classState.isLoose) {
      wrapReturn = function wrapReturn(returnArg) {
        var thisExpr = _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);

        return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
      };
    } else {
      wrapReturn = function wrapReturn(returnArg) {
        return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
      };
    }

    var bodyPaths = body.get("body");

    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
      body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
    }

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = classState.superReturns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var returnPath = _step5.value;
        returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
          _iterator5["return"]();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  }

  function pushMethod(node, path) {
    var scope = path ? path.scope : classState.scope;

    if (node.kind === "method") {
      if (processMethod(node, scope)) return;
    }

    var placement = node["static"] ? "static" : "instance";
    var methods = classState.methods[placement];
    var descKey = node.kind === "method" ? "value" : node.kind;
    var key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);

    var fn = _core.types.toExpression(node);

    if (_core.types.isStringLiteral(key)) {
      if (node.kind === "method") {
        fn = (0, _helperFunctionName["default"])({
          id: key,
          node: node,
          scope: scope
        });
      }
    } else {
      methods.hasComputed = true;
    }

    var descriptor;

    if (!methods.hasComputed && methods.map.has(key.value)) {
      descriptor = methods.map.get(key.value);
      descriptor[descKey] = fn;

      if (descKey === "value") {
        descriptor.get = null;
        descriptor.set = null;
      } else {
        descriptor.value = null;
      }
    } else {
      descriptor = _defineProperty({
        key: key
      }, descKey, fn);
      methods.list.push(descriptor);

      if (!methods.hasComputed) {
        methods.map.set(key.value, descriptor);
      }
    }
  }

  function processMethod(node, scope) {
    if (assumptions.setClassMethods && !node.decorators) {
      var classRef = classState.classRef;

      if (!node["static"]) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }

      var methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));

      var func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);

      _core.types.inherits(func, node);

      var key = _core.types.toComputedKey(node, node.key);

      if (_core.types.isStringLiteral(key)) {
        func = (0, _helperFunctionName["default"])({
          node: func,
          id: key,
          scope: scope
        });
      }

      var expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));

      _core.types.inheritsComments(expr, node);

      classState.body.push(expr);
      return true;
    }

    return false;
  }

  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({
        protoAlias: classState.scope.generateUidIdentifier("proto")
      });

      var classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype"));

      var protoDeclaration = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);

      classState.body.push(protoDeclaration);
    }
  }

  function pushConstructor(superReturns, method, path) {
    setState({
      userConstructorPath: path,
      userConstructor: method,
      hasConstructor: true,
      superReturns: superReturns
    });
    var construct = classState.construct;

    _core.types.inheritsComments(construct, method);

    construct.params = method.params;

    _core.types.inherits(construct.body, method.body);

    construct.body.directives = method.body.directives;
    pushConstructorToBody();
  }

  function pushConstructorToBody() {
    if (classState.pushedConstructor) return;
    classState.pushedConstructor = true;

    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
      pushDescriptors();
    }

    classState.body.push(classState.construct);
    pushInheritsToBody();
  }

  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    var superFnId = path.scope.generateUidIdentifier("super");
    setState({
      pushedInherits: true,
      superFnId: superFnId
    });

    if (!assumptions.superIsCallableConstructor) {
      classState.body.unshift(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(superFnId, _core.types.callExpression((0, _inlineCreateSuperHelpers["default"])(classState.file), [_core.types.cloneNode(classState.classRef)]))]));
    }

    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));
  }

  function extractDynamicKeys() {
    var dynamicKeys = classState.dynamicKeys,
        node = classState.node,
        scope = classState.scope;
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = node.body.body[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var elem = _step6.value;
        if (!_core.types.isClassMethod(elem) || !elem.computed) continue;
        if (scope.isPure(elem.key, true)) continue;
        var id = scope.generateUidIdentifierBasedOnNode(elem.key);
        dynamicKeys.set(id.name, elem.key);
        elem.key = id;
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
          _iterator6["return"]();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
  }

  function setupClosureParamsArgs() {
    var superName = classState.superName,
        dynamicKeys = classState.dynamicKeys;
    var closureParams = [];
    var closureArgs = [];

    if (classState.isDerived) {
      var arg = _core.types.cloneNode(superName);

      if (classState.extendsNative) {
        arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
        (0, _helperAnnotateAsPure["default"])(arg);
      }

      var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
      closureParams.push(param);
      closureArgs.push(arg);
      setState({
        superName: _core.types.cloneNode(param)
      });
    }

    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = dynamicKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var _step7$value = _slicedToArray(_step7.value, 2),
            name = _step7$value[0],
            value = _step7$value[1];

        closureParams.push(_core.types.identifier(name));
        closureArgs.push(value);
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
          _iterator7["return"]();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }

    return {
      closureParams: closureParams,
      closureArgs: closureArgs
    };
  }

  function classTransformer(path, file, builtinClasses, isLoose) {
    setState({
      parent: path.parent,
      scope: path.scope,
      node: path.node,
      path: path,
      file: file,
      isLoose: isLoose
    });
    setState({
      classId: classState.node.id,
      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: _core.types.blockStatement([])
    });
    setState({
      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
    });
    var classRef = classState.classRef,
        node = classState.node,
        constructorBody = classState.constructorBody;
    setState({
      construct: buildConstructor(classRef, constructorBody, node)
    });
    extractDynamicKeys();
    var body = classState.body;

    var _setupClosureParamsAr = setupClosureParamsArgs(),
        closureParams = _setupClosureParamsAr.closureParams,
        closureArgs = _setupClosureParamsAr.closureArgs;

    buildBody();

    if (!assumptions.noClassCalls) {
      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));
    }

    body.push.apply(body, _toConsumableArray(classState.staticPropBody.map(function (fn) {
      return fn(_core.types.cloneNode(classState.classRef));
    })));
    var isStrict = path.isInStrictMode();
    var constructorOnly = classState.classId && body.length === 1;

    if (constructorOnly && !isStrict) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = classState.construct.params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var param = _step8.value;

          if (!_core.types.isIdentifier(param)) {
            constructorOnly = false;
            break;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }

    var directives = constructorOnly ? body[0].body.directives : [];

    if (!isStrict) {
      directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
    }

    if (constructorOnly) {
      return _core.types.toExpression(body[0]);
    }

    body.push(_core.types.returnStatement(_core.types.cloneNode(classState.classRef)));

    var container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));

    return _core.types.callExpression(container, closureArgs);
  }

  return classTransformer(path, file, builtinClasses, isLoose);
}