"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClassFeaturePlugin = createClassFeaturePlugin;
Object.defineProperty(exports, "injectInitialization", {
  enumerable: true,
  get: function get() {
    return _misc.injectInitialization;
  }
});
Object.defineProperty(exports, "enableFeature", {
  enumerable: true,
  get: function get() {
    return _features.enableFeature;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function get() {
    return _features.FEATURES;
  }
});

var _core = require("@babel/core");

var _helperFunctionName = require("@babel/helper-function-name");

var _helperSplitExportDeclaration = require("@babel/helper-split-export-declaration");

var _fields = require("./fields");

var _decorators = require("./decorators");

var _misc = require("./misc");

var _features = require("./features");

var version = "7.15.4".split(".").reduce(function (v, x) {
  return v * 1e5 + +x;
}, 0);
var versionKey = "@babel/plugin-class-features/version";

function createClassFeaturePlugin(_ref) {
  var name = _ref.name,
      feature = _ref.feature,
      loose = _ref.loose,
      manipulateOptions = _ref.manipulateOptions,
      _ref$api = _ref.api,
      api = _ref$api === void 0 ? {
    assumption: function assumption() {
      return void 0;
    }
  } : _ref$api;
  var setPublicClassFields = api.assumption("setPublicClassFields");
  var privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
  var constantSuper = api.assumption("constantSuper");
  var noDocumentAll = api.assumption("noDocumentAll");

  if (loose === true) {
    var explicit = [];

    if (setPublicClassFields !== undefined) {
      explicit.push("\"setPublicClassFields\"");
    }

    if (privateFieldsAsProperties !== undefined) {
      explicit.push("\"privateFieldsAsProperties\"");
    }

    if (explicit.length !== 0) {
      console.warn("[".concat(name, "]: You are using the \"loose: true\" option and you are") + " explicitly setting a value for the ".concat(explicit.join(" and ")) + " assumption".concat(explicit.length > 1 ? "s" : "", ". The \"loose\" option") + " can cause incompatibilities with the other class features" + " plugins, so it's recommended that you replace it with the" + " following top-level option:\n" + "\t\"assumptions\": {\n" + "\t\t\"setPublicClassFields\": true,\n" + "\t\t\"privateFieldsAsProperties\": true\n" + "\t}");
    }
  }

  return {
    name: name,
    manipulateOptions: manipulateOptions,
    pre: function pre() {
      (0, _features.enableFeature)(this.file, feature, loose);

      if (!this.file.get(versionKey) || this.file.get(versionKey) < version) {
        this.file.set(versionKey, version);
      }
    },
    visitor: {
      Class: function Class(path, state) {
        if (this.file.get(versionKey) !== version) return;
        (0, _features.verifyUsedFeatures)(path, this.file);
        var loose = (0, _features.isLoose)(this.file, feature);
        var constructor;
        var isDecorated = (0, _decorators.hasDecorators)(path.node);
        var props = [];
        var elements = [];
        var computedPaths = [];
        var privateNames = new Set();
        var body = path.get("body");
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = body.get("body")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _path = _step.value;
            (0, _features.verifyUsedFeatures)(_path, this.file);

            if ((_path.isClassProperty() || _path.isClassMethod()) && _path.node.computed) {
              computedPaths.push(_path);
            }

            if (_path.isPrivate()) {
              var _name = _path.node.key.id.name;
              var getName = "get ".concat(_name);
              var setName = "set ".concat(_name);

              if (_path.isClassPrivateMethod()) {
                if (_path.node.kind === "get") {
                  if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }

                  privateNames.add(getName).add(_name);
                } else if (_path.node.kind === "set") {
                  if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }

                  privateNames.add(setName).add(_name);
                }
              } else {
                if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(_name);
              }
            }

            if (_path.isClassMethod({
              kind: "constructor"
            })) {
              constructor = _path;
            } else {
              elements.push(_path);

              if (_path.isProperty() || _path.isPrivate() || _path.isStaticBlock != null && _path.isStaticBlock()) {
                props.push(_path);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (!props.length && !isDecorated) return;
        var innerBinding = path.node.id;
        var ref;

        if (!innerBinding || path.isClassExpression()) {
          (0, _helperFunctionName["default"])(path);
          ref = path.scope.generateUidIdentifier("class");
        } else {
          ref = _core.types.cloneNode(path.node.id);
        }

        var privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);
        var privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, state);
        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, {
          privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,
          noDocumentAll: noDocumentAll,
          innerBinding: innerBinding
        }, state);
        var keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;

        if (isDecorated) {
          staticNodes = pureStaticNodes = keysNodes = [];

          var _ref2 = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file);

          instanceNodes = _ref2.instanceNodes;
          wrapClass = _ref2.wrapClass;
        } else {
          keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file);

          var _ref3 = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding);

          staticNodes = _ref3.staticNodes;
          pureStaticNodes = _ref3.pureStaticNodes;
          instanceNodes = _ref3.instanceNodes;
          wrapClass = _ref3.wrapClass;
        }

        if (instanceNodes.length > 0) {
          (0, _misc.injectInitialization)(path, constructor, instanceNodes, function (referenceVisitor, state) {
            if (isDecorated) return;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var prop = _step2.value;
                if (prop.node["static"]) continue;
                prop.traverse(referenceVisitor, state);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          });
        }

        var wrappedPath = wrapClass(path);
        wrappedPath.insertBefore([].concat(_toConsumableArray(privateNamesNodes), _toConsumableArray(keysNodes)));

        if (staticNodes.length > 0) {
          wrappedPath.insertAfter(staticNodes);
        }

        if (pureStaticNodes.length > 0) {
          wrappedPath.find(function (parent) {
            return parent.isStatement() || parent.isDeclaration();
          }).insertAfter(pureStaticNodes);
        }
      },
      PrivateName: function PrivateName(path) {
        if (this.file.get(versionKey) !== version || path.parentPath.isPrivate({
          key: path.node
        })) {
          return;
        }

        throw path.buildCodeFrameError("Unknown PrivateName \"".concat(path, "\""));
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
        if (this.file.get(versionKey) !== version) return;
        var decl = path.get("declaration");

        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {
          if (decl.node.id) {
            (0, _helperSplitExportDeclaration["default"])(path);
          } else {
            decl.node.type = "ClassExpression";
          }
        }
      }
    }
  };
}