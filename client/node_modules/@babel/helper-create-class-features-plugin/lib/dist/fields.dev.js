"use strict";

function _templateObject19() {
  var data = _taggedTemplateLiteral(["(() => ", ")()"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["", "(\n    ", ",\n    ", "\n  )"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["", ".add(", ")"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["", "(\n    ", ",\n    ", ",\n    {\n      get: ", ",\n      set: ", "\n    },\n  )"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["", "(\n    ", ",\n    ", ",\n    {\n      writable: true,\n      value: ", "\n    },\n  )"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["", ".set(", ", {\n        // configurable is always false for private elements\n        // enumerable is always false for private elements\n        writable: true,\n        value: ", ",\n      })"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["BASE(REF, PROP)[PROP]"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", ".has(", ")"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n        Object.prototype.hasOwnProperty.call(", ", ", ")\n      "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["var ", " = ", ""]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPrivateNamesMap = buildPrivateNamesMap;
exports.buildPrivateNamesNodes = buildPrivateNamesNodes;
exports.transformPrivateNamesUsage = transformPrivateNamesUsage;
exports.buildFieldsInitNodes = buildFieldsInitNodes;

var _core = require("@babel/core");

var _helperReplaceSupers = require("@babel/helper-replace-supers");

var _helperMemberExpressionToFunctions = require("@babel/helper-member-expression-to-functions");

var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");

var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");

var ts = require("./typescript");

function buildPrivateNamesMap(props) {
  var privateNamesMap = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;

      if (prop.isPrivate()) {
        var name = prop.node.key.id.name;
        var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          "static": prop.node["static"],
          method: !prop.isProperty()
        };

        if (prop.isClassPrivateMethod()) {
          if (prop.node.kind === "get") {
            update.getId = prop.scope.generateUidIdentifier("get_".concat(name));
          } else if (prop.node.kind === "set") {
            update.setId = prop.scope.generateUidIdentifier("set_".concat(name));
          } else if (prop.node.kind === "method") {
            update.methodId = prop.scope.generateUidIdentifier(name);
          }
        }

        privateNamesMap.set(name, update);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return privateNamesMap;
}

function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, state) {
  var initNodes = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = privateNamesMap[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          name = _step2$value[0],
          value = _step2$value[1];

      var isStatic = value["static"],
          isMethod = value.method,
          getId = value.getId,
          setId = value.setId;
      var isAccessor = getId || setId;

      var id = _core.types.cloneNode(value.id);

      var init = void 0;

      if (privateFieldsAsProperties) {
        init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]);
      } else if (!isStatic) {
        init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), []);
      }

      if (init) {
        (0, _helperAnnotateAsPure["default"])(init);
        initNodes.push(_core.template.statement.ast(_templateObject(), id, init));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return initNodes;
}

function privateNameVisitorFactory(visitor) {
  var privateNameVisitor = Object.assign({}, visitor, {
    Class: function Class(path) {
      var privateNamesMap = this.privateNamesMap;
      var body = path.get("body.body");
      var visiblePrivateNames = new Map(privateNamesMap);
      var redeclared = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var prop = _step3.value;
          if (!prop.isPrivate()) continue;
          var name = prop.node.key.id.name;
          visiblePrivateNames["delete"](name);
          redeclared.push(name);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!redeclared.length) {
        return;
      }

      path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
        redeclared: redeclared
      }));
      path.traverse(privateNameVisitor, Object.assign({}, this, {
        privateNamesMap: visiblePrivateNames
      }));
      path.skipKey("body");
    }
  });

  var nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);

  return privateNameVisitor;
}

var privateNameVisitor = privateNameVisitorFactory({
  PrivateName: function PrivateName(path, _ref) {
    var noDocumentAll = _ref.noDocumentAll;
    var privateNamesMap = this.privateNamesMap,
        redeclared = this.redeclared;
    var node = path.node,
        parentPath = path.parentPath;

    if (!parentPath.isMemberExpression({
      property: node
    }) && !parentPath.isOptionalMemberExpression({
      property: node
    })) {
      return;
    }

    var name = node.id.name;
    if (!privateNamesMap.has(name)) return;
    if (redeclared && redeclared.includes(name)) return;
    this.handle(parentPath, noDocumentAll);
  }
});

function unshadow(name, scope, innerBinding) {
  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
    var _scope;

    scope.rename(name);
    scope = scope.parent;
  }
}

var privateInVisitor = privateNameVisitorFactory({
  BinaryExpression: function BinaryExpression(path) {
    var _path$node = path.node,
        operator = _path$node.operator,
        left = _path$node.left,
        right = _path$node.right;
    if (operator !== "in") return;
    if (!_core.types.isPrivateName(left)) return;
    var privateFieldsAsProperties = this.privateFieldsAsProperties,
        privateNamesMap = this.privateNamesMap,
        redeclared = this.redeclared;
    var name = left.id.name;
    if (!privateNamesMap.has(name)) return;
    if (redeclared && redeclared.includes(name)) return;
    unshadow(this.classRef.name, path.scope, this.innerBinding);

    if (privateFieldsAsProperties) {
      var _privateNamesMap$get = privateNamesMap.get(name),
          _id = _privateNamesMap$get.id;

      path.replaceWith(_core.template.expression.ast(_templateObject2(), right, _core.types.cloneNode(_id)));
      return;
    }

    var _privateNamesMap$get2 = privateNamesMap.get(name),
        id = _privateNamesMap$get2.id,
        isStatic = _privateNamesMap$get2["static"];

    if (isStatic) {
      path.replaceWith(_core.template.expression.ast(_templateObject3(), right, this.classRef));
      return;
    }

    path.replaceWith(_core.template.expression.ast(_templateObject4(), _core.types.cloneNode(id), right));
  }
});
var privateNameHandlerSpec = {
  memoise: function memoise(member, count) {
    var scope = member.scope;
    var object = member.node.object;
    var memo = scope.maybeGenerateMemoised(object);

    if (!memo) {
      return;
    }

    this.memoiser.set(object, memo, count);
  },
  receiver: function receiver(member) {
    var object = member.node.object;

    if (this.memoiser.has(object)) {
      return _core.types.cloneNode(this.memoiser.get(object));
    }

    return _core.types.cloneNode(object);
  },
  get: function get(member) {
    var classRef = this.classRef,
        privateNamesMap = this.privateNamesMap,
        file = this.file,
        innerBinding = this.innerBinding;
    var name = member.node.property.id.name;

    var _privateNamesMap$get3 = privateNamesMap.get(name),
        id = _privateNamesMap$get3.id,
        isStatic = _privateNamesMap$get3["static"],
        isMethod = _privateNamesMap$get3.method,
        methodId = _privateNamesMap$get3.methodId,
        getId = _privateNamesMap$get3.getId,
        setId = _privateNamesMap$get3.setId;

    var isAccessor = getId || setId;

    if (isStatic) {
      var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
      unshadow(classRef.name, member.scope, innerBinding);
      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);
    }

    if (isMethod) {
      if (isAccessor) {
        if (!getId && setId) {
          if (file.availableHelper("writeOnlyError")) {
            return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral("#".concat(name))])]);
          }

          console.warn("@babel/helpers is outdated, update it to silence this warning.");
        }

        return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
      }

      return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);
    }

    return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
  },
  boundGet: function boundGet(member) {
    this.memoise(member, 1);
    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
  },
  set: function set(member, value) {
    var classRef = this.classRef,
        privateNamesMap = this.privateNamesMap,
        file = this.file;
    var name = member.node.property.id.name;

    var _privateNamesMap$get4 = privateNamesMap.get(name),
        id = _privateNamesMap$get4.id,
        isStatic = _privateNamesMap$get4["static"],
        isMethod = _privateNamesMap$get4.method,
        setId = _privateNamesMap$get4.setId,
        getId = _privateNamesMap$get4.getId;

    var isAccessor = getId || setId;

    if (isStatic) {
      var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);
    }

    if (isMethod) {
      if (setId) {
        return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value]);
      }

      return _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral("#".concat(name))])]);
    }

    return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value]);
  },
  destructureSet: function destructureSet(member) {
    var classRef = this.classRef,
        privateNamesMap = this.privateNamesMap,
        file = this.file;
    var name = member.node.property.id.name;

    var _privateNamesMap$get5 = privateNamesMap.get(name),
        id = _privateNamesMap$get5.id,
        isStatic = _privateNamesMap$get5["static"];

    if (isStatic) {
      try {
        var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
      } catch (_unused) {
        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
      }

      return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier("value"));
    }

    return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier("value"));
  },
  call: function call(member, args) {
    this.memoise(member, 1);
    return (0, _helperOptimiseCallExpression["default"])(this.get(member), this.receiver(member), args, false);
  },
  optionalCall: function optionalCall(member, args) {
    this.memoise(member, 1);
    return (0, _helperOptimiseCallExpression["default"])(this.get(member), this.receiver(member), args, true);
  }
};
var privateNameHandlerLoose = {
  get: function get(member) {
    var privateNamesMap = this.privateNamesMap,
        file = this.file;
    var object = member.node.object;
    var name = member.node.property.id.name;
    return _core.template.expression(_templateObject5())({
      BASE: file.addHelper("classPrivateFieldLooseBase"),
      REF: _core.types.cloneNode(object),
      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
    });
  },
  set: function set() {
    throw new Error("private name handler with loose = true don't need set()");
  },
  boundGet: function boundGet(member) {
    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
  },
  simpleSet: function simpleSet(member) {
    return this.get(member);
  },
  destructureSet: function destructureSet(member) {
    return this.get(member);
  },
  call: function call(member, args) {
    return _core.types.callExpression(this.get(member), args);
  },
  optionalCall: function optionalCall(member, args) {
    return _core.types.optionalCallExpression(this.get(member), args, true);
  }
};

function transformPrivateNamesUsage(ref, path, privateNamesMap, _ref2, state) {
  var privateFieldsAsProperties = _ref2.privateFieldsAsProperties,
      noDocumentAll = _ref2.noDocumentAll,
      innerBinding = _ref2.innerBinding;
  if (!privateNamesMap.size) return;
  var body = path.get("body");
  var handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
  (0, _helperMemberExpressionToFunctions["default"])(body, privateNameVisitor, Object.assign({
    privateNamesMap: privateNamesMap,
    classRef: ref,
    file: state
  }, handler, {
    noDocumentAll: noDocumentAll,
    innerBinding: innerBinding
  }));
  body.traverse(privateInVisitor, {
    privateNamesMap: privateNamesMap,
    classRef: ref,
    file: state,
    privateFieldsAsProperties: privateFieldsAsProperties,
    innerBinding: innerBinding
  });
}

function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
  var _privateNamesMap$get6 = privateNamesMap.get(prop.node.key.id.name),
      id = _privateNamesMap$get6.id;

  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return _core.template.statement.ast(_templateObject6(), ref, _core.types.cloneNode(id), value);
}

function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
  var _privateNamesMap$get7 = privateNamesMap.get(prop.node.key.id.name),
      id = _privateNamesMap$get7.id;

  var value = prop.node.value || prop.scope.buildUndefinedNode();
  {
    if (!state.availableHelper("classPrivateFieldInitSpec")) {
      return _core.template.statement.ast(_templateObject7(), _core.types.cloneNode(id), ref, value);
    }
  }
  var helper = state.addHelper("classPrivateFieldInitSpec");
  return _core.template.statement.ast(_templateObject8(), helper, _core.types.thisExpression(), _core.types.cloneNode(id), value);
}

function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
      getId = privateName.getId,
      setId = privateName.setId,
      initAdded = privateName.initAdded;
  var isAccessor = getId || setId;
  if (!prop.isProperty() && (initAdded || !isAccessor)) return;

  if (isAccessor) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return _core.template.statement.ast(_templateObject9(), _core.types.cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
  }

  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return _core.template.statement.ast(_templateObject10(), _core.types.cloneNode(id), value);
}

function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var methodId = privateName.methodId,
      id = privateName.id,
      getId = privateName.getId,
      setId = privateName.setId,
      initAdded = privateName.initAdded;
  if (initAdded) return;

  if (methodId) {
    return _core.template.statement.ast(_templateObject11(), ref, id, methodId.name);
  }

  var isAccessor = getId || setId;

  if (isAccessor) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return _core.template.statement.ast(_templateObject12(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
  }
}

function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var getId = privateName.getId,
      setId = privateName.setId,
      initAdded = privateName.initAdded;
  if (initAdded) return;
  var isAccessor = getId || setId;

  if (isAccessor) {
    return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);
  }

  return buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state);
}

function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
      getId = privateName.getId,
      setId = privateName.setId;
  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
    initAdded: true
  }));
  {
    if (!state.availableHelper("classPrivateFieldInitSpec")) {
      return _core.template.statement.ast(_templateObject13(), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }
  }
  var helper = state.addHelper("classPrivateFieldInitSpec");
  return _core.template.statement.ast(_templateObject14(), helper, _core.types.thisExpression(), _core.types.cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
}

function buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id;
  {
    if (!state.availableHelper("classPrivateMethodInitSpec")) {
      return _core.template.statement.ast(_templateObject15(), id, ref);
    }
  }
  var helper = state.addHelper("classPrivateMethodInitSpec");
  return _core.template.statement.ast(_templateObject16(), helper, _core.types.thisExpression(), _core.types.cloneNode(id));
}

function buildPublicFieldInitLoose(ref, prop) {
  var _prop$node = prop.node,
      key = _prop$node.key,
      computed = _prop$node.computed;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));
}

function buildPublicFieldInitSpec(ref, prop, state) {
  var _prop$node2 = prop.node,
      key = _prop$node2.key,
      computed = _prop$node2.computed;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));
}

function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
      methodId = privateName.methodId,
      getId = privateName.getId,
      setId = privateName.setId,
      initAdded = privateName.initAdded;
  if (initAdded) return;
  var isAccessor = getId || setId;

  if (isAccessor) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return _core.template.statement.ast(_templateObject17(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
  }

  return _core.template.statement.ast(_templateObject18(), ref, id, methodId.name);
}

function buildPrivateMethodDeclaration(prop, privateNamesMap) {
  var privateFieldsAsProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
      methodId = privateName.methodId,
      getId = privateName.getId,
      setId = privateName.setId,
      getterDeclared = privateName.getterDeclared,
      setterDeclared = privateName.setterDeclared,
      isStatic = privateName["static"];
  var _prop$node3 = prop.node,
      params = _prop$node3.params,
      body = _prop$node3.body,
      generator = _prop$node3.generator,
      async = _prop$node3.async;
  var isGetter = getId && !getterDeclared && params.length === 0;
  var isSetter = setId && !setterDeclared && params.length > 0;
  var declId = methodId;

  if (isGetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      getterDeclared: true
    }));
    declId = getId;
  } else if (isSetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      setterDeclared: true
    }));
    declId = setId;
  } else if (isStatic && !privateFieldsAsProperties) {
    declId = id;
  }

  return _core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async);
}

var thisContextVisitor = _core.traverse.visitors.merge([{
  ThisExpression: function ThisExpression(path, state) {
    state.needsClassRef = true;
    path.replaceWith(_core.types.cloneNode(state.classRef));
  },
  MetaProperty: function MetaProperty(path) {
    var meta = path.get("meta");
    var property = path.get("property");
    var scope = path.scope;

    if (meta.isIdentifier({
      name: "new"
    }) && property.isIdentifier({
      name: "target"
    })) {
      path.replaceWith(scope.buildUndefinedNode());
    }
  }
}, _helperReplaceSupers.environmentVisitor]);

var innerReferencesVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
      state.needsClassRef = true;
      path.node.name = state.classRef.name;
    }
  }
};

function replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
  var _state$classRef;

  var state = {
    classRef: ref,
    needsClassRef: false,
    innerBinding: innerBindingRef
  };
  var replacer = new _helperReplaceSupers["default"]({
    methodPath: path,
    constantSuper: constantSuper,
    file: file,
    refToPreserve: ref,
    getSuperRef: getSuperRef,
    getObjectRef: function getObjectRef() {
      state.needsClassRef = true;
      return isStaticBlock || path.node["static"] ? ref : _core.types.memberExpression(ref, _core.types.identifier("prototype"));
    }
  });
  replacer.replace();

  if (isStaticBlock || path.isProperty()) {
    path.traverse(thisContextVisitor, state);
  }

  if ((_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {
    path.traverse(innerReferencesVisitor, state);
  }

  return state.needsClassRef;
}

function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
  var needsClassRef = false;
  var injectSuperRef;
  var staticNodes = [];
  var instanceNodes = [];
  var pureStaticNodes = [];
  var getSuperRef = _core.types.isIdentifier(superRef) ? function () {
    return superRef;
  } : function () {
    var _injectSuperRef;

    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);
    return injectSuperRef;
  };
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = props[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var prop = _step4.value;
      prop.isClassProperty() && ts.assertFieldTransformed(prop);
      var isStatic = prop.node["static"];
      var isInstance = !isStatic;
      var isPrivate = prop.isPrivate();
      var isPublic = !isPrivate;
      var isField = prop.isProperty();
      var isMethod = !isField;
      var isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();

      if (isStatic || isMethod && isPrivate || isStaticBlock) {
        var replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
        needsClassRef = needsClassRef || replaced;
      }

      switch (true) {
        case isStaticBlock:
          staticNodes.push(_core.template.statement.ast(_templateObject19(), _core.types.blockStatement(prop.node.body)));
          break;

        case isStatic && isPrivate && isField && privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
          break;

        case isStatic && isPrivate && isField && !privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          break;

        case isStatic && isPublic && isField && setPublicClassFields:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
          break;

        case isStatic && isPublic && isField && !setPublicClassFields:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));
          break;

        case isInstance && isPrivate && isField && privateFieldsAsProperties:
          instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isField && !privateFieldsAsProperties:
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));
          break;

        case isInstance && isPrivate && isMethod && privateFieldsAsProperties:
          instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isStatic && isPrivate && isMethod && privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isInstance && isPublic && isField && setPublicClassFields:
          instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
          break;

        case isInstance && isPublic && isField && !setPublicClassFields:
          instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));
          break;

        default:
          throw new Error("Unreachable.");
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return {
    staticNodes: staticNodes.filter(Boolean),
    instanceNodes: instanceNodes.filter(Boolean),
    pureStaticNodes: pureStaticNodes.filter(Boolean),
    wrapClass: function wrapClass(path) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = props[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var prop = _step5.value;
          prop.remove();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (injectSuperRef) {
        path.scope.push({
          id: _core.types.cloneNode(injectSuperRef)
        });
        path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass));
      }

      if (!needsClassRef) return path;

      if (path.isClassExpression()) {
        path.scope.push({
          id: ref
        });
        path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node));
      } else if (!path.node.id) {
        path.node.id = ref;
      }

      return path;
    }
  };
}