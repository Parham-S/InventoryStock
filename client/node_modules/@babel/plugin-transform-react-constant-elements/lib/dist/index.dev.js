"use strict";

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          ", " || (", " = ", ")\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

  if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
    throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
  }

  var HOISTED = new WeakMap();

  function declares(node, scope) {
    if (_core.types.isJSXIdentifier(node, {
      name: "this"
    }) || _core.types.isJSXIdentifier(node, {
      name: "arguments"
    }) || _core.types.isJSXIdentifier(node, {
      name: "super"
    }) || _core.types.isJSXIdentifier(node, {
      name: "new"
    })) {
      var path = scope.path;
      return path.isFunctionParent() && !path.isArrowFunctionExpression();
    }

    return scope.hasOwnBinding(node.name);
  }

  function isHoistingScope(_ref) {
    var path = _ref.path;
    return path.isFunctionParent() || path.isLoop() || path.isProgram();
  }

  function getHoistingScope(scope) {
    while (!isHoistingScope(scope)) {
      scope = scope.parent;
    }

    return scope;
  }

  var analyzer = {
    enter: function enter(path, state) {
      var stop = function stop() {
        state.isImmutable = false;
        path.stop();
      };

      if (path.isJSXClosingElement()) {
        path.skip();
        return;
      }

      if (path.isJSXIdentifier({
        name: "ref"
      }) && path.parentPath.isJSXAttribute({
        name: path.node
      })) {
        return stop();
      }

      if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName()) {
        return;
      }

      if (path.isIdentifier()) {
        var binding = path.scope.getBinding(path.node.name);
        if (binding && binding.constant) return;
      }

      if (!path.isImmutable()) {
        if (path.isPure()) {
          var expressionResult = path.evaluate();

          if (expressionResult.confident) {
            var value = expressionResult.value;
            var isMutable = !state.mutablePropsAllowed && value && _typeof(value) === "object" || typeof value === "function";

            if (!isMutable) {
              path.skip();
              return;
            }
          } else if (_core.types.isIdentifier(expressionResult.deopt)) {
            return;
          }
        }

        stop();
      }
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var node = path.node;
      var scope = path.scope;

      while (scope) {
        if (scope === state.targetScope) return;
        if (declares(node, scope)) break;
        scope = scope.parent;
      }

      state.targetScope = getHoistingScope(scope);
    }
  };
  return {
    name: "transform-react-constant-elements",
    visitor: {
      JSXElement: function JSXElement(path) {
        var _jsxScope;

        if (HOISTED.has(path.node)) return;
        HOISTED.set(path.node, path.scope);
        var name = path.node.openingElement.name;
        var mutablePropsAllowed = false;

        if (allowMutablePropsOnTags != null) {
          var lastSegment = name;

          while (_core.types.isJSXMemberExpression(lastSegment)) {
            lastSegment = lastSegment.property;
          }

          var elementName = lastSegment.name;
          mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);
        }

        var state = {
          isImmutable: true,
          mutablePropsAllowed: mutablePropsAllowed,
          targetScope: path.scope.getProgramParent()
        };
        path.traverse(analyzer, state);
        if (!state.isImmutable) return;
        var targetScope = state.targetScope;
        HOISTED.set(path.node, targetScope);
        var jsxScope;
        var current = path;

        while (!jsxScope && current.parentPath.isJSX()) {
          current = current.parentPath;
          jsxScope = HOISTED.get(current.node);
        }

        (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = getHoistingScope(path.scope);
        if (targetScope === jsxScope) return;
        var id = path.scope.generateUidBasedOnNode(name);
        targetScope.push({
          id: _core.types.identifier(id)
        });

        var replacement = _core.template.expression.ast(_templateObject(), _core.types.identifier(id), _core.types.identifier(id), path.node);

        if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute()) {
          replacement = _core.types.jsxExpressionContainer(replacement);
        }

        path.replaceWith(replacement);
      }
    }
  };
});

exports["default"] = _default;