"use strict";

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      ", " ||\n        (", " = ", ")\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = transpileNamespace;

var _core = require("@babel/core");

function transpileNamespace(path, t, allowNamespaces) {
  if (path.node.declare || path.node.id.type === "StringLiteral") {
    path.remove();
    return;
  }

  if (!allowNamespaces) {
    throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
  }

  var name = path.node.id.name;
  var value = handleNested(path, t, t.cloneDeep(path.node));
  var bound = path.scope.hasOwnBinding(name);

  if (path.parent.type === "ExportNamedDeclaration") {
    if (!bound) {
      path.parentPath.insertAfter(value);
      path.replaceWith(getDeclaration(t, name));
      path.scope.registerDeclaration(path.parentPath);
    } else {
      path.parentPath.replaceWith(value);
    }
  } else if (bound) {
    path.replaceWith(value);
  } else {
    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
  }
}

function getDeclaration(t, name) {
  return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
}

function getMemberExpression(t, name, itemName) {
  return t.memberExpression(t.identifier(name), t.identifier(itemName));
}

function handleVariableDeclaration(node, name, hub) {
  if (node.kind !== "const") {
    throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
  }

  var declarations = node.declarations;

  if (declarations.every(function (declarator) {
    return _core.types.isIdentifier(declarator.id);
  })) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var declarator = _step.value;
        declarator.init = _core.types.assignmentExpression("=", getMemberExpression(_core.types, name, declarator.id.name), declarator.init);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return [node];
  }

  var bindingIdentifiers = _core.types.getBindingIdentifiers(node);

  var assignments = [];

  for (var idName in bindingIdentifiers) {
    assignments.push(_core.types.assignmentExpression("=", getMemberExpression(_core.types, name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
  }

  return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];
}

function buildNestedAmbiendModuleError(path, node) {
  throw path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
}

function handleNested(path, t, node, parentExport) {
  var names = new Set();
  var realName = node.id;
  t.assertIdentifier(realName);
  var name = path.scope.generateUid(realName.name);
  var namespaceTopLevel = t.isTSModuleBlock(node.body) ? node.body.body : [t.exportNamedDeclaration(node.body)];

  for (var i = 0; i < namespaceTopLevel.length; i++) {
    var subNode = namespaceTopLevel[i];

    switch (subNode.type) {
      case "TSModuleDeclaration":
        {
          if (!t.isIdentifier(subNode.id)) {
            throw buildNestedAmbiendModuleError(path, subNode);
          }

          var transformed = handleNested(path, t, subNode);
          var moduleName = subNode.id.name;

          if (names.has(moduleName)) {
            namespaceTopLevel[i] = transformed;
          } else {
            names.add(moduleName);
            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
          }

          continue;
        }

      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration":
        names.add(subNode.id.name);
        continue;

      case "VariableDeclaration":
        {
          for (var _name in t.getBindingIdentifiers(subNode)) {
            names.add(_name);
          }

          continue;
        }

      default:
        continue;

      case "ExportNamedDeclaration":
    }

    switch (subNode.declaration.type) {
      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration":
        {
          var itemName = subNode.declaration.id.name;
          names.add(itemName);
          namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
          break;
        }

      case "VariableDeclaration":
        {
          var nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
          namespaceTopLevel.splice.apply(namespaceTopLevel, [i, nodes.length].concat(_toConsumableArray(nodes)));
          i += nodes.length - 1;
          break;
        }

      case "TSModuleDeclaration":
        {
          if (!t.isIdentifier(subNode.declaration.id)) {
            throw buildNestedAmbiendModuleError(path, subNode.declaration);
          }

          var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

          var _moduleName = subNode.declaration.id.name;

          if (names.has(_moduleName)) {
            namespaceTopLevel[i] = _transformed;
          } else {
            names.add(_moduleName);
            namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
          }
        }
    }
  }

  var fallthroughValue = t.objectExpression([]);

  if (parentExport) {
    var memberExpr = t.memberExpression(parentExport, realName);
    fallthroughValue = _core.template.expression.ast(_templateObject(), t.cloneNode(memberExpr), t.cloneNode(memberExpr), fallthroughValue);
  }

  return _core.template.statement.ast(_templateObject2(), t.identifier(name), namespaceTopLevel, realName, t.cloneNode(realName), fallthroughValue);
}