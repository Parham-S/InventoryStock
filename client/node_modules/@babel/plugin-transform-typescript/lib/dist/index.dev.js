"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n              this.", " = ", ""]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _pluginSyntaxTypescript = require("@babel/plugin-syntax-typescript");

var _core = require("@babel/core");

var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");

var _constEnum = require("./const-enum");

var _enum = require("./enum");

var _namespace = require("./namespace");

function isInType(path) {
  switch (path.parent.type) {
    case "TSTypeReference":
    case "TSQualifiedName":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;

    case "ExportSpecifier":
      return path.parentPath.parent.exportKind === "type";

    default:
      return false;
  }
}

var GLOBAL_TYPES = new WeakMap();
var NEEDS_EXPLICIT_ESM = new WeakMap();
var PARSED_PARAMS = new WeakSet();

function isGlobalType(path, name) {
  var program = path.find(function (path) {
    return path.isProgram();
  }).node;
  if (path.scope.hasOwnBinding(name)) return false;
  if (GLOBAL_TYPES.get(program).has(name)) return true;
  console.warn("The exported identifier \"".concat(name, "\" is not declared in Babel's scope tracker\n") + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + "\"".concat(name, "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
  return false;
}

function registerGlobalType(programScope, name) {
  GLOBAL_TYPES.get(programScope.path.node).add(name);
}

var _default = (0, _helperPluginUtils.declare)(function (api, opts) {
  api.assertVersion(7);
  var JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
  var _opts$allowNamespaces = opts.allowNamespaces,
      allowNamespaces = _opts$allowNamespaces === void 0 ? true : _opts$allowNamespaces,
      _opts$jsxPragma = opts.jsxPragma,
      jsxPragma = _opts$jsxPragma === void 0 ? "React.createElement" : _opts$jsxPragma,
      _opts$jsxPragmaFrag = opts.jsxPragmaFrag,
      jsxPragmaFrag = _opts$jsxPragmaFrag === void 0 ? "React.Fragment" : _opts$jsxPragmaFrag,
      _opts$onlyRemoveTypeI = opts.onlyRemoveTypeImports,
      onlyRemoveTypeImports = _opts$onlyRemoveTypeI === void 0 ? false : _opts$onlyRemoveTypeI,
      _opts$optimizeConstEn = opts.optimizeConstEnums,
      optimizeConstEnums = _opts$optimizeConstEn === void 0 ? false : _opts$optimizeConstEn;
  {
    var _opts$allowDeclareFie = opts.allowDeclareFields,
        allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
  }
  var classMemberVisitors = {
    field: function field(path) {
      var node = path.node;
      {
        if (!allowDeclareFields && node.declare) {
          throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
        }
      }

      if (node.declare) {
        if (node.value) {
          throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
        }

        if (!node.decorators) {
          path.remove();
        }
      } else if (node.definite) {
        if (node.value) {
          throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
        }

        {
          if (!allowDeclareFields && !node.decorators) {
            path.remove();
          }
        }
      } else {
        if (!allowDeclareFields && !node.value && !node.decorators && !_core.types.isClassPrivateProperty(node)) {
          path.remove();
        }
      }

      if (node.accessibility) node.accessibility = null;
      if (node["abstract"]) node["abstract"] = null;
      if (node.readonly) node.readonly = null;
      if (node.optional) node.optional = null;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (node.definite) node.definite = null;
      if (node.declare) node.declare = null;
      if (node.override) node.override = null;
    },
    method: function method(_ref) {
      var node = _ref.node;
      if (node.accessibility) node.accessibility = null;
      if (node["abstract"]) node["abstract"] = null;
      if (node.optional) node.optional = null;
      if (node.override) node.override = null;
    },
    constructor: function constructor(path, classPath) {
      if (path.node.accessibility) path.node.accessibility = null;
      var parameterProperties = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = path.node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var param = _step.value;

          if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
            PARSED_PARAMS.add(param.parameter);
            parameterProperties.push(param.parameter);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (parameterProperties.length) {
        var assigns = parameterProperties.map(function (p) {
          var id;

          if (_core.types.isIdentifier(p)) {
            id = p;
          } else if (_core.types.isAssignmentPattern(p) && _core.types.isIdentifier(p.left)) {
            id = p.left;
          } else {
            throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
          }

          return _core.template.statement.ast(_templateObject(), _core.types.cloneNode(id), _core.types.cloneNode(id));
        });
        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);
      }
    }
  };
  return {
    name: "transform-typescript",
    inherits: _pluginSyntaxTypescript["default"],
    visitor: {
      Pattern: visitPattern,
      Identifier: visitPattern,
      RestElement: visitPattern,
      Program: {
        enter: function enter(path, state) {
          var file = state.file;
          var fileJsxPragma = null;
          var fileJsxPragmaFrag = null;

          if (!GLOBAL_TYPES.has(path.node)) {
            GLOBAL_TYPES.set(path.node, new Set());
          }

          if (file.ast.comments) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = file.ast.comments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var comment = _step2.value;
                var jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);

                if (jsxMatches) {
                  if (jsxMatches[1]) {
                    fileJsxPragmaFrag = jsxMatches[2];
                  } else {
                    fileJsxPragma = jsxMatches[2];
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }

          var pragmaImportName = fileJsxPragma || jsxPragma;

          if (pragmaImportName) {
            var _pragmaImportName$spl = pragmaImportName.split(".");

            var _pragmaImportName$spl2 = _slicedToArray(_pragmaImportName$spl, 1);

            pragmaImportName = _pragmaImportName$spl2[0];
          }

          var pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;

          if (pragmaFragImportName) {
            var _pragmaFragImportName = pragmaFragImportName.split(".");

            var _pragmaFragImportName2 = _slicedToArray(_pragmaFragImportName, 1);

            pragmaFragImportName = _pragmaFragImportName2[0];
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = path.get("body")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var stmt = _step3.value;

              if (stmt.isImportDeclaration()) {
                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                  NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                }

                if (stmt.node.importKind === "type") {
                  stmt.remove();
                  continue;
                }

                if (onlyRemoveTypeImports) {
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                } else {
                  if (stmt.node.specifiers.length === 0) {
                    NEEDS_EXPLICIT_ESM.set(path.node, false);
                    continue;
                  }

                  var allElided = true;
                  var importsToRemove = [];
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = stmt.node.specifiers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var specifier = _step4.value;
                      var binding = stmt.scope.getBinding(specifier.local.name);

                      if (binding && isImportTypeOnly({
                        binding: binding,
                        programPath: path,
                        pragmaImportName: pragmaImportName,
                        pragmaFragImportName: pragmaFragImportName
                      })) {
                        importsToRemove.push(binding.path);
                      } else {
                        allElided = false;
                        NEEDS_EXPLICIT_ESM.set(path.node, false);
                      }
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }

                  if (allElided) {
                    stmt.remove();
                  } else {
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = undefined;

                    try {
                      for (var _iterator5 = importsToRemove[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var importPath = _step5.value;
                        importPath.remove();
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                          _iterator5["return"]();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                  }
                }

                continue;
              }

              if (stmt.isExportDeclaration()) {
                stmt = stmt.get("declaration");
              }

              if (stmt.isVariableDeclaration({
                declare: true
              })) {
                for (var _i2 = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                  var name = _Object$keys[_i2];
                  registerGlobalType(path.scope, name);
                }
              } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                declare: true
              }) || stmt.isTSEnumDeclaration({
                declare: true
              }) || stmt.isTSModuleDeclaration({
                declare: true
              }) && stmt.get("id").isIdentifier()) {
                registerGlobalType(path.scope, stmt.node.id.name);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        },
        exit: function exit(path) {
          if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
            path.pushContainer("body", _core.types.exportNamedDeclaration());
          }
        }
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        }

        if (path.node.exportKind === "type") {
          path.remove();
          return;
        }

        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (_ref2) {
          var local = _ref2.local;
          return isGlobalType(path, local.name);
        })) {
          path.remove();
          return;
        }

        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      },
      ExportSpecifier: function ExportSpecifier(path) {
        if (!path.parent.source && isGlobalType(path, path.node.local.name)) {
          path.remove();
        }
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        }

        if (_core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
          path.remove();
          return;
        }

        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      },
      TSDeclareFunction: function TSDeclareFunction(path) {
        path.remove();
      },
      TSDeclareMethod: function TSDeclareMethod(path) {
        path.remove();
      },
      VariableDeclaration: function VariableDeclaration(path) {
        if (path.node.declare) {
          path.remove();
        }
      },
      VariableDeclarator: function VariableDeclarator(_ref3) {
        var node = _ref3.node;
        if (node.definite) node.definite = null;
      },
      TSIndexSignature: function TSIndexSignature(path) {
        path.remove();
      },
      ClassDeclaration: function ClassDeclaration(path) {
        var node = path.node;

        if (node.declare) {
          path.remove();
          return;
        }
      },
      Class: function Class(path) {
        var node = path.node;
        if (node.typeParameters) node.typeParameters = null;
        if (node.superTypeParameters) node.superTypeParameters = null;
        if (node["implements"]) node["implements"] = null;
        if (node["abstract"]) node["abstract"] = null;
        path.get("body.body").forEach(function (child) {
          if (child.isClassMethod() || child.isClassPrivateMethod()) {
            if (child.node.kind === "constructor") {
              classMemberVisitors.constructor(child, path);
            } else {
              classMemberVisitors.method(child);
            }
          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
            classMemberVisitors.field(child);
          }
        });
      },
      Function: function Function(path) {
        var node = path.node,
            scope = path.scope;
        if (node.typeParameters) node.typeParameters = null;
        if (node.returnType) node.returnType = null;
        var params = node.params;

        if (params.length > 0 && _core.types.isIdentifier(params[0], {
          name: "this"
        })) {
          params.shift();
        }

        var paramsPath = path.get("params");
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = paramsPath[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var p = _step6.value;

            if (p.type === "TSParameterProperty") {
              p.replaceWith(p.get("parameter"));
              scope.registerBinding("param", p);
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      },
      TSModuleDeclaration: function TSModuleDeclaration(path) {
        (0, _namespace["default"])(path, _core.types, allowNamespaces);
      },
      TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
        path.remove();
      },
      TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
        path.remove();
      },
      TSEnumDeclaration: function TSEnumDeclaration(path) {
        if (optimizeConstEnums && path.node["const"]) {
          (0, _constEnum["default"])(path, _core.types);
        } else {
          (0, _enum["default"])(path, _core.types);
        }
      },
      TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
        if (_core.types.isTSExternalModuleReference(path.node.moduleReference)) {
          throw path.buildCodeFrameError("`import ".concat(path.node.id.name, " = require('").concat(path.node.moduleReference.expression.value, "')` ") + "is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + "`import ".concat(path.node.id.name, " from '").concat(path.node.moduleReference.expression.value, "';` alongside ") + "Typescript's --allowSyntheticDefaultImports option.");
        }

        path.replaceWith(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(path.node.id, entityNameToExpr(path.node.moduleReference))]));
      },
      TSExportAssignment: function TSExportAssignment(path) {
        throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
      },
      TSTypeAssertion: function TSTypeAssertion(path) {
        path.replaceWith(path.node.expression);
      },
      TSAsExpression: function TSAsExpression(path) {
        var node = path.node;

        do {
          node = node.expression;
        } while (_core.types.isTSAsExpression(node));

        path.replaceWith(node);
      },
      TSNonNullExpression: function TSNonNullExpression(path) {
        path.replaceWith(path.node.expression);
      },
      CallExpression: function CallExpression(path) {
        path.node.typeParameters = null;
      },
      OptionalCallExpression: function OptionalCallExpression(path) {
        path.node.typeParameters = null;
      },
      NewExpression: function NewExpression(path) {
        path.node.typeParameters = null;
      },
      JSXOpeningElement: function JSXOpeningElement(path) {
        path.node.typeParameters = null;
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(path) {
        path.node.typeParameters = null;
      }
    }
  };

  function entityNameToExpr(node) {
    if (_core.types.isTSQualifiedName(node)) {
      return _core.types.memberExpression(entityNameToExpr(node.left), node.right);
    }

    return node;
  }

  function visitPattern(_ref4) {
    var node = _ref4.node;
    if (node.typeAnnotation) node.typeAnnotation = null;
    if (_core.types.isIdentifier(node) && node.optional) node.optional = null;
  }

  function isImportTypeOnly(_ref5) {
    var binding = _ref5.binding,
        programPath = _ref5.programPath,
        pragmaImportName = _ref5.pragmaImportName,
        pragmaFragImportName = _ref5.pragmaFragImportName;
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = binding.referencePaths[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var path = _step7.value;

        if (!isInType(path)) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
          _iterator7["return"]();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }

    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
      return true;
    }

    var sourceFileHasJsx = false;
    programPath.traverse({
      "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
        sourceFileHasJsx = true;
        path.stop();
      }
    });
    return !sourceFileHasJsx;
  }
});

exports["default"] = _default;