"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NodePath", {
  enumerable: true,
  get: function get() {
    return _path["default"];
  }
});
Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function get() {
    return _scope["default"];
  }
});
Object.defineProperty(exports, "Hub", {
  enumerable: true,
  get: function get() {
    return _hub["default"];
  }
});
exports.visitors = exports["default"] = void 0;

var _context = require("./context");

var visitors = require("./visitors");

exports.visitors = visitors;

var _t = require("@babel/types");

var cache = require("./cache");

var _path = require("./path");

var _scope = require("./scope");

var _hub = require("./hub");

var VISITOR_KEYS = _t.VISITOR_KEYS,
    removeProperties = _t.removeProperties,
    traverseFast = _t.traverseFast;

function traverse(parent) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var scope = arguments.length > 2 ? arguments[2] : undefined;
  var state = arguments.length > 3 ? arguments[3] : undefined;
  var parentPath = arguments.length > 4 ? arguments[4] : undefined;
  if (!parent) return;

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + "Instead of that you tried to traverse a ".concat(parent.type, " node without ") + "passing scope and parentPath.");
    }
  }

  if (!VISITOR_KEYS[parent.type]) {
    return;
  }

  visitors.explode(opts);
  traverse.node(parent, opts, scope, state, parentPath);
}

var _default = traverse;
exports["default"] = _default;
traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.cheap = function (node, enter) {
  return traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  var keys = VISITOR_KEYS[node.type];
  if (!keys) return;
  var context = new _context["default"](scope, opts, state, parentPath);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

traverse.clearNode = function (node, opts) {
  removeProperties(node, opts);
  cache.path["delete"](node);
};

traverse.removeProperties = function (tree, opts) {
  traverseFast(tree, traverse.clearNode, opts);
  return tree;
};

function hasDenylistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, type, denylistTypes) {
  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
  if (tree.type === type) return true;
  var state = {
    has: false,
    type: type
  };
  traverse(tree, {
    noScope: true,
    denylist: denylistTypes,
    enter: hasDenylistedType
  }, null, state);
  return state.has;
};

traverse.cache = cache;