"use strict";

var _environmentVisitor;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipAllButComputedKey = skipAllButComputedKey;
exports["default"] = exports.environmentVisitor = void 0;

var _traverse = require("@babel/traverse");

var _helperMemberExpressionToFunctions = require("@babel/helper-member-expression-to-functions");

var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");

var _t = require("@babel/types");

var VISITOR_KEYS = _t.VISITOR_KEYS,
    assignmentExpression = _t.assignmentExpression,
    booleanLiteral = _t.booleanLiteral,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    identifier = _t.identifier,
    memberExpression = _t.memberExpression,
    sequenceExpression = _t.sequenceExpression,
    staticBlock = _t.staticBlock,
    stringLiteral = _t.stringLiteral,
    thisExpression = _t.thisExpression;

function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
  objectRef = cloneNode(objectRef);
  var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
  return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}

function skipAllButComputedKey(path) {
  if (!path.node.computed) {
    path.skip();
    return;
  }

  var keys = VISITOR_KEYS[path.type];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var environmentVisitor = (_environmentVisitor = {}, _defineProperty(_environmentVisitor, "".concat(staticBlock ? "StaticBlock|" : "", "ClassPrivateProperty|TypeAnnotation"), function ClassPrivatePropertyTypeAnnotation(path) {
  path.skip();
}), _defineProperty(_environmentVisitor, "Function", function Function(path) {
  if (path.isMethod()) return;
  if (path.isArrowFunctionExpression()) return;
  path.skip();
}), _defineProperty(_environmentVisitor, "Method|ClassProperty", function MethodClassProperty(path) {
  skipAllButComputedKey(path);
}), _environmentVisitor);
exports.environmentVisitor = environmentVisitor;

var visitor = _traverse["default"].visitors.merge([environmentVisitor, {
  Super: function Super(path, state) {
    var node = path.node,
        parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      object: node
    })) return;
    state.handle(parentPath);
  }
}]);

var unshadowSuperBindingVisitor = _traverse["default"].visitors.merge([environmentVisitor, {
  Scopable: function Scopable(path, _ref) {
    var refName = _ref.refName;
    var binding = path.scope.getOwnBinding(refName);

    if (binding && binding.identifier.name === refName) {
      path.scope.rename(refName);
    }
  }
}]);

var specHandlers = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
        node = superMember.node;
    var computed = node.computed,
        property = node.property;

    if (!computed) {
      return;
    }

    var memo = scope.maybeGenerateMemoised(property);

    if (!memo) {
      return;
    }

    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node = superMember.node,
        computed = _superMember$node.computed,
        property = _superMember$node.property;

    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }

    if (computed) {
      return cloneNode(property);
    }

    return stringLiteral(property.name);
  },
  get: function get(superMember) {
    return this._get(superMember, this._getThisRefs());
  },
  _get: function _get(superMember, thisRefs) {
    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
  },
  _getThisRefs: function _getThisRefs() {
    if (!this.isDerivedConstructor) {
      return {
        "this": thisExpression()
      };
    }

    var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return {
      memo: assignmentExpression("=", thisRef, thisExpression()),
      "this": cloneNode(thisRef)
    };
  },
  set: function set(superMember, value) {
    var thisRefs = this._getThisRefs();

    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], booleanLiteral(superMember.isInStrictMode())]);
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    var thisRefs = this._getThisRefs();

    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    var thisRefs = this._getThisRefs();

    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, true);
  }
};
var looseHandlers = Object.assign({}, specHandlers, {
  prop: function prop(superMember) {
    var property = superMember.node.property;

    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }

    return cloneNode(property);
  },
  get: function get(superMember) {
    var isStatic = this.isStatic,
        getSuperRef = this.getSuperRef;
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    var object;

    if (isStatic) {
      var _getSuperRef;

      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
    } else {
      var _getSuperRef2;

      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
    }

    return memberExpression(object, prop, computed);
  },
  set: function set(superMember, value) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
  },
  destructureSet: function destructureSet(superMember) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return memberExpression(thisExpression(), prop, computed);
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, true);
  }
});

var ReplaceSupers =
/*#__PURE__*/
function () {
  function ReplaceSupers(opts) {
    _classCallCheck(this, ReplaceSupers);

    var _opts$constantSuper;

    var path = opts.methodPath;
    this.methodPath = path;
    this.isDerivedConstructor = path.isClassMethod({
      kind: "constructor"
    }) && !!opts.superRef;
    this.isStatic = path.isObjectMethod() || path.node["static"] || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
    this.opts = opts;
  }

  _createClass(ReplaceSupers, [{
    key: "getObjectRef",
    value: function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
  }, {
    key: "getSuperRef",
    value: function getSuperRef() {
      if (this.opts.superRef) return cloneNode(this.opts.superRef);
      if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());
    }
  }, {
    key: "replace",
    value: function replace() {
      if (this.opts.refToPreserve) {
        this.methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }

      var handler = this.constantSuper ? looseHandlers : specHandlers;
      (0, _helperMemberExpressionToFunctions["default"])(this.methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: handler.get
      }, handler));
    }
  }]);

  return ReplaceSupers;
}();

exports["default"] = ReplaceSupers;