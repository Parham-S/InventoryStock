"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperRemapAsyncToGenerator = require("@babel/helper-remap-async-to-generator");

var _pluginSyntaxAsyncGenerators = require("@babel/plugin-syntax-async-generators");

var _core = require("@babel/core");

var _forAwait = require("./for-await");

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  var yieldStarVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    YieldExpression: function YieldExpression(_ref, state) {
      var node = _ref.node;
      if (!node.delegate) return;
      var callee = state.addHelper("asyncGeneratorDelegate");
      node.argument = _core.types.callExpression(callee, [_core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
    }
  };
  var forAwaitVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    ForOfStatement: function ForOfStatement(path, _ref2) {
      var _block$body;

      var file = _ref2.file;
      var node = path.node;
      if (!node["await"]) return;
      var build = (0, _forAwait["default"])(path, {
        getAsyncIterator: file.addHelper("asyncIterator")
      });
      var declar = build.declar,
          loop = build.loop;
      var block = loop.body;
      path.ensureBlock();

      if (declar) {
        block.body.push(declar);
      }

      (_block$body = block.body).push.apply(_block$body, _toConsumableArray(node.body.body));

      _core.types.inherits(loop, node);

      _core.types.inherits(loop.body, node.body);

      if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
      } else {
        path.replaceWithMultiple(build.node);
      }
    }
  };
  var visitor = {
    Function: function Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
      (0, _helperRemapAsyncToGenerator["default"])(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator")
      });
    }
  };
  return {
    name: "proposal-async-generator-functions",
    inherits: _pluginSyntaxAsyncGenerators["default"],
    visitor: {
      Program: function Program(path, state) {
        path.traverse(visitor, state);
      }
    }
  };
});

exports["default"] = _default;