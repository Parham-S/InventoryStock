"use strict";

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _noHelperImplementation = require("./no-helper-implementation");

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  var _options$assumeArray, _options$allowArrayLi, _api$assumption;

  api.assertVersion(7);
  {
    var assumeArray = options.assumeArray,
        allowArrayLike = options.allowArrayLike,
        loose = options.loose;

    if (loose === true && assumeArray === true) {
      throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
    }

    if (assumeArray === true && allowArrayLike === true) {
      throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
    }

    if (allowArrayLike && /^7\.\d\./.test(api.version)) {
      throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
    }
  }
  var iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
  var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
  var skipteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;

  if (iterableIsArray && arrayLikeIsIterable) {
    throw new Error("The \"iterableIsArray\" and \"arrayLikeIsIterable\" assumptions are not compatible.");
  }

  if (iterableIsArray) {
    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement: function ForOfStatement(path) {
          var scope = path.scope;
          var _path$node = path.node,
              left = _path$node.left,
              right = _path$node.right,
              isAwait = _path$node["await"];

          if (isAwait) {
            return;
          }

          var i = scope.generateUidIdentifier("i");
          var array = scope.maybeGenerateMemoised(right, true);
          var inits = [_core.types.variableDeclarator(i, _core.types.numericLiteral(0))];

          if (array) {
            inits.push(_core.types.variableDeclarator(array, right));
          } else {
            array = right;
          }

          var item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), true);

          var assignment;

          if (_core.types.isVariableDeclaration(left)) {
            assignment = left;
            assignment.declarations[0].init = item;
          } else {
            assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
          }

          var blockBody;
          var body = path.get("body");

          if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
            return body.scope.hasOwnBinding(id);
          })) {
            blockBody = _core.types.blockStatement([assignment, body.node]);
          } else {
            blockBody = _core.types.toBlock(body.node);
            blockBody.body.unshift(assignment);
          }

          path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), blockBody));
        }
      }
    };
  }

  var buildForOfArray = (0, _core.template)(_templateObject());

  var buildForOfNoIteratorClosing = _core.template.statements(_templateObject2());

  var buildForOf = _core.template.statements(_templateObject3());

  var builder = skipteratorClosing ? {
    build: buildForOfNoIteratorClosing,
    helper: "createForOfIteratorHelperLoose",
    getContainer: function getContainer(nodes) {
      return nodes;
    }
  } : {
    build: buildForOf,
    helper: "createForOfIteratorHelper",
    getContainer: function getContainer(nodes) {
      return nodes[1].block.body;
    }
  };

  function _ForOfStatementArray(path) {
    var node = path.node,
        scope = path.scope;
    var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
    var iterationKey = scope.generateUidIdentifier("i");
    var loop = buildForOfArray({
      BODY: node.body,
      KEY: iterationKey,
      NAME: right,
      ARR: node.right
    });

    _core.types.inherits(loop, node);

    _core.types.ensureBlock(loop);

    var iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), true);

    var left = node.left;

    if (_core.types.isVariableDeclaration(left)) {
      left.declarations[0].init = iterationValue;
      loop.body.body.unshift(left);
    } else {
      loop.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue)));
    }

    return loop;
  }

  return {
    name: "transform-for-of",
    visitor: {
      ForOfStatement: function ForOfStatement(path, state) {
        var right = path.get("right");

        if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) {
          path.replaceWith(_ForOfStatementArray(path));
          return;
        }

        if (!state.availableHelper(builder.helper)) {
          (0, _noHelperImplementation["default"])(skipteratorClosing, path, state);
          return;
        }

        var node = path.node,
            parent = path.parent,
            scope = path.scope;
        var left = node.left;
        var declar;
        var stepKey = scope.generateUid("step");

        var stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));

        if (_core.types.isVariableDeclaration(left)) {
          declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
        } else {
          declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
        }

        path.ensureBlock();
        node.body.body.unshift(declar);
        var nodes = builder.build({
          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
          ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? _core.types.booleanLiteral(true) : null,
          STEP_KEY: _core.types.identifier(stepKey),
          OBJECT: node.right,
          BODY: node.body
        });
        var container = builder.getContainer(nodes);

        _core.types.inherits(container[0], node);

        _core.types.inherits(container[0].body, node.body);

        if (_core.types.isLabeledStatement(parent)) {
          container[0] = _core.types.labeledStatement(parent.label, container[0]);
          path.parentPath.replaceWithMultiple(nodes);
          path.skip();
        } else {
          path.replaceWithMultiple(nodes);
        }
      }
    }
  };
});

exports["default"] = _default;