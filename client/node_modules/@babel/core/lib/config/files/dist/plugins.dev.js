"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(loadPlugin),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(loadPreset),
    _marked3 =
/*#__PURE__*/
regeneratorRuntime.mark(requireModule);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePlugin = resolvePlugin;
exports.resolvePreset = resolvePreset;
exports.loadPlugin = loadPlugin;
exports.loadPreset = loadPreset;

function _debug() {
  var data = require("debug");

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _path() {
  var data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

var _moduleTypes = require("./module-types");

function _module() {
  var data = require("module");

  _module = function _module() {
    return data;
  };

  return data;
}

var debug = _debug()("babel:config:loading:files:plugins");

var EXACT_RE = /^module:/;
var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;

function resolvePlugin(name, dirname) {
  return resolveStandardizedName("plugin", name, dirname);
}

function resolvePreset(name, dirname) {
  return resolveStandardizedName("preset", name, dirname);
}

function loadPlugin(name, dirname) {
  var filepath, value;
  return regeneratorRuntime.wrap(function loadPlugin$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          filepath = resolvePlugin(name, dirname);

          if (filepath) {
            _context.next = 3;
            break;
          }

          throw new Error("Plugin ".concat(name, " not found relative to ").concat(dirname));

        case 3:
          return _context.delegateYield(requireModule("plugin", filepath), "t0", 4);

        case 4:
          value = _context.t0;
          debug("Loaded plugin %o from %o.", name, dirname);
          return _context.abrupt("return", {
            filepath: filepath,
            value: value
          });

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function loadPreset(name, dirname) {
  var filepath, value;
  return regeneratorRuntime.wrap(function loadPreset$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          filepath = resolvePreset(name, dirname);

          if (filepath) {
            _context2.next = 3;
            break;
          }

          throw new Error("Preset ".concat(name, " not found relative to ").concat(dirname));

        case 3:
          return _context2.delegateYield(requireModule("preset", filepath), "t0", 4);

        case 4:
          value = _context2.t0;
          debug("Loaded preset %o from %o.", name, dirname);
          return _context2.abrupt("return", {
            filepath: filepath,
            value: value
          });

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}

function standardizeName(type, name) {
  if (_path().isAbsolute(name)) return name;
  var isPreset = type === "preset";
  return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, "babel-".concat(type, "-")).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, "$1".concat(type, "-")).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, "$1babel-".concat(type, "-")).replace(OTHER_ORG_DEFAULT_RE, "$1/babel-".concat(type)).replace(EXACT_RE, "");
}

function resolveStandardizedName(type, name) {
  var dirname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();
  var standardizedName = standardizeName(type, name);

  try {
    return (function (v, w) {
      return v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1];
    }(process.versions.node, "8.9") ? require.resolve : function (r, _ref) {
      var _ref$paths = _slicedToArray(_ref.paths, 1),
          b = _ref$paths[0];

      var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

      var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

      if (f) return f;
      f = new Error("Cannot resolve module '".concat(r, "'"));
      f.code = "MODULE_NOT_FOUND";
      throw f;
    })(standardizedName, {
      paths: [dirname]
    });
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") throw e;

    if (standardizedName !== name) {
      var resolvedOriginal = false;

      try {
        ((function (v, w) {
          return v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1];
        })(process.versions.node, "8.9") ? require.resolve : function (r, _ref2) {
          var _ref2$paths = _slicedToArray(_ref2.paths, 1),
              b = _ref2$paths[0];

          var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

          var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

          if (f) return f;
          f = new Error("Cannot resolve module '".concat(r, "'"));
          f.code = "MODULE_NOT_FOUND";
          throw f;
        })(name, {
          paths: [dirname]
        });
        resolvedOriginal = true;
      } catch (_unused) {}

      if (resolvedOriginal) {
        e.message += "\n- If you want to resolve \"".concat(name, "\", use \"module:").concat(name, "\"");
      }
    }

    var resolvedBabel = false;

    try {
      ((function (v, w) {
        return v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1];
      })(process.versions.node, "8.9") ? require.resolve : function (r, _ref3) {
        var _ref3$paths = _slicedToArray(_ref3.paths, 1),
            b = _ref3$paths[0];

        var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '".concat(r, "'"));
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(standardizeName(type, "@babel/" + name), {
        paths: [dirname]
      });
      resolvedBabel = true;
    } catch (_unused2) {}

    if (resolvedBabel) {
      e.message += "\n- Did you mean \"@babel/".concat(name, "\"?");
    }

    var resolvedOppositeType = false;
    var oppositeType = type === "preset" ? "plugin" : "preset";

    try {
      ((function (v, w) {
        return v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1];
      })(process.versions.node, "8.9") ? require.resolve : function (r, _ref4) {
        var _ref4$paths = _slicedToArray(_ref4.paths, 1),
            b = _ref4$paths[0];

        var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '".concat(r, "'"));
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(standardizeName(oppositeType, name), {
        paths: [dirname]
      });
      resolvedOppositeType = true;
    } catch (_unused3) {}

    if (resolvedOppositeType) {
      e.message += "\n- Did you accidentally pass a ".concat(oppositeType, " as a ").concat(type, "?");
    }

    throw e;
  }
}

var LOADING_MODULES = new Set();

function requireModule(type, name) {
  return regeneratorRuntime.wrap(function requireModule$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (!LOADING_MODULES.has(name)) {
            _context3.next = 2;
            break;
          }

          throw new Error("Reentrant ".concat(type, " detected trying to load \"").concat(name, "\". This module is not ignored ") + "and is trying to load itself while compiling itself, leading to a dependency cycle. " + 'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.');

        case 2:
          _context3.prev = 2;
          LOADING_MODULES.add(name);
          return _context3.delegateYield((0, _moduleTypes["default"])(name, "You appear to be using a native ECMAScript module ".concat(type, ", ") + "which is only supported when running Babel asynchronously.", true), "t0", 5);

        case 5:
          return _context3.abrupt("return", _context3.t0);

        case 8:
          _context3.prev = 8;
          _context3.t1 = _context3["catch"](2);
          _context3.t1.message = "[BABEL]: ".concat(_context3.t1.message, " (While processing: ").concat(name, ")");
          throw _context3.t1;

        case 12:
          _context3.prev = 12;
          LOADING_MODULES["delete"](name);
          return _context3.finish(12);

        case 15:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, null, [[2, 8, 12, 15]]);
}