"use strict";

exports.__esModule = true;
exports.validateIncludeExclude = validateIncludeExclude;
exports.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;

var _utils = require("./utils");

function patternToRegExp(pattern) {
  if (pattern instanceof RegExp) return pattern;

  try {
    return new RegExp("^".concat(pattern, "$"));
  } catch (_unused) {
    return null;
  }
}

function buildUnusedError(label, unused) {
  if (!unused.length) return "";
  return "  - The following \"".concat(label, "\" patterns didn't match any polyfill:\n") + unused.map(function (original) {
    return "    ".concat(String(original), "\n");
  }).join("");
}

function buldDuplicatesError(duplicates) {
  if (!duplicates.size) return "";
  return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
    return "    ".concat(name, "\n");
  }).join("");
}

function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
  var current;

  var filter = function filter(pattern) {
    var regexp = patternToRegExp(pattern);
    if (!regexp) return false;
    var matched = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = polyfills[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var polyfill = _step.value;

        if (regexp.test(polyfill)) {
          matched = true;
          current.add(polyfill);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return !matched;
  }; // prettier-ignore


  var include = current = new Set();
  var unusedInclude = Array.from(includePatterns).filter(filter); // prettier-ignore

  var exclude = current = new Set();
  var unusedExclude = Array.from(excludePatterns).filter(filter);
  var duplicates = (0, _utils.intersection)(include, exclude);

  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
    throw new Error("Error while validating the \"".concat(provider, "\" provider options:\n") + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
  }

  return {
    include: include,
    exclude: exclude
  };
}

function applyMissingDependenciesDefaults(options, babelApi) {
  var _options$missingDepen = options.missingDependencies,
      missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
  if (missingDependencies === false) return false;
  var caller = babelApi.caller(function (caller) {
    return caller == null ? void 0 : caller.name;
  });
  var _missingDependencies$ = missingDependencies.log,
      log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
      _missingDependencies$2 = missingDependencies.inject,
      inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
      _missingDependencies$3 = missingDependencies.all,
      all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
  return {
    log: log,
    inject: inject,
    all: all
  };
}