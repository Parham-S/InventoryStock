"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports["default"] = definePolyfillProvider;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperCompilationTargets = _interopRequireWildcard(require("@babel/helper-compilation-targets"));

var _utils = require("./utils");

var _importsCache = _interopRequireDefault(require("./imports-cache"));

var _debugUtils = require("./debug-utils");

var _normalizeOptions = require("./normalize-options");

var v = _interopRequireWildcard(require("./visitors"));

var deps = _interopRequireWildcard(require("./node/dependencies"));

var _metaResolver = _interopRequireDefault(require("./meta-resolver"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var getTargets = _helperCompilationTargets["default"]["default"] || _helperCompilationTargets["default"];

function resolveOptions(options, babelApi) {
  var method = options.method,
      targetsOption = options.targets,
      ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
      configPath = options.configPath,
      debug = options.debug,
      shouldInjectPolyfill = options.shouldInjectPolyfill,
      absoluteImports = options.absoluteImports,
      providerOptions = _objectWithoutPropertiesLoose(options, ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"]);

  var methodName;
  if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
    throw new Error(".method must be a string");
  } else {
    throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + " or \"usage-pure\" (received ".concat(JSON.stringify(method), ")"));
  }

  if (typeof shouldInjectPolyfill === "function") {
    if (options.include || options.exclude) {
      throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
    }
  } else if (shouldInjectPolyfill != null) {
    throw new Error(".shouldInjectPolyfill must be a function, or undefined" + " (received ".concat(JSON.stringify(shouldInjectPolyfill), ")"));
  }

  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
    throw new Error(".absoluteImports must be a boolean, a string, or undefined" + " (received ".concat(JSON.stringify(absoluteImports), ")"));
  }

  var targets;

  if ( // If any browserslist-related option is specified, fallback to the old
  // behavior of not using the targets specified in the top-level options.
  targetsOption || configPath || ignoreBrowserslistConfig) {
    var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
      browsers: targetsOption
    } : targetsOption;
    targets = getTargets(targetsObj, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath
    });
  } else {
    targets = babelApi.targets();
  }

  return {
    method: method,
    methodName: methodName,
    targets: targets,
    absoluteImports: absoluteImports != null ? absoluteImports : false,
    shouldInjectPolyfill: shouldInjectPolyfill,
    debug: !!debug,
    providerOptions: providerOptions
  };
}

function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
  var _resolveOptions = resolveOptions(options, babelApi),
      method = _resolveOptions.method,
      methodName = _resolveOptions.methodName,
      targets = _resolveOptions.targets,
      _debug = _resolveOptions.debug,
      _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
      providerOptions = _resolveOptions.providerOptions,
      absoluteImports = _resolveOptions.absoluteImports;

  var getUtils = (0, _utils.createUtilsGetter)(new _importsCache["default"](function (moduleName) {
    return deps.resolve(dirname, moduleName, absoluteImports);
  })); // eslint-disable-next-line prefer-const

  var include, exclude;
  var polyfillsSupport;
  var polyfillsNames;
  var filterPolyfills;
  var depsCache = new Map();
  var api = {
    babel: babelApi,
    getUtils: getUtils,
    method: options.method,
    targets: targets,
    createMetaResolver: _metaResolver["default"],
    shouldInjectPolyfill: function shouldInjectPolyfill(name) {
      if (polyfillsNames === undefined) {
        throw new Error("Internal error in the ".concat(factory.name, " provider: ") + "shouldInjectPolyfill() can't be called during initialization.");
      }

      if (!polyfillsNames.has(name)) {
        console.warn("Internal error in the ".concat(provider.name, " provider: ") + "unknown polyfill \"".concat(name, "\"."));
      }

      if (filterPolyfills && !filterPolyfills(name)) return false;
      var shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
        compatData: polyfillsSupport,
        includes: include,
        excludes: exclude
      });

      if (_shouldInjectPolyfill) {
        shouldInject = _shouldInjectPolyfill(name, shouldInject);

        if (typeof shouldInject !== "boolean") {
          throw new Error(".shouldInjectPolyfill must return a boolean.");
        }
      }

      return shouldInject;
    },
    debug: function debug(name) {
      debugLog().found = true;
      if (!_debug || !name) return;
      if (debugLog().polyfills.has(provider.name)) return;
      debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);
    },
    assertDependency: function assertDependency(name) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
      if (missingDependencies === false) return;

      if (absoluteImports) {
        // If absoluteImports is not false, we will try resolving
        // the dependency and throw if it's not possible. We can
        // skip the check here.
        return;
      }

      var dep = version === "*" ? name : "".concat(name, "@^").concat(version);
      var found = missingDependencies.all ? false : mapGetOr(depsCache, "".concat(name, " :: ").concat(dirname), function () {
        return deps.has(dirname, name);
      });

      if (!found) {
        debugLog().missingDeps.add(dep);
      }
    }
  };
  var provider = factory(api, providerOptions, dirname);

  if (typeof provider[methodName] !== "function") {
    throw new Error("The \"".concat(provider.name || factory.name, "\" provider doesn't ") + "support the \"".concat(method, "\" polyfilling method."));
  }

  if (Array.isArray(provider.polyfills)) {
    polyfillsNames = new Set(provider.polyfills);
    filterPolyfills = provider.filterPolyfills;
  } else if (provider.polyfills) {
    polyfillsNames = new Set(Object.keys(provider.polyfills));
    polyfillsSupport = provider.polyfills;
    filterPolyfills = provider.filterPolyfills;
  } else {
    polyfillsNames = new Set();
  }

  var _ref = (0, _normalizeOptions.validateIncludeExclude)(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);

  include = _ref.include;
  exclude = _ref.exclude;
  return {
    debug: _debug,
    method: method,
    targets: targets,
    provider: provider,
    callProvider: function callProvider(payload, path) {
      var utils = getUtils(path); // $FlowIgnore

      provider[methodName](payload, utils, path);
    }
  };
}

function definePolyfillProvider(factory) {
  return (0, _helperPluginUtils.declare)(function (babelApi, options, dirname) {
    babelApi.assertVersion(7);
    var traverse = babelApi.traverse;
    var debugLog;
    var missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);

    var _instantiateProvider = instantiateProvider(factory, options, missingDependencies, dirname, function () {
      return debugLog;
    }, babelApi),
        debug = _instantiateProvider.debug,
        method = _instantiateProvider.method,
        targets = _instantiateProvider.targets,
        provider = _instantiateProvider.provider,
        callProvider = _instantiateProvider.callProvider;

    var createVisitor = method === "entry-global" ? v.entry : v.usage;
    var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);

    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {
      console.log("".concat(provider.name, ": `DEBUG` option"));
      console.log("\nUsing targets: ".concat((0, _debugUtils.stringifyTargetsMultiline)(targets)));
      console.log("\nUsing polyfills with `".concat(method, "` method:"));
    }

    return {
      name: "inject-polyfills",
      visitor: visitor,
      pre: function pre() {
        var _provider$pre;

        debugLog = {
          polyfills: new Map(),
          found: false,
          providers: new Set(),
          missingDeps: new Set()
        }; // $FlowIgnore - Flow doesn't support optional calls

        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
      },
      post: function post() {
        var _provider$post; // $FlowIgnore - Flow doesn't support optional calls


        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);

        if (missingDependencies !== false) {
          if (missingDependencies.log === "per-file") {
            deps.logMissing(debugLog.missingDeps);
          } else {
            deps.laterLogMissing(debugLog.missingDeps);
          }
        }

        if (!debug) return;
        if (this.filename) console.log("\n[".concat(this.filename, "]"));

        if (debugLog.polyfills.size === 0) {
          console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the ".concat(provider.name, " polyfill did not add any polyfill.") : "The entry point for the ".concat(provider.name, " polyfill has not been found.") : "Based on your code and targets, the ".concat(provider.name, " polyfill did not add any polyfill."));
          return;
        }

        if (method === "entry-global") {
          console.log("The ".concat(provider.name, " polyfill entry has been replaced with ") + "the following polyfills:");
        } else {
          console.log("The ".concat(provider.name, " polyfill added the following polyfills:"));
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = debugLog.polyfills[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                name = _step$value[0],
                support = _step$value[1];

            if (support) {
              var filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, support);
              var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
              console.log("  ".concat(name, " ").concat(formattedTargets));
            } else {
              console.log("  ".concat(name));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    };
  });
}

function mapGetOr(map, key, getDefault) {
  var val = map.get(key);

  if (val === undefined) {
    val = getDefault();
    map.set(key, val);
  }

  return val;
}