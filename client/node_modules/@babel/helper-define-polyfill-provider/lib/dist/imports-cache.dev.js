"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports["default"] = void 0;

var babel = _interopRequireWildcard(require("@babel/core"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _ref = babel["default"] || babel,
    t = _ref.types;

var ImportsCache =
/*#__PURE__*/
function () {
  function ImportsCache(resolver) {
    _classCallCheck(this, ImportsCache);

    this._imports = new WeakMap();
    this._anonymousImports = new WeakMap();
    this._lastImports = new WeakMap();
    this._resolver = resolver;
  }

  _createClass(ImportsCache, [{
    key: "storeAnonymous",
    value: function storeAnonymous(programPath, url, // eslint-disable-next-line no-undef
    getVal) {
      var key = this._normalizeKey(programPath, url);

      var imports = this._ensure(this._anonymousImports, programPath, Set);

      if (imports.has(key)) return;
      var node = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)));
      imports.add(key);

      this._injectImport(programPath, node);
    }
  }, {
    key: "storeNamed",
    value: function storeNamed(programPath, url, name, getVal) {
      var key = this._normalizeKey(programPath, url, name);

      var imports = this._ensure(this._imports, programPath, Map);

      if (!imports.has(key)) {
        var _getVal = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)), t.identifier(name)),
            node = _getVal.node,
            id = _getVal.name;

        imports.set(key, id);

        this._injectImport(programPath, node);
      }

      return t.identifier(imports.get(key));
    }
  }, {
    key: "_injectImport",
    value: function _injectImport(programPath, node) {
      var lastImport = this._lastImports.get(programPath);

      if (lastImport && lastImport.node && // Sometimes the AST is modified and the "last import"
      // we have has been replaced
      lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {
        lastImport = lastImport.insertAfter(node);
      } else {
        lastImport = programPath.unshiftContainer("body", node);
      }

      lastImport = lastImport[lastImport.length - 1];

      this._lastImports.set(programPath, lastImport);
      /*
      let lastImport;
       programPath.get("body").forEach(path => {
        if (path.isImportDeclaration()) lastImport = path;
        if (
          path.isExpressionStatement() &&
          isRequireCall(path.get("expression"))
        ) {
          lastImport = path;
        }
        if (
          path.isVariableDeclaration() &&
          path.get("declarations").length === 1 &&
          (isRequireCall(path.get("declarations.0.init")) ||
            (path.get("declarations.0.init").isMemberExpression() &&
              isRequireCall(path.get("declarations.0.init.object"))))
        ) {
          lastImport = path;
        }
      });*/

    }
  }, {
    key: "_ensure",
    value: function _ensure(map, programPath, Collection) {
      var collection = map.get(programPath);

      if (!collection) {
        collection = new Collection();
        map.set(programPath, collection);
      }

      return collection;
    }
  }, {
    key: "_normalizeKey",
    value: function _normalizeKey(programPath, url) {
      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      var sourceType = programPath.node.sourceType; // If we rely on the imported binding (the "name" parameter), we also need to cache
      // based on the sourceType. This is because the module transforms change the names
      // of the import variables.

      return "".concat(name && sourceType, "::").concat(url, "::").concat(name);
    }
  }]);

  return ImportsCache;
}();

exports["default"] = ImportsCache;