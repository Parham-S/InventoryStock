"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createPlugin;

var _pluginSyntaxJsx = require("@babel/plugin-syntax-jsx");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _helperModuleImports = require("@babel/helper-module-imports");

var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");

var DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};
var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;

var get = function get(pass, name) {
  return pass.get("@babel/plugin-react-jsx/".concat(name));
};

var set = function set(pass, name, v) {
  return pass.set("@babel/plugin-react-jsx/".concat(name), v);
};

function createPlugin(_ref) {
  var name = _ref.name,
      development = _ref.development;
  return (0, _helperPluginUtils.declare)(function (api, options) {
    var PURE_ANNOTATION = options.pure,
        _options$throwIfNames = options.throwIfNamespace,
        throwIfNamespace = _options$throwIfNames === void 0 ? true : _options$throwIfNames,
        filter = options.filter,
        _options$runtime = options.runtime,
        RUNTIME_DEFAULT = _options$runtime === void 0 ? development ? "automatic" : "classic" : _options$runtime,
        _options$importSource = options.importSource,
        IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,
        _options$pragma = options.pragma,
        PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,
        _options$pragmaFrag = options.pragmaFrag,
        PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;
    {
      var _options$useSpread = options.useSpread,
          useSpread = _options$useSpread === void 0 ? false : _options$useSpread,
          _options$useBuiltIns = options.useBuiltIns,
          useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

      if (RUNTIME_DEFAULT === "classic") {
        if (typeof useSpread !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
        }

        if (typeof useBuiltIns !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
        }

        if (useSpread && useBuiltIns) {
          throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
        }
      }
    }
    var injectMetaPropertiesVisitor = {
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = path.get("attributes")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var attr = _step.value;
            if (!attr.isJSXElement()) continue;
            var _name = attr.node.name.name;

            if (_name === "__source" || _name === "__self") {
              throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var attributes = [];

        if (isThisAllowed(path)) {
          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__self"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));
        }

        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__source"), _core.types.jsxExpressionContainer(makeSource(path, state))));
        path.pushContainer("attributes", attributes);
      }
    };
    return {
      name: name,
      inherits: _pluginSyntaxJsx["default"],
      visitor: {
        JSXNamespacedName: function JSXNamespacedName(path) {
          if (throwIfNamespace) {
            throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
          }
        },
        JSXSpreadChild: function JSXSpreadChild(path) {
          throw path.buildCodeFrameError("Spread children are not supported in React.");
        },
        Program: {
          enter: function enter(path, state) {
            var file = state.file;
            var runtime = RUNTIME_DEFAULT;
            var source = IMPORT_SOURCE_DEFAULT;
            var pragma = PRAGMA_DEFAULT;
            var pragmaFrag = PRAGMA_FRAG_DEFAULT;
            var sourceSet = !!options.importSource;
            var pragmaSet = !!options.pragma;
            var pragmaFragSet = !!options.pragmaFrag;

            if (file.ast.comments) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = file.ast.comments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var comment = _step2.value;
                  var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                  if (sourceMatches) {
                    source = sourceMatches[1];
                    sourceSet = true;
                  }

                  var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                  if (runtimeMatches) {
                    runtime = runtimeMatches[1];
                  }

                  var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxMatches) {
                    pragma = jsxMatches[1];
                    pragmaSet = true;
                  }

                  var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxFragMatches) {
                    pragmaFrag = jsxFragMatches[1];
                    pragmaFragSet = true;
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }

            set(state, "runtime", runtime);

            if (runtime === "classic") {
              if (sourceSet) {
                throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
              }

              var createElement = toMemberExpression(pragma);
              var fragment = toMemberExpression(pragmaFrag);
              set(state, "id/createElement", function () {
                return _core.types.cloneNode(createElement);
              });
              set(state, "id/fragment", function () {
                return _core.types.cloneNode(fragment);
              });
              set(state, "defaultPure", pragma === DEFAULT.pragma);
            } else if (runtime === "automatic") {
              if (pragmaSet || pragmaFragSet) {
                throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
              }

              var define = function define(name, id) {
                return set(state, name, createImportLazily(state, path, id, source));
              };

              define("id/jsx", development ? "jsxDEV" : "jsx");
              define("id/jsxs", development ? "jsxDEV" : "jsxs");
              define("id/createElement", "createElement");
              define("id/fragment", "Fragment");
              set(state, "defaultPure", source === DEFAULT.importSource);
            } else {
              throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
            }

            if (development) {
              path.traverse(injectMetaPropertiesVisitor, state);
            }
          }
        },
        JSXElement: {
          exit: function exit(path, file) {
            var callExpr;

            if (get(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
              callExpr = buildCreateElementCall(path, file);
            } else {
              callExpr = buildJSXElementCall(path, file);
            }

            path.replaceWith(_core.types.inherits(callExpr, path.node));
          }
        },
        JSXFragment: {
          exit: function exit(path, file) {
            var callExpr;

            if (get(file, "runtime") === "classic") {
              callExpr = buildCreateElementFragmentCall(path, file);
            } else {
              callExpr = buildJSXFragmentCall(path, file);
            }

            path.replaceWith(_core.types.inherits(callExpr, path.node));
          }
        },
        JSXAttribute: function JSXAttribute(path) {
          if (_core.types.isJSXElement(path.node.value)) {
            path.node.value = _core.types.jsxExpressionContainer(path.node.value);
          }
        }
      }
    };

    function getThisFunctionParent(path) {
      var scope = path.scope;

      do {
        if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {
          return scope.path;
        }
      } while (scope = scope.parent);

      return null;
    }

    function isDerivedClass(classPath) {
      return classPath.node.superClass !== null;
    }

    function isThisAllowed(path) {
      var parentMethodOrFunction = getThisFunctionParent(path);

      if (parentMethodOrFunction === null) {
        return true;
      }

      if (!parentMethodOrFunction.isMethod()) {
        return true;
      }

      if (parentMethodOrFunction.node.kind !== "constructor") {
        return true;
      }

      return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);
    }

    function call(pass, name, args) {
      var node = _core.types.callExpression(get(pass, "id/".concat(name))(), args);

      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) (0, _helperAnnotateAsPure["default"])(node);
      return node;
    }

    function shouldUseCreateElement(path) {
      var openingPath = path.get("openingElement");
      var attributes = openingPath.node.attributes;
      var seenPropsSpread = false;

      for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i];

        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === "key") {
          return true;
        } else if (_core.types.isJSXSpreadAttribute(attr)) {
          seenPropsSpread = true;
        }
      }

      return false;
    }

    function convertJSXIdentifier(node, parent) {
      if (_core.types.isJSXIdentifier(node)) {
        if (node.name === "this" && _core.types.isReferenced(node, parent)) {
          return _core.types.thisExpression();
        } else if (_core.types.isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
        } else {
          return _core.types.stringLiteral(node.name);
        }
      } else if (_core.types.isJSXMemberExpression(node)) {
        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (_core.types.isJSXNamespacedName(node)) {
        return _core.types.stringLiteral("".concat(node.namespace.name, ":").concat(node.name.name));
      }

      return node;
    }

    function convertAttributeValue(node) {
      if (_core.types.isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }

    function accumulateAttribute(array, attribute) {
      if (_core.types.isJSXSpreadAttribute(attribute.node)) {
        var arg = attribute.node.argument;

        if (_core.types.isObjectExpression(arg)) {
          array.push.apply(array, _toConsumableArray(arg.properties));
        } else {
          array.push(_core.types.spreadElement(arg));
        }

        return array;
      }

      var value = convertAttributeValue(attribute.node.name.name !== "key" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);

      if (attribute.node.name.name === "key" && value === null) {
        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
      }

      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {
        var _value$extra;

        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
      }

      if (_core.types.isJSXNamespacedName(attribute.node.name)) {
        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + ":" + attribute.node.name.name.name);
      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {
        attribute.node.name.type = "Identifier";
      } else {
        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);
      }

      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));
      return array;
    }

    function buildChildrenProperty(children) {
      var childrenNode;

      if (children.length === 1) {
        childrenNode = children[0];
      } else if (children.length > 1) {
        childrenNode = _core.types.arrayExpression(children);
      } else {
        return undefined;
      }

      return _core.types.objectProperty(_core.types.identifier("children"), childrenNode);
    }

    function buildJSXElementCall(path, file) {
      var openingPath = path.get("openingElement");
      var args = [getTag(openingPath)];
      var attribsArray = [];
      var extracted = Object.create(null);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = openingPath.get("attributes")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var attr = _step3.value;

          if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {
            var _name2 = attr.node.name.name;

            switch (_name2) {
              case "__source":
              case "__self":
                if (extracted[_name2]) throw sourceSelfError(path, _name2);

              case "key":
                {
                  var keyValue = convertAttributeValue(attr.node.value);

                  if (keyValue === null) {
                    throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
                  }

                  extracted[_name2] = keyValue;
                  break;
                }

              default:
                attribsArray.push(attr);
            }
          } else {
            attribsArray.push(attr);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var children = _core.types.react.buildChildren(path.node);

      var attribs;

      if (attribsArray.length || children.length) {
        attribs = buildJSXOpeningElementAttributes(attribsArray, file, children);
      } else {
        attribs = _core.types.objectExpression([]);
      }

      args.push(attribs);

      if (development) {
        var _extracted$key, _extracted$__source, _extracted$__self;

        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());
      } else if (extracted.key !== undefined) {
        args.push(extracted.key);
      }

      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }

    function buildJSXOpeningElementAttributes(attribs, file, children) {
      var props = attribs.reduce(accumulateAttribute, []);

      if ((children == null ? void 0 : children.length) > 0) {
        props.push(buildChildrenProperty(children));
      }

      return _core.types.objectExpression(props);
    }

    function buildJSXFragmentCall(path, file) {
      var args = [get(file, "id/fragment")()];

      var children = _core.types.react.buildChildren(path.node);

      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));

      if (development) {
        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));
      }

      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }

    function buildCreateElementFragmentCall(path, file) {
      if (filter && !filter(path.node, file)) return;
      return call(file, "createElement", [get(file, "id/fragment")(), _core.types.nullLiteral()].concat(_toConsumableArray(_core.types.react.buildChildren(path.node))));
    }

    function buildCreateElementCall(path, file) {
      var openingPath = path.get("openingElement");
      return call(file, "createElement", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes"))].concat(_toConsumableArray(_core.types.react.buildChildren(path.node))));
    }

    function getTag(openingPath) {
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var tagName;

      if (_core.types.isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (_core.types.isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      if (_core.types.react.isCompatTag(tagName)) {
        return _core.types.stringLiteral(tagName);
      } else {
        return tagExpr;
      }
    }

    function buildCreateElementOpeningElementAttributes(file, path, attribs) {
      var runtime = get(file, "runtime");
      {
        if (runtime !== "automatic") {
          var objs = [];

          var _props = attribs.reduce(accumulateAttribute, []);

          if (!useSpread) {
            var start = 0;

            _props.forEach(function (prop, i) {
              if (_core.types.isSpreadElement(prop)) {
                if (i > start) {
                  objs.push(_core.types.objectExpression(_props.slice(start, i)));
                }

                objs.push(prop.argument);
                start = i + 1;
              }
            });

            if (_props.length > start) {
              objs.push(_core.types.objectExpression(_props.slice(start)));
            }
          } else if (_props.length) {
            objs.push(_core.types.objectExpression(_props));
          }

          if (!objs.length) {
            return _core.types.nullLiteral();
          }

          if (objs.length === 1) {
            return objs[0];
          }

          if (!_core.types.isObjectExpression(objs[0])) {
            objs.unshift(_core.types.objectExpression([]));
          }

          var helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
          return _core.types.callExpression(helper, objs);
        }
      }
      var props = [];
      var found = Object.create(null);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = attribs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var attr = _step4.value;

          var _name3 = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;

          if (runtime === "automatic" && (_name3 === "__source" || _name3 === "__self")) {
            if (found[_name3]) throw sourceSelfError(path, _name3);
            found[_name3] = true;
          }

          accumulateAttribute(props, attr);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();
    }
  });

  function getSource(source, importName) {
    switch (importName) {
      case "Fragment":
        return "".concat(source, "/").concat(development ? "jsx-dev-runtime" : "jsx-runtime");

      case "jsxDEV":
        return "".concat(source, "/jsx-dev-runtime");

      case "jsx":
      case "jsxs":
        return "".concat(source, "/jsx-runtime");

      case "createElement":
        return source;
    }
  }

  function createImportLazily(pass, path, importName, source) {
    return function () {
      var actualSource = getSource(source, importName);

      if ((0, _helperModuleImports.isModule)(path)) {
        var reference = get(pass, "imports/".concat(importName));
        if (reference) return _core.types.cloneNode(reference);
        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {
          importedInterop: "uncompiled",
          importPosition: "after"
        });
        set(pass, "imports/".concat(importName), reference);
        return reference;
      } else {
        var _reference = get(pass, "requires/".concat(actualSource));

        if (_reference) {
          _reference = _core.types.cloneNode(_reference);
        } else {
          _reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {
            importedInterop: "uncompiled"
          });
          set(pass, "requires/".concat(actualSource), _reference);
        }

        return _core.types.memberExpression(_reference, _core.types.identifier(importName));
      }
    };
  }
}

function toMemberExpression(id) {
  return id.split(".").map(function (name) {
    return _core.types.identifier(name);
  }).reduce(function (object, property) {
    return _core.types.memberExpression(object, property);
  });
}

function makeSource(path, state) {
  var location = path.node.loc;

  if (!location) {
    return path.scope.buildUndefinedNode();
  }

  if (!state.fileNameIdentifier) {
    var _state$filename = state.filename,
        filename = _state$filename === void 0 ? "" : _state$filename;
    var fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
    var scope = path.hub.getScope();

    if (scope) {
      scope.push({
        id: fileNameIdentifier,
        init: _core.types.stringLiteral(filename)
      });
    }

    state.fileNameIdentifier = fileNameIdentifier;
  }

  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
}

function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
  var fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();
  var fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();

  var fileNameProperty = _core.types.objectProperty(_core.types.identifier("fileName"), fileNameIdentifier);

  var lineNumberProperty = _core.types.objectProperty(_core.types.identifier("lineNumber"), fileLineLiteral);

  var columnNumberProperty = _core.types.objectProperty(_core.types.identifier("columnNumber"), fileColumnLiteral);

  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
}

function sourceSelfError(path, name) {
  var pluginName = "transform-react-jsx-".concat(name.slice(2));
  return path.buildCodeFrameError("Duplicate ".concat(name, " prop found. You are most likely using the deprecated ").concat(pluginName, " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config."));
}