'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = _interopDefault(require('postcss'));

var valueParser = _interopDefault(require('postcss-values-parser'));

var index = postcss.plugin('postcss-color-hex-alpha', function (opts) {
  // whether to preserve the original hexa
  var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;
  return function (root) {
    // for each declaration with a hexa
    root.walkDecls(function (decl) {
      if (hasAlphaHex(decl)) {
        // replace instances of hexa with rgba()
        var ast = valueParser(decl.value).parse();
        walk(ast, function (node) {
          if (isAlphaHex(node)) {
            node.replaceWith(hexa2rgba(node));
          }
        }); // conditionally update the declaration

        var modifiedValue = String(ast);

        if (decl.value !== modifiedValue) {
          if (preserve) {
            decl.cloneBefore({
              value: modifiedValue
            });
          } else {
            decl.value = modifiedValue;
          }
        }
      }
    });
  };
}); // match any hexa

var alphaHexRegExp = /#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)\b/; // whether a node has a hexa

var hasAlphaHex = function hasAlphaHex(node) {
  return alphaHexRegExp.test(node.value);
}; // match an exact hexa


var alphaHexValueRegExp = /^#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)$/; // walk all nodes in a value

var walk = function walk(node, fn) {
  if (Object(node.nodes).length) {
    node.nodes.slice().forEach(function (child) {
      fn(child);
      walk(child, fn);
    });
  }
}; // decimal precision


var alphaDecimalPrecision = 100000; // match a hexa node

var isAlphaHex = function isAlphaHex(node) {
  return node.type === 'word' && alphaHexValueRegExp.test(node.value);
};

var hexa2rgba = function hexa2rgba(node) {
  // hex is the node value
  var hex = node.value; // conditionally expand a hex

  var hex8 = "0x".concat(hex.length === 5 ? hex.slice(1).replace(/[0-9A-f]/g, '$&$&') : hex.slice(1)); // extract the red, blue, green, and alpha values from the hex

  var _ref = [parseInt(hex8.slice(2, 4), 16), parseInt(hex8.slice(4, 6), 16), parseInt(hex8.slice(6, 8), 16), Math.round(parseInt(hex8.slice(8, 10), 16) / 255 * alphaDecimalPrecision) / alphaDecimalPrecision],
      r = _ref[0],
      g = _ref[1],
      b = _ref[2],
      a = _ref[3]; // return a new rgba function, preserving the whitespace of the original node

  var rgbaFunc = valueParser.func({
    value: 'rgba',
    raws: Object.assign({}, node.raws)
  });
  rgbaFunc.append(valueParser.paren({
    value: '('
  }));
  rgbaFunc.append(valueParser.number({
    value: r
  }));
  rgbaFunc.append(valueParser.comma({
    value: ','
  }));
  rgbaFunc.append(valueParser.number({
    value: g
  }));
  rgbaFunc.append(valueParser.comma({
    value: ','
  }));
  rgbaFunc.append(valueParser.number({
    value: b
  }));
  rgbaFunc.append(valueParser.comma({
    value: ','
  }));
  rgbaFunc.append(valueParser.number({
    value: a
  }));
  rgbaFunc.append(valueParser.paren({
    value: ')'
  }));
  return rgbaFunc;
};

module.exports = index;