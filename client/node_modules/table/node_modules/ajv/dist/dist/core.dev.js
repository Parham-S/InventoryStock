"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;

var validate_1 = require("./compile/validate");

Object.defineProperty(exports, "KeywordCxt", {
  enumerable: true,
  get: function get() {
    return validate_1.KeywordCxt;
  }
});

var codegen_1 = require("./compile/codegen");

Object.defineProperty(exports, "_", {
  enumerable: true,
  get: function get() {
    return codegen_1._;
  }
});
Object.defineProperty(exports, "str", {
  enumerable: true,
  get: function get() {
    return codegen_1.str;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function get() {
    return codegen_1.stringify;
  }
});
Object.defineProperty(exports, "nil", {
  enumerable: true,
  get: function get() {
    return codegen_1.nil;
  }
});
Object.defineProperty(exports, "Name", {
  enumerable: true,
  get: function get() {
    return codegen_1.Name;
  }
});
Object.defineProperty(exports, "CodeGen", {
  enumerable: true,
  get: function get() {
    return codegen_1.CodeGen;
  }
});

var validation_error_1 = require("./runtime/validation_error");

var ref_error_1 = require("./compile/ref_error");

var rules_1 = require("./compile/rules");

var compile_1 = require("./compile");

var codegen_2 = require("./compile/codegen");

var resolve_1 = require("./compile/resolve");

var dataType_1 = require("./compile/validate/dataType");

var util_1 = require("./compile/util");

var $dataRefSchema = require("./refs/data.json");

var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
var EXT_SCOPE_NAMES = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]);
var removedOptions = {
  errorDataPath: "",
  format: "`validateFormats: false` can be used instead.",
  nullable: '"nullable" keyword is supported by default.',
  jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
  extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
  missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
  processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
  sourceCode: "Use option `code: {source: true}`",
  strictDefaults: "It is default now, see option `strict`.",
  strictKeywords: "It is default now, see option `strict`.",
  uniqueItems: '"uniqueItems" keyword is always validated.',
  unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
  cache: "Map is used as cache, schema object as key.",
  serialize: "Map is used as cache, schema object as key.",
  ajvErrors: "It is default now."
};
var deprecatedOptions = {
  ignoreKeywordsWithRef: "",
  jsPropertySyntax: "",
  unicode: '"minLength"/"maxLength" account for unicode characters by default.'
};
var MAX_EXPRESSION = 200; // eslint-disable-next-line complexity

function requiredOptions(o) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;

  var s = o.strict;

  var _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;

  var optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
  return {
    strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s) !== null && _c !== void 0 ? _c : true,
    strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
    strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : "log",
    strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
    strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : false,
    code: o.code ? _objectSpread({}, o.code, {
      optimize: optimize
    }) : {
      optimize: optimize
    },
    loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
    loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
    meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
    messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
    inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
    schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
    addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
    validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
    validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
    unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
    int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
  };
}

var Ajv =
/*#__PURE__*/
function () {
  function Ajv() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Ajv);

    this.schemas = {};
    this.refs = {};
    this.formats = {};
    this._compilations = new Set();
    this._loading = {};
    this._cache = new Map();
    opts = this.opts = _objectSpread({}, opts, {}, requiredOptions(opts));
    var _this$opts$code = this.opts.code,
        es5 = _this$opts$code.es5,
        lines = _this$opts$code.lines;
    this.scope = new codegen_2.ValueScope({
      scope: {},
      prefixes: EXT_SCOPE_NAMES,
      es5: es5,
      lines: lines
    });
    this.logger = getLogger(opts.logger);
    var formatOpt = opts.validateFormats;
    opts.validateFormats = false;
    this.RULES = (0, rules_1.getRules)();
    checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
    checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
    this._metaOpts = getMetaSchemaOptions.call(this);
    if (opts.formats) addInitialFormats.call(this);

    this._addVocabularies();

    this._addDefaultMetaSchema();

    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
    if (_typeof(opts.meta) == "object") this.addMetaSchema(opts.meta);
    addInitialSchemas.call(this);
    opts.validateFormats = formatOpt;
  }

  _createClass(Ajv, [{
    key: "_addVocabularies",
    value: function _addVocabularies() {
      this.addKeyword("$async");
    }
  }, {
    key: "_addDefaultMetaSchema",
    value: function _addDefaultMetaSchema() {
      var _this$opts = this.opts,
          $data = _this$opts.$data,
          meta = _this$opts.meta,
          schemaId = _this$opts.schemaId;
      var _dataRefSchema = $dataRefSchema;

      if (schemaId === "id") {
        _dataRefSchema = _objectSpread({}, $dataRefSchema);
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }

      if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
  }, {
    key: "defaultMeta",
    value: function defaultMeta() {
      var _this$opts2 = this.opts,
          meta = _this$opts2.meta,
          schemaId = _this$opts2.schemaId;
      return this.opts.defaultMeta = _typeof(meta) == "object" ? meta[schemaId] || meta : undefined;
    }
  }, {
    key: "validate",
    value: function validate(schemaKeyRef, // key, ref or schema object
    data // to be validated
    ) {
      var v;

      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error("no schema with key or ref \"".concat(schemaKeyRef, "\""));
      } else {
        v = this.compile(schemaKeyRef);
      }

      var valid = v(data);
      if (!("$async" in v)) this.errors = v.errors;
      return valid;
    }
  }, {
    key: "compile",
    value: function compile(schema, _meta) {
      var sch = this._addSchema(schema, _meta);

      return sch.validate || this._compileSchemaEnv(sch);
    }
  }, {
    key: "compileAsync",
    value: function compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }

      var loadSchema = this.opts.loadSchema;
      return runCompileAsync.call(this, schema, meta);

      function runCompileAsync(_schema, _meta) {
        var sch;
        return regeneratorRuntime.async(function runCompileAsync$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return regeneratorRuntime.awrap(loadMetaSchema.call(this, _schema.$schema));

              case 2:
                sch = this._addSchema(_schema, _meta);
                return _context.abrupt("return", sch.validate || _compileAsync.call(this, sch));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }

      function loadMetaSchema($ref) {
        return regeneratorRuntime.async(function loadMetaSchema$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!($ref && !this.getSchema($ref))) {
                  _context2.next = 3;
                  break;
                }

                _context2.next = 3;
                return regeneratorRuntime.awrap(runCompileAsync.call(this, {
                  $ref: $ref
                }, true));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this);
      }

      function _compileAsync(sch) {
        return regeneratorRuntime.async(function _compileAsync$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                return _context3.abrupt("return", this._compileSchemaEnv(sch));

              case 4:
                _context3.prev = 4;
                _context3.t0 = _context3["catch"](0);

                if (_context3.t0 instanceof ref_error_1["default"]) {
                  _context3.next = 8;
                  break;
                }

                throw _context3.t0;

              case 8:
                checkLoaded.call(this, _context3.t0);
                _context3.next = 11;
                return regeneratorRuntime.awrap(loadMissingSchema.call(this, _context3.t0.missingSchema));

              case 11:
                return _context3.abrupt("return", _compileAsync.call(this, sch));

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, null, this, [[0, 4]]);
      }

      function checkLoaded(_ref) {
        var ref = _ref.missingSchema,
            missingRef = _ref.missingRef;

        if (this.refs[ref]) {
          throw new Error("AnySchema ".concat(ref, " is loaded but ").concat(missingRef, " cannot be resolved"));
        }
      }

      function loadMissingSchema(ref) {
        var _schema;

        return regeneratorRuntime.async(function loadMissingSchema$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return regeneratorRuntime.awrap(_loadSchema.call(this, ref));

              case 2:
                _schema = _context4.sent;

                if (this.refs[ref]) {
                  _context4.next = 6;
                  break;
                }

                _context4.next = 6;
                return regeneratorRuntime.awrap(loadMetaSchema.call(this, _schema.$schema));

              case 6:
                if (!this.refs[ref]) this.addSchema(_schema, ref, meta);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, null, this);
      }

      function _loadSchema(ref) {
        var p;
        return regeneratorRuntime.async(function _loadSchema$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                p = this._loading[ref];

                if (!p) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", p);

              case 3:
                _context5.prev = 3;
                _context5.next = 6;
                return regeneratorRuntime.awrap(this._loading[ref] = loadSchema(ref));

              case 6:
                return _context5.abrupt("return", _context5.sent);

              case 7:
                _context5.prev = 7;
                delete this._loading[ref];
                return _context5.finish(7);

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, null, this, [[3,, 7, 10]]);
      }
    } // Adds schema to the instance

  }, {
    key: "addSchema",
    value: function addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta) // false to skip schema validation. Used internally, option validateSchema should be used instead.
    {
      var _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;

      if (Array.isArray(schema)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = schema[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var sch = _step.value;
            this.addSchema(sch, undefined, _meta, _validateSchema);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }

      var id;

      if (_typeof(schema) === "object") {
        var schemaId = this.opts.schemaId;
        id = schema[schemaId];

        if (id !== undefined && typeof id != "string") {
          throw new Error("schema ".concat(schemaId, " must be string"));
        }
      }

      key = (0, resolve_1.normalizeId)(key || id);

      this._checkUnique(key);

      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    } // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false

  }, {
    key: "addMetaSchema",
    value: function addMetaSchema(schema, key) // false to skip schema validation, can be used to override validateSchema option for meta-schema
    {
      var _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;

      this.addSchema(schema, key, true, _validateSchema);
      return this;
    } //  Validate schema against its meta-schema

  }, {
    key: "validateSchema",
    value: function validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean") return true;
      var $schema;
      $schema = schema.$schema;

      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }

      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();

      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }

      var valid = this.validate($schema, schema);

      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(message);else throw new Error(message);
      }

      return valid;
    } // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)

  }, {
    key: "getSchema",
    value: function getSchema(keyRef) {
      var sch;

      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") {
        keyRef = sch;
      }

      if (sch === undefined) {
        var schemaId = this.opts.schemaId;
        var root = new compile_1.SchemaEnv({
          schema: {},
          schemaId: schemaId
        });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch) return;
        this.refs[keyRef] = sch;
      }

      return sch.validate || this._compileSchemaEnv(sch);
    } // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.

  }, {
    key: "removeSchema",
    value: function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);

        this._removeAllSchemas(this.refs, schemaKeyRef);

        return this;
      }

      switch (_typeof(schemaKeyRef)) {
        case "undefined":
          this._removeAllSchemas(this.schemas);

          this._removeAllSchemas(this.refs);

          this._cache.clear();

          return this;

        case "string":
          {
            var sch = getSchEnv.call(this, schemaKeyRef);
            if (_typeof(sch) == "object") this._cache["delete"](sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }

        case "object":
          {
            var cacheKey = schemaKeyRef;

            this._cache["delete"](cacheKey);

            var id = schemaKeyRef[this.opts.schemaId];

            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }

            return this;
          }

        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    } // add "vocabulary" - a collection of keywords

  }, {
    key: "addVocabulary",
    value: function addVocabulary(definitions) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = definitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var def = _step2.value;
          this.addKeyword(def);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this;
    }
  }, {
    key: "addKeyword",
    value: function addKeyword(kwdOrDef, def // deprecated
    ) {
      var _this = this;

      var keyword;

      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;

        if (_typeof(def) == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (_typeof(kwdOrDef) == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;

        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }

      checkKeyword.call(this, keyword, def);

      if (!def) {
        (0, util_1.eachItem)(keyword, function (kwd) {
          return addRule.call(_this, kwd);
        });
        return this;
      }

      keywordMetaschema.call(this, def);

      var definition = _objectSpread({}, def, {
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      });

      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? function (k) {
        return addRule.call(_this, k, definition);
      } : function (k) {
        return definition.type.forEach(function (t) {
          return addRule.call(_this, k, definition, t);
        });
      });
      return this;
    }
  }, {
    key: "getKeyword",
    value: function getKeyword(keyword) {
      var rule = this.RULES.all[keyword];
      return _typeof(rule) == "object" ? rule.definition : !!rule;
    } // Remove keyword

  }, {
    key: "removeKeyword",
    value: function removeKeyword(keyword) {
      // TODO return type should be Ajv
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = RULES.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var group = _step3.value;
          var i = group.rules.findIndex(function (rule) {
            return rule.keyword === keyword;
          });
          if (i >= 0) group.rules.splice(i, 1);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return this;
    } // Add format

  }, {
    key: "addFormat",
    value: function addFormat(name, format) {
      if (typeof format == "string") format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
  }, {
    key: "errorsText",
    value: function errorsText() // optional options with properties `separator` and `dataVar`
    {
      var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;

      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$separator = _ref2.separator,
          separator = _ref2$separator === void 0 ? ", " : _ref2$separator,
          _ref2$dataVar = _ref2.dataVar,
          dataVar = _ref2$dataVar === void 0 ? "data" : _ref2$dataVar;

      if (!errors || errors.length === 0) return "No errors";
      return errors.map(function (e) {
        return "".concat(dataVar).concat(e.instancePath, " ").concat(e.message);
      }).reduce(function (text, msg) {
        return text + separator + msg;
      });
    }
  }, {
    key: "$dataMetaSchema",
    value: function $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      var rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = keywordsJsonPointers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var jsonPointer = _step4.value;
          var segments = jsonPointer.split("/").slice(1); // first segment is an empty string

          var keywords = metaSchema;
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = segments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var seg = _step5.value;
              keywords = keywords[seg];
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          for (var key in rules) {
            var rule = rules[key];
            if (_typeof(rule) != "object") continue;
            var $data = rule.definition.$data;
            var schema = keywords[key];
            if ($data && schema) keywords[key] = schemaOrData(schema);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return metaSchema;
    }
  }, {
    key: "_removeAllSchemas",
    value: function _removeAllSchemas(schemas, regex) {
      for (var keyRef in schemas) {
        var sch = schemas[keyRef];

        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache["delete"](sch.schema);

            delete schemas[keyRef];
          }
        }
      }
    }
  }, {
    key: "_addSchema",
    value: function _addSchema(schema, meta, baseId) {
      var validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;
      var addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;
      var id;
      var schemaId = this.opts.schemaId;

      if (_typeof(schema) == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd) throw new Error("schema must be object");else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
      }

      var sch = this._cache.get(schema);

      if (sch !== undefined) return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      var localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({
        schema: schema,
        schemaId: schemaId,
        meta: meta,
        baseId: baseId,
        localRefs: localRefs
      });

      this._cache.set(sch.schema, sch);

      if (addSchema && !baseId.startsWith("#")) {
        // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
        if (baseId) this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }

      if (validateSchema) this.validateSchema(schema, true);
      return sch;
    }
  }, {
    key: "_checkUnique",
    value: function _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error("schema with key or id \"".concat(id, "\" already exists"));
      }
    }
  }, {
    key: "_compileSchemaEnv",
    value: function _compileSchemaEnv(sch) {
      if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);
      /* istanbul ignore if */

      if (!sch.validate) throw new Error("ajv implementation error");
      return sch.validate;
    }
  }, {
    key: "_compileMetaSchema",
    value: function _compileMetaSchema(sch) {
      var currentOpts = this.opts;
      this.opts = this._metaOpts;

      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }]);

  return Ajv;
}();

exports["default"] = Ajv;
Ajv.ValidationError = validation_error_1["default"];
Ajv.MissingRefError = ref_error_1["default"];

function checkOptions(checkOpts, options, msg) {
  var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "error";

  for (var key in checkOpts) {
    var opt = key;
    if (opt in options) this.logger[log]("".concat(msg, ": option ").concat(key, ". ").concat(checkOpts[opt]));
  }
}

function getSchEnv(keyRef) {
  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line

  return this.schemas[keyRef] || this.refs[keyRef];
}

function addInitialSchemas() {
  var optsSchemas = this.opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (var key in optsSchemas) {
    this.addSchema(optsSchemas[key], key);
  }
}

function addInitialFormats() {
  for (var name in this.opts.formats) {
    var format = this.opts.formats[name];
    if (format) this.addFormat(name, format);
  }
}

function addInitialKeywords(defs) {
  if (Array.isArray(defs)) {
    this.addVocabulary(defs);
    return;
  }

  this.logger.warn("keywords option as map is deprecated, pass array");

  for (var keyword in defs) {
    var def = defs[keyword];
    if (!def.keyword) def.keyword = keyword;
    this.addKeyword(def);
  }
}

function getMetaSchemaOptions() {
  var metaOpts = _objectSpread({}, this.opts);

  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = META_IGNORE_OPTIONS[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var opt = _step6.value;
      delete metaOpts[opt];
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return metaOpts;
}

var noLogs = {
  log: function log() {},
  warn: function warn() {},
  error: function error() {}
};

function getLogger(logger) {
  if (logger === false) return noLogs;
  if (logger === undefined) return console;
  if (logger.log && logger.warn && logger.error) return logger;
  throw new Error("logger must implement log, warn and error methods");
}

var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;

function checkKeyword(keyword, def) {
  var RULES = this.RULES;
  (0, util_1.eachItem)(keyword, function (kwd) {
    if (RULES.keywords[kwd]) throw new Error("Keyword ".concat(kwd, " is already defined"));
    if (!KEYWORD_NAME.test(kwd)) throw new Error("Keyword ".concat(kwd, " has invalid name"));
  });
  if (!def) return;

  if (def.$data && !("code" in def || "validate" in def)) {
    throw new Error('$data keyword must have "code" or "validate" function');
  }
}

function addRule(keyword, definition, dataType) {
  var _this2 = this;

  var _a;

  var post = definition === null || definition === void 0 ? void 0 : definition.post;
  if (dataType && post) throw new Error('keyword with "post" flag cannot have "type"');
  var RULES = this.RULES;
  var ruleGroup = post ? RULES.post : RULES.rules.find(function (_ref3) {
    var t = _ref3.type;
    return t === dataType;
  });

  if (!ruleGroup) {
    ruleGroup = {
      type: dataType,
      rules: []
    };
    RULES.rules.push(ruleGroup);
  }

  RULES.keywords[keyword] = true;
  if (!definition) return;
  var rule = {
    keyword: keyword,
    definition: _objectSpread({}, definition, {
      type: (0, dataType_1.getJSONTypes)(definition.type),
      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
    })
  };
  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);
  RULES.all[keyword] = rule;
  (_a = definition["implements"]) === null || _a === void 0 ? void 0 : _a.forEach(function (kwd) {
    return _this2.addKeyword(kwd);
  });
}

function addBeforeRule(ruleGroup, rule, before) {
  var i = ruleGroup.rules.findIndex(function (_rule) {
    return _rule.keyword === before;
  });

  if (i >= 0) {
    ruleGroup.rules.splice(i, 0, rule);
  } else {
    ruleGroup.rules.push(rule);
    this.logger.warn("rule ".concat(before, " is not defined"));
  }
}

function keywordMetaschema(def) {
  var metaSchema = def.metaSchema;
  if (metaSchema === undefined) return;
  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
  def.validateSchema = this.compile(metaSchema, true);
}

var $dataRef = {
  $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
};

function schemaOrData(schema) {
  return {
    anyOf: [schema, $dataRef]
  };
}