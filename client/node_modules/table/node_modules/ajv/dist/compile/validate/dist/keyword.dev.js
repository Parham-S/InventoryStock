"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject10() {
  var data = _taggedTemplateLiteral(["", ".length"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["", " === null ? ", " : ", ".concat(", ")"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["Array.isArray(", ")"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["", "[", "]"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["", "", ""]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["await "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", ".errors"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["", ".errors"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["", " instanceof ", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["await "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;

var codegen_1 = require("../codegen");

var names_1 = require("../names");

var code_1 = require("../../vocabularies/code");

var errors_1 = require("../errors");

function macroKeywordCode(cxt, def) {
  var gen = cxt.gen,
      keyword = cxt.keyword,
      schema = cxt.schema,
      parentSchema = cxt.parentSchema,
      it = cxt.it;
  var macroSchema = def.macro.call(it.self, schema, parentSchema, it);
  var schemaRef = useKeyword(gen, keyword, macroSchema);
  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
  var valid = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1.nil,
    errSchemaPath: "".concat(it.errSchemaPath, "/").concat(keyword),
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid);
  cxt.pass(valid, function () {
    return cxt.error(true);
  });
}

exports.macroKeywordCode = macroKeywordCode;

function funcKeywordCode(cxt, def) {
  var _a;

  var gen = cxt.gen,
      keyword = cxt.keyword,
      schema = cxt.schema,
      parentSchema = cxt.parentSchema,
      $data = cxt.$data,
      it = cxt.it;
  checkAsyncKeyword(it, def);
  var validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
  var validateRef = useKeyword(gen, keyword, validate);
  var valid = gen["let"]("valid");
  cxt.block$data(valid, validateKeyword);
  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);

  function validateKeyword() {
    if (def.errors === false) {
      assignValid();
      if (def.modifying) modifyData(cxt);
      reportErrs(function () {
        return cxt.error();
      });
    } else {
      var ruleErrs = def.async ? validateAsync() : validateSync();
      if (def.modifying) modifyData(cxt);
      reportErrs(function () {
        return addErrs(cxt, ruleErrs);
      });
    }
  }

  function validateAsync() {
    var ruleErrs = gen["let"]("ruleErrs", null);
    gen["try"](function () {
      return assignValid((0, codegen_1._)(_templateObject()));
    }, function (e) {
      return gen.assign(valid, false)["if"]((0, codegen_1._)(_templateObject2(), e, it.ValidationError), function () {
        return gen.assign(ruleErrs, (0, codegen_1._)(_templateObject3(), e));
      }, function () {
        return gen["throw"](e);
      });
    });
    return ruleErrs;
  }

  function validateSync() {
    var validateErrs = (0, codegen_1._)(_templateObject4(), validateRef);
    gen.assign(validateErrs, null);
    assignValid(codegen_1.nil);
    return validateErrs;
  }

  function assignValid() {
    var _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)(_templateObject5()) : codegen_1.nil;

    var passCxt = it.opts.passContext ? names_1["default"]["this"] : names_1["default"].self;
    var passSchema = !("compile" in def && !$data || def.schema === false);
    gen.assign(valid, (0, codegen_1._)(_templateObject6(), _await, (0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)), def.modifying);
  }

  function reportErrs(errors) {
    var _a;

    gen["if"]((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
  }
}

exports.funcKeywordCode = funcKeywordCode;

function modifyData(cxt) {
  var gen = cxt.gen,
      data = cxt.data,
      it = cxt.it;
  gen["if"](it.parentData, function () {
    return gen.assign(data, (0, codegen_1._)(_templateObject7(), it.parentData, it.parentDataProperty));
  });
}

function addErrs(cxt, errs) {
  var gen = cxt.gen;
  gen["if"]((0, codegen_1._)(_templateObject8(), errs), function () {
    gen.assign(names_1["default"].vErrors, (0, codegen_1._)(_templateObject9(), names_1["default"].vErrors, errs, names_1["default"].vErrors, errs)).assign(names_1["default"].errors, (0, codegen_1._)(_templateObject10(), names_1["default"].vErrors));
    (0, errors_1.extendErrors)(cxt);
  }, function () {
    return cxt.error();
  });
}

function checkAsyncKeyword(_ref, def) {
  var schemaEnv = _ref.schemaEnv;
  if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
}

function useKeyword(gen, keyword, result) {
  if (result === undefined) throw new Error("keyword \"".concat(keyword, "\" failed to compile"));
  return gen.scopeValue("keyword", typeof result == "function" ? {
    ref: result
  } : {
    ref: result,
    code: (0, codegen_1.stringify)(result)
  });
}

function validSchemaType(schema, schemaType) {
  var allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // TODO add tests
  return !schemaType.length || schemaType.some(function (st) {
    return st === "array" ? Array.isArray(schema) : st === "object" ? schema && _typeof(schema) == "object" && !Array.isArray(schema) : _typeof(schema) == st || allowUndefined && typeof schema == "undefined";
  });
}

exports.validSchemaType = validSchemaType;

function validateKeywordUsage(_ref2, def, keyword) {
  var schema = _ref2.schema,
      opts = _ref2.opts,
      self = _ref2.self,
      errSchemaPath = _ref2.errSchemaPath;

  /* istanbul ignore if */
  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
    throw new Error("ajv implementation error");
  }

  var deps = def.dependencies;

  if (deps === null || deps === void 0 ? void 0 : deps.some(function (kwd) {
    return !Object.prototype.hasOwnProperty.call(schema, kwd);
  })) {
    throw new Error("parent schema must have dependencies of ".concat(keyword, ": ").concat(deps.join(",")));
  }

  if (def.validateSchema) {
    var valid = def.validateSchema(schema[keyword]);

    if (!valid) {
      var msg = "keyword \"".concat(keyword, "\" value is invalid at path \"").concat(errSchemaPath, "\": ") + self.errorsText(def.validateSchema.errors);
      if (opts.validateSchema === "log") self.logger.error(msg);else throw new Error(msg);
    }
  }
}

exports.validateKeywordUsage = validateKeywordUsage;