"use strict";

function _templateObject39() {
  var data = _taggedTemplateLiteral(["", " && ", ""]);

  _templateObject39 = function _templateObject39() {
    return data;
  };

  return data;
}

function _templateObject38() {
  var data = _taggedTemplateLiteral(["", "", ""]);

  _templateObject38 = function _templateObject38() {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _templateObject37() {
  var data = _taggedTemplateLiteral(["!", "(", ")"]);

  _templateObject37 = function _templateObject37() {
    return data;
  };

  return data;
}

function _templateObject36() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject36 = function _templateObject36() {
    return data;
  };

  return data;
}

function _templateObject35() {
  var data = _taggedTemplateLiteral(["", " === undefined"]);

  _templateObject35 = function _templateObject35() {
    return data;
  };

  return data;
}

function _templateObject34() {
  var data = _taggedTemplateLiteral(["", " !== undefined && (", ")"]);

  _templateObject34 = function _templateObject34() {
    return data;
  };

  return data;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _templateObject33() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject33 = function _templateObject33() {
    return data;
  };

  return data;
}

function _templateObject32() {
  var data = _taggedTemplateLiteral(["", ".items"]);

  _templateObject32 = function _templateObject32() {
    return data;
  };

  return data;
}

function _templateObject31() {
  var data = _taggedTemplateLiteral(["", ".props"]);

  _templateObject31 = function _templateObject31() {
    return data;
  };

  return data;
}

function _templateObject30() {
  var data = _taggedTemplateLiteral(["", " === 0"]);

  _templateObject30 = function _templateObject30() {
    return data;
  };

  return data;
}

function _templateObject29() {
  var data = _taggedTemplateLiteral(["", ".errors"]);

  _templateObject29 = function _templateObject29() {
    return data;
  };

  return data;
}

function _templateObject28() {
  var data = _taggedTemplateLiteral(["new ", "(", ")"]);

  _templateObject28 = function _templateObject28() {
    return data;
  };

  return data;
}

function _templateObject27() {
  var data = _taggedTemplateLiteral(["", " === 0"]);

  _templateObject27 = function _templateObject27() {
    return data;
  };

  return data;
}

function _templateObject26() {
  var data = _taggedTemplateLiteral(["", ".opts.$comment(", ", ", ", ", ".schema)"]);

  _templateObject26 = function _templateObject26() {
    return data;
  };

  return data;
}

function _templateObject25() {
  var data = _taggedTemplateLiteral(["", "/$comment"]);

  _templateObject25 = function _templateObject25() {
    return data;
  };

  return data;
}

function _templateObject24() {
  var data = _taggedTemplateLiteral(["", ".logger.log(", ")"]);

  _templateObject24 = function _templateObject24() {
    return data;
  };

  return data;
}

function _templateObject23() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject23 = function _templateObject23() {
    return data;
  };

  return data;
}

function _templateObject22() {
  var data = _taggedTemplateLiteral(["/*# sourceURL=", " */"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject21() {
  var data = _taggedTemplateLiteral(["undefined"]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["", ".items"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["", ".dynamicItems"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["undefined"]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["", ".props"]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["", ".dynamicProps"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["", ".evaluated"]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["{}"]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["undefined"]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["undefined"]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\"\""]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["", ".", ""]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["", ".", ""]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["", ".", ""]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["", ".", ""]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["", ".", ""]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral([", ", "={}"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["{", "=\"\", ", ", ", ", ", "=", "", "}={}"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["", ", ", ""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\"use strict\"; ", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["", ", ", ""]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;

var boolSchema_1 = require("./boolSchema");

var dataType_1 = require("./dataType");

var applicability_1 = require("./applicability");

var dataType_2 = require("./dataType");

var defaults_1 = require("./defaults");

var keyword_1 = require("./keyword");

var subschema_1 = require("./subschema");

var codegen_1 = require("../codegen");

var names_1 = require("../names");

var resolve_1 = require("../resolve");

var util_1 = require("../util");

var errors_1 = require("../errors"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas


function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);

    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }

  validateFunction(it, function () {
    return (0, boolSchema_1.topBoolOrEmptySchema)(it);
  });
}

exports.validateFunctionCode = validateFunctionCode;

function validateFunction(_ref, body) {
  var gen = _ref.gen,
      validateName = _ref.validateName,
      schema = _ref.schema,
      schemaEnv = _ref.schemaEnv,
      opts = _ref.opts;

  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1._)(_templateObject(), names_1["default"].data, names_1["default"].valCxt), schemaEnv.$async, function () {
      gen.code((0, codegen_1._)(_templateObject2(), funcSourceUrl(schema, opts)));
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1._)(_templateObject3(), names_1["default"].data, destructureValCxt(opts)), schemaEnv.$async, function () {
      return gen.code(funcSourceUrl(schema, opts)).code(body);
    });
  }
}

function destructureValCxt(opts) {
  return (0, codegen_1._)(_templateObject4(), names_1["default"].instancePath, names_1["default"].parentData, names_1["default"].parentDataProperty, names_1["default"].rootData, names_1["default"].data, opts.dynamicRef ? (0, codegen_1._)(_templateObject5(), names_1["default"].dynamicAnchors) : codegen_1.nil);
}

function destructureValCxtES5(gen, opts) {
  gen["if"](names_1["default"].valCxt, function () {
    gen["var"](names_1["default"].instancePath, (0, codegen_1._)(_templateObject6(), names_1["default"].valCxt, names_1["default"].instancePath));
    gen["var"](names_1["default"].parentData, (0, codegen_1._)(_templateObject7(), names_1["default"].valCxt, names_1["default"].parentData));
    gen["var"](names_1["default"].parentDataProperty, (0, codegen_1._)(_templateObject8(), names_1["default"].valCxt, names_1["default"].parentDataProperty));
    gen["var"](names_1["default"].rootData, (0, codegen_1._)(_templateObject9(), names_1["default"].valCxt, names_1["default"].rootData));
    if (opts.dynamicRef) gen["var"](names_1["default"].dynamicAnchors, (0, codegen_1._)(_templateObject10(), names_1["default"].valCxt, names_1["default"].dynamicAnchors));
  }, function () {
    gen["var"](names_1["default"].instancePath, (0, codegen_1._)(_templateObject11()));
    gen["var"](names_1["default"].parentData, (0, codegen_1._)(_templateObject12()));
    gen["var"](names_1["default"].parentDataProperty, (0, codegen_1._)(_templateObject13()));
    gen["var"](names_1["default"].rootData, names_1["default"].data);
    if (opts.dynamicRef) gen["var"](names_1["default"].dynamicAnchors, (0, codegen_1._)(_templateObject14()));
  });
}

function topSchemaObjCode(it) {
  var schema = it.schema,
      opts = it.opts,
      gen = it.gen;
  validateFunction(it, function () {
    if (opts.$comment && schema.$comment) commentKeyword(it);
    checkNoDefault(it);
    gen["let"](names_1["default"].vErrors, null);
    gen["let"](names_1["default"].errors, 0);
    if (opts.unevaluated) resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}

function resetEvaluated(it) {
  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
  var gen = it.gen,
      validateName = it.validateName;
  it.evaluated = gen["const"]("evaluated", (0, codegen_1._)(_templateObject15(), validateName));
  gen["if"]((0, codegen_1._)(_templateObject16(), it.evaluated), function () {
    return gen.assign((0, codegen_1._)(_templateObject17(), it.evaluated), (0, codegen_1._)(_templateObject18()));
  });
  gen["if"]((0, codegen_1._)(_templateObject19(), it.evaluated), function () {
    return gen.assign((0, codegen_1._)(_templateObject20(), it.evaluated), (0, codegen_1._)(_templateObject21()));
  });
}

function funcSourceUrl(schema, opts) {
  var schId = _typeof(schema) == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(_templateObject22(), schId) : codegen_1.nil;
} // schema compilation - this function is used recursively to generate code for sub-schemas


function subschemaCode(it, valid) {
  if (isSchemaObj(it)) {
    checkKeywords(it);

    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid);
      return;
    }
  }

  (0, boolSchema_1.boolOrEmptySchema)(it, valid);
}

function schemaCxtHasRules(_ref2) {
  var schema = _ref2.schema,
      self = _ref2.self;
  if (typeof schema == "boolean") return !schema;

  for (var key in schema) {
    if (self.RULES.all[key]) return true;
  }

  return false;
}

function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}

function subSchemaObjCode(it, valid) {
  var schema = it.schema,
      gen = it.gen,
      opts = it.opts;
  if (opts.$comment && schema.$comment) commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  var errsCount = gen["const"]("_errs", names_1["default"].errors);
  typeAndKeywords(it, errsCount); // TODO var

  gen["var"](valid, (0, codegen_1._)(_templateObject23(), errsCount, names_1["default"].errors));
}

function checkKeywords(it) {
  (0, util_1.checkUnknownRules)(it);
  checkRefsAndKeywords(it);
}

function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
  var types = (0, dataType_1.getSchemaTypes)(it.schema);
  var checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
  schemaKeywords(it, types, !checkedTypes, errsCount);
}

function checkRefsAndKeywords(it) {
  var schema = it.schema,
      errSchemaPath = it.errSchemaPath,
      opts = it.opts,
      self = it.self;

  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
    self.logger.warn("$ref: keywords ignored in schema at path \"".concat(errSchemaPath, "\""));
  }
}

function checkNoDefault(it) {
  var schema = it.schema,
      opts = it.opts;

  if (schema["default"] !== undefined && opts.useDefaults && opts.strictSchema) {
    (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
  }
}

function updateContext(it) {
  var schId = it.schema[it.opts.schemaId];
  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.baseId, schId);
}

function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
}

function commentKeyword(_ref3) {
  var gen = _ref3.gen,
      schemaEnv = _ref3.schemaEnv,
      schema = _ref3.schema,
      errSchemaPath = _ref3.errSchemaPath,
      opts = _ref3.opts;
  var msg = schema.$comment;

  if (opts.$comment === true) {
    gen.code((0, codegen_1._)(_templateObject24(), names_1["default"].self, msg));
  } else if (typeof opts.$comment == "function") {
    var schemaPath = (0, codegen_1.str)(_templateObject25(), errSchemaPath);
    var rootName = gen.scopeValue("root", {
      ref: schemaEnv.root
    });
    gen.code((0, codegen_1._)(_templateObject26(), names_1["default"].self, msg, schemaPath, rootName));
  }
}

function returnResults(it) {
  var gen = it.gen,
      schemaEnv = it.schemaEnv,
      validateName = it.validateName,
      ValidationError = it.ValidationError,
      opts = it.opts;

  if (schemaEnv.$async) {
    // TODO assign unevaluated
    gen["if"]((0, codegen_1._)(_templateObject27(), names_1["default"].errors), function () {
      return gen["return"](names_1["default"].data);
    }, function () {
      return gen["throw"]((0, codegen_1._)(_templateObject28(), ValidationError, names_1["default"].vErrors));
    });
  } else {
    gen.assign((0, codegen_1._)(_templateObject29(), validateName), names_1["default"].vErrors);
    if (opts.unevaluated) assignEvaluated(it);
    gen["return"]((0, codegen_1._)(_templateObject30(), names_1["default"].errors));
  }
}

function assignEvaluated(_ref4) {
  var gen = _ref4.gen,
      evaluated = _ref4.evaluated,
      props = _ref4.props,
      items = _ref4.items;
  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject31(), evaluated), props);
  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject32(), evaluated), items);
}

function schemaKeywords(it, types, typeErrors, errsCount) {
  var gen = it.gen,
      schema = it.schema,
      data = it.data,
      allErrors = it.allErrors,
      opts = it.opts,
      self = it.self;
  var RULES = self.RULES;

  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(function () {
      return keywordCode(it, "$ref", RULES.all.$ref.definition);
    }); // TODO typecast

    return;
  }

  if (!opts.jtd) checkStrictTypes(it, types);
  gen.block(function () {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = RULES.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var group = _step.value;
        groupKeywords(group);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    groupKeywords(RULES.post);
  });

  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;

    if (group.type) {
      gen["if"]((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it, group);

      if (types.length === 1 && types[0] === group.type && typeErrors) {
        gen["else"]();
        (0, dataType_2.reportTypeError)(it);
      }

      gen.endIf();
    } else {
      iterateKeywords(it, group);
    } // TODO make it "ok" call?


    if (!allErrors) gen["if"]((0, codegen_1._)(_templateObject33(), names_1["default"].errors, errsCount || 0));
  }
}

function iterateKeywords(it, group) {
  var gen = it.gen,
      schema = it.schema,
      useDefaults = it.opts.useDefaults;
  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
  gen.block(function () {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = group.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var rule = _step2.value;

        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  });
}

function checkStrictTypes(it, types) {
  if (it.schemaEnv.meta || !it.opts.strictTypes) return;
  checkContextTypes(it, types);
  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
  checkKeywordTypes(it, it.dataTypes);
}

function checkContextTypes(it, types) {
  if (!types.length) return;

  if (!it.dataTypes.length) {
    it.dataTypes = types;
    return;
  }

  types.forEach(function (t) {
    if (!includesType(it.dataTypes, t)) {
      strictTypesError(it, "type \"".concat(t, "\" not allowed by context \"").concat(it.dataTypes.join(","), "\""));
    }
  });
  it.dataTypes = it.dataTypes.filter(function (t) {
    return includesType(types, t);
  });
}

function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}

function checkKeywordTypes(it, ts) {
  var rules = it.self.RULES.all;

  for (var keyword in rules) {
    var rule = rules[keyword];

    if (_typeof(rule) == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
      var type = rule.definition.type;

      if (type.length && !type.some(function (t) {
        return hasApplicableType(ts, t);
      })) {
        strictTypesError(it, "missing type \"".concat(type.join(","), "\" for keyword \"").concat(keyword, "\""));
      }
    }
  }
}

function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}

function includesType(ts, t) {
  return ts.includes(t) || t === "integer" && ts.includes("number");
}

function strictTypesError(it, msg) {
  var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += " at \"".concat(schemaPath, "\" (strictTypes)");
  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
}

var KeywordCxt =
/*#__PURE__*/
function () {
  function KeywordCxt(it, def, keyword) {
    _classCallCheck(this, KeywordCxt);

    (0, keyword_1.validateKeywordUsage)(it, def, keyword);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword;
    this.data = it.data;
    this.schema = it.schema[keyword];
    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
    this.schemaType = def.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def;

    if (this.$data) {
      this.schemaCode = it.gen["const"]("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;

      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
        throw new Error("".concat(keyword, " value must be ").concat(JSON.stringify(def.schemaType)));
      }
    }

    if ("code" in def ? def.trackErrors : def.errors !== false) {
      this.errsCount = it.gen["const"]("_errs", names_1["default"].errors);
    }
  }

  _createClass(KeywordCxt, [{
    key: "result",
    value: function result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
  }, {
    key: "failResult",
    value: function failResult(condition, successAction, failAction) {
      this.gen["if"](condition);
      if (failAction) failAction();else this.error();

      if (successAction) {
        this.gen["else"]();
        successAction();
        if (this.allErrors) this.gen.endIf();
      } else {
        if (this.allErrors) this.gen.endIf();else this.gen["else"]();
      }
    }
  }, {
    key: "pass",
    value: function pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
  }, {
    key: "fail",
    value: function fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors) this.gen["if"](false); // this branch will be removed by gen.optimize

        return;
      }

      this.gen["if"](condition);
      this.error();
      if (this.allErrors) this.gen.endIf();else this.gen["else"]();
    }
  }, {
    key: "fail$data",
    value: function fail$data(condition) {
      if (!this.$data) return this.fail(condition);
      var schemaCode = this.schemaCode;
      this.fail((0, codegen_1._)(_templateObject34(), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));
    }
  }, {
    key: "error",
    value: function error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);

        this._error(append, errorPaths);

        this.setParams({});
        return;
      }

      this._error(append, errorPaths);
    }
  }, {
    key: "_error",
    value: function _error(append, errorPaths) {
      ;
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
  }, {
    key: "$dataError",
    value: function $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.errsCount === undefined) throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
  }, {
    key: "ok",
    value: function ok(cond) {
      if (!this.allErrors) this.gen["if"](cond);
    }
  }, {
    key: "setParams",
    value: function setParams(obj, assign) {
      if (assign) Object.assign(this.params, obj);else this.params = obj;
    }
  }, {
    key: "block$data",
    value: function block$data(valid, codeBlock) {
      var _this = this;

      var $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;
      this.gen.block(function () {
        _this.check$data(valid, $dataValid);

        codeBlock();
      });
    }
  }, {
    key: "check$data",
    value: function check$data() {
      var valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;
      var $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;
      if (!this.$data) return;
      var gen = this.gen,
          schemaCode = this.schemaCode,
          schemaType = this.schemaType,
          def = this.def;
      gen["if"]((0, codegen_1.or)((0, codegen_1._)(_templateObject35(), schemaCode), $dataValid));
      if (valid !== codegen_1.nil) gen.assign(valid, true);

      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil) gen.assign(valid, false);
      }

      gen["else"]();
    }
  }, {
    key: "invalid$data",
    value: function invalid$data() {
      var gen = this.gen,
          schemaCode = this.schemaCode,
          schemaType = this.schemaType,
          def = this.def,
          it = this.it;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());

      function wrong$DataType() {
        if (schemaType.length) {
          /* istanbul ignore if */
          if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
          var st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)(_templateObject36(), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));
        }

        return codegen_1.nil;
      }

      function invalid$DataSchema() {
        if (def.validateSchema) {
          var validateSchemaRef = gen.scopeValue("validate$data", {
            ref: def.validateSchema
          }); // TODO value.code for standalone

          return (0, codegen_1._)(_templateObject37(), validateSchemaRef, schemaCode);
        }

        return codegen_1.nil;
      }
    }
  }, {
    key: "subschema",
    value: function subschema(appl, valid) {
      var subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);

      var nextContext = _objectSpread({}, this.it, {}, subschema, {
        items: undefined,
        props: undefined
      });

      subschemaCode(nextContext, valid);
      return nextContext;
    }
  }, {
    key: "mergeEvaluated",
    value: function mergeEvaluated(schemaCxt, toName) {
      var it = this.it,
          gen = this.gen;
      if (!it.opts.unevaluated) return;

      if (it.props !== true && schemaCxt.props !== undefined) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }

      if (it.items !== true && schemaCxt.items !== undefined) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
  }, {
    key: "mergeValidEvaluated",
    value: function mergeValidEvaluated(schemaCxt, valid) {
      var _this2 = this;

      var it = this.it,
          gen = this.gen;

      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen["if"](valid, function () {
          return _this2.mergeEvaluated(schemaCxt, codegen_1.Name);
        });
        return true;
      }
    }
  }]);

  return KeywordCxt;
}();

exports.KeywordCxt = KeywordCxt;

function keywordCode(it, keyword, def, ruleType) {
  var cxt = new KeywordCxt(it, def, keyword);

  if ("code" in def) {
    def.code(cxt, ruleType);
  } else if (cxt.$data && def.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def);
  } else if ("macro" in def) {
    (0, keyword_1.macroKeywordCode)(cxt, def);
  } else if (def.compile || def.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def);
  }
}

var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

function getData($data, _ref5) {
  var dataLevel = _ref5.dataLevel,
      dataNames = _ref5.dataNames,
      dataPathArr = _ref5.dataPathArr;
  var jsonPointer;
  var data;
  if ($data === "") return names_1["default"].rootData;

  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: ".concat($data));
    jsonPointer = $data;
    data = names_1["default"].rootData;
  } else {
    var matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches) throw new Error("Invalid JSON-pointer: ".concat($data));
    var up = +matches[1];
    jsonPointer = matches[2];

    if (jsonPointer === "#") {
      if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }

    if (up > dataLevel) throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split("/");
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = segments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var segment = _step3.value;

      if (segment) {
        data = (0, codegen_1._)(_templateObject38(), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));
        expr = (0, codegen_1._)(_templateObject39(), expr, data);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return expr;

  function errorMsg(pointerType, up) {
    return "Cannot access ".concat(pointerType, " ").concat(up, " levels up, current level is ").concat(dataLevel);
  }
}

exports.getData = getData;