"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["delete ", "[", "]"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", ".test(", ")"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["{additionalProperty: ", "}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var code_1 = require("../code");

var codegen_1 = require("../../compile/codegen");

var names_1 = require("../../compile/names");

var util_1 = require("../../compile/util");

var error = {
  message: "must NOT have additional properties",
  params: function params(_ref) {
    var _params = _ref.params;
    return (0, codegen_1._)(_templateObject(), _params.additionalProperty);
  }
};
var def = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error,
  code: function code(cxt) {
    var gen = cxt.gen,
        schema = cxt.schema,
        parentSchema = cxt.parentSchema,
        data = cxt.data,
        errsCount = cxt.errsCount,
        it = cxt.it;
    /* istanbul ignore if */

    if (!errsCount) throw new Error("ajv implementation error");
    var allErrors = it.allErrors,
        opts = it.opts;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema)) return;
    var props = (0, code_1.allSchemaProperties)(parentSchema.properties);
    var patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1._)(_templateObject2(), errsCount, names_1["default"].errors));

    function checkAdditionalProperties() {
      gen.forIn("key", data, function (key) {
        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen["if"](isAdditional(key), function () {
          return additionalPropertyCode(key);
        });
      });
    }

    function isAdditional(key) {
      var definedProp;

      if (props.length > 8) {
        // TODO maybe an option instead of hard-coded 8?
        var propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1.or).apply(void 0, _toConsumableArray(props.map(function (p) {
          return (0, codegen_1._)(_templateObject3(), key, p);
        })));
      } else {
        definedProp = codegen_1.nil;
      }

      if (patProps.length) {
        definedProp = (0, codegen_1.or).apply(void 0, [definedProp].concat(_toConsumableArray(patProps.map(function (p) {
          return (0, codegen_1._)(_templateObject4(), (0, code_1.usePattern)(cxt, p), key);
        }))));
      }

      return (0, codegen_1.not)(definedProp);
    }

    function deleteAdditional(key) {
      gen.code((0, codegen_1._)(_templateObject5(), data, key));
    }

    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }

      if (schema === false) {
        cxt.setParams({
          additionalProperty: key
        });
        cxt.error();
        if (!allErrors) gen["break"]();
        return;
      }

      if (_typeof(schema) == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        var valid = gen.name("valid");

        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid, false);
          gen["if"]((0, codegen_1.not)(valid), function () {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid);
          if (!allErrors) gen["if"]((0, codegen_1.not)(valid), function () {
            return gen["break"]();
          });
        }
      }
    }

    function applyAdditionalSchema(key, valid, errors) {
      var subschema = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1.Type.Str
      };

      if (errors === false) {
        Object.assign(subschema, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }

      cxt.subschema(subschema, valid);
    }
  }
};
exports["default"] = def;