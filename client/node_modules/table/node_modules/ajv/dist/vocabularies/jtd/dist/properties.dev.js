"use strict";

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", " !== ", ""]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["delete ", "[", "]"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["{error: ", ", missingProperty: ", "}"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["{error: ", ", additionalProperty: ", "}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProperties = exports.error = void 0;

var code_1 = require("../code");

var util_1 = require("../../compile/util");

var codegen_1 = require("../../compile/codegen");

var metadata_1 = require("./metadata");

var nullable_1 = require("./nullable");

var error_1 = require("./error");

var PropError;

(function (PropError) {
  PropError["Additional"] = "additional";
  PropError["Missing"] = "missing";
})(PropError || (PropError = {}));

exports.error = {
  message: function message(cxt) {
    var params = cxt.params;
    return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : "must have property '".concat(params.missingProperty, "'") : (0, error_1.typeErrorMessage)(cxt, "object");
  },
  params: function params(cxt) {
    var params = cxt.params;
    return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)(_templateObject(), params.propError, params.additionalProperty) : (0, codegen_1._)(_templateObject2(), params.propError, params.missingProperty) : (0, error_1.typeErrorParams)(cxt, "object");
  }
};
var def = {
  keyword: "properties",
  schemaType: "object",
  error: exports.error,
  code: validateProperties
}; // const error: KeywordErrorDefinition = {
//   message: "should NOT have additional properties",
//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
// }

function validateProperties(cxt) {
  (0, metadata_1.checkMetadata)(cxt);
  var gen = cxt.gen,
      data = cxt.data,
      parentSchema = cxt.parentSchema,
      it = cxt.it;
  var additionalProperties = parentSchema.additionalProperties,
      nullable = parentSchema.nullable;
  if (it.jtdDiscriminator && nullable) throw new Error("JTD: nullable inside discriminator mapping");

  if (commonProperties()) {
    throw new Error("JTD: properties and optionalProperties have common members");
  }

  var _schemaProperties = schemaProperties("properties"),
      _schemaProperties2 = _slicedToArray(_schemaProperties, 2),
      allProps = _schemaProperties2[0],
      properties = _schemaProperties2[1];

  var _schemaProperties3 = schemaProperties("optionalProperties"),
      _schemaProperties4 = _slicedToArray(_schemaProperties3, 2),
      allOptProps = _schemaProperties4[0],
      optProperties = _schemaProperties4[1];

  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
    return;
  }

  var _ref = it.jtdDiscriminator === undefined ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen["let"]("valid", false), true],
      _ref2 = _slicedToArray(_ref, 2),
      valid = _ref2[0],
      cond = _ref2[1];

  gen["if"](cond, function () {
    return gen.assign(valid, true).block(function () {
      validateProps(properties, "properties", true);
      validateProps(optProperties, "optionalProperties");
      if (!additionalProperties) validateAdditional();
    });
  });
  cxt.pass(valid);

  function commonProperties() {
    var props = parentSchema.properties;
    var optProps = parentSchema.optionalProperties;
    if (!(props && optProps)) return false;

    for (var p in props) {
      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true;
    }

    return false;
  }

  function schemaProperties(keyword) {
    var schema = parentSchema[keyword];
    var allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];

    if (it.jtdDiscriminator && allPs.some(function (p) {
      return p === it.jtdDiscriminator;
    })) {
      throw new Error("JTD: discriminator tag used in ".concat(keyword));
    }

    var ps = allPs.filter(function (p) {
      return !(0, util_1.alwaysValidSchema)(it, schema[p]);
    });
    return [allPs, ps];
  }

  function validateProps(props, keyword, required) {
    var _valid = gen["var"]("valid");

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var prop = _step.value;
        gen["if"]((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), function () {
          return applyPropertySchema(prop, keyword, _valid);
        }, function () {
          return missingProperty(prop);
        });
        cxt.ok(_valid);
      };

      for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    function missingProperty(prop) {
      if (required) {
        gen.assign(_valid, false);
        cxt.error(false, {
          propError: PropError.Missing,
          missingProperty: prop
        }, {
          schemaPath: prop
        });
      } else {
        gen.assign(_valid, true);
      }
    }
  }

  function applyPropertySchema(prop, keyword, _valid) {
    cxt.subschema({
      keyword: keyword,
      schemaProp: prop,
      dataProp: prop
    }, _valid);
  }

  function validateAdditional() {
    gen.forIn("key", data, function (key) {
      var _allProps = it.jtdDiscriminator === undefined ? allProps : [it.jtdDiscriminator].concat(allProps);

      var addProp = isAdditional(key, _allProps, "properties");
      var addOptProp = isAdditional(key, allOptProps, "optionalProperties");
      var extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
      gen["if"](extra, function () {
        if (it.opts.removeAdditional) {
          gen.code((0, codegen_1._)(_templateObject3(), data, key));
        } else {
          cxt.error(false, {
            propError: PropError.Additional,
            additionalProperty: key
          }, {
            instancePath: key,
            parentSchema: true
          });
          if (!it.opts.allErrors) gen["break"]();
        }
      });
    });
  }

  function isAdditional(key, props, keyword) {
    var additional;

    if (props.length > 8) {
      // TODO maybe an option instead of hard-coded 8?
      var propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
      additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
    } else if (props.length) {
      additional = (0, codegen_1.and).apply(void 0, _toConsumableArray(props.map(function (p) {
        return (0, codegen_1._)(_templateObject4(), key, p);
      })));
    } else {
      additional = true;
    }

    return additional;
  }
}

exports.validateProperties = validateProperties;
exports["default"] = def;