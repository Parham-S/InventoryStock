"use strict";

function _templateObject9() {
  var data = _taggedTemplateLiteral(["", ".evaluated.items"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["", ".evaluated.props"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["", ".length"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["", " === null ? ", " : ", ".concat(", ")"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["", ".errors"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["!(", " instanceof ", ")"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["await ", ""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["", ".validate"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["", ".validate"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.callRef = exports.getValidate = void 0;

var ref_error_1 = require("../../compile/ref_error");

var code_1 = require("../code");

var codegen_1 = require("../../compile/codegen");

var names_1 = require("../../compile/names");

var compile_1 = require("../../compile");

var util_1 = require("../../compile/util");

var def = {
  keyword: "$ref",
  schemaType: "string",
  code: function code(cxt) {
    var gen = cxt.gen,
        $ref = cxt.schema,
        it = cxt.it;
    var baseId = it.baseId,
        env = it.schemaEnv,
        validateName = it.validateName,
        opts = it.opts,
        self = it.self;
    var root = env.root;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
    var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
    if (schOrEnv === undefined) throw new ref_error_1["default"](baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);

    function callRootRef() {
      if (env === root) return callRef(cxt, validateName, env, env.$async);
      var rootName = gen.scopeValue("root", {
        ref: root
      });
      return callRef(cxt, (0, codegen_1._)(_templateObject(), rootName), root, root.$async);
    }

    function callValidate(sch) {
      var v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }

    function inlineRefSchema(sch) {
      var schName = gen.scopeValue("schema", opts.code.source === true ? {
        ref: sch,
        code: (0, codegen_1.stringify)(sch)
      } : {
        ref: sch
      });
      var valid = gen.name("valid");
      var schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid);
    }
  }
};

function getValidate(cxt, sch) {
  var gen = cxt.gen;
  return sch.validate ? gen.scopeValue("validate", {
    ref: sch.validate
  }) : (0, codegen_1._)(_templateObject2(), gen.scopeValue("wrapper", {
    ref: sch
  }));
}

exports.getValidate = getValidate;

function callRef(cxt, v, sch, $async) {
  var gen = cxt.gen,
      it = cxt.it;
  var allErrors = it.allErrors,
      env = it.schemaEnv,
      opts = it.opts;
  var passCxt = opts.passContext ? names_1["default"]["this"] : codegen_1.nil;
  if ($async) callAsyncRef();else callSyncRef();

  function callAsyncRef() {
    if (!env.$async) throw new Error("async schema referenced by sync schema");
    var valid = gen["let"]("valid");
    gen["try"](function () {
      gen.code((0, codegen_1._)(_templateObject3(), (0, code_1.callValidateCode)(cxt, v, passCxt)));
      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result

      if (!allErrors) gen.assign(valid, true);
    }, function (e) {
      gen["if"]((0, codegen_1._)(_templateObject4(), e, it.ValidationError), function () {
        return gen["throw"](e);
      });
      addErrorsFrom(e);
      if (!allErrors) gen.assign(valid, false);
    });
    cxt.ok(valid);
  }

  function callSyncRef() {
    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), function () {
      return addEvaluatedFrom(v);
    }, function () {
      return addErrorsFrom(v);
    });
  }

  function addErrorsFrom(source) {
    var errs = (0, codegen_1._)(_templateObject5(), source);
    gen.assign(names_1["default"].vErrors, (0, codegen_1._)(_templateObject6(), names_1["default"].vErrors, errs, names_1["default"].vErrors, errs)); // TODO tagged

    gen.assign(names_1["default"].errors, (0, codegen_1._)(_templateObject7(), names_1["default"].vErrors));
  }

  function addEvaluatedFrom(source) {
    var _a;

    if (!it.opts.unevaluated) return;
    var schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated; // TODO refactor

    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== undefined) {
          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        var props = gen["var"]("props", (0, codegen_1._)(_templateObject8(), source));
        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
      }
    }

    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== undefined) {
          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        var items = gen["var"]("items", (0, codegen_1._)(_templateObject9(), source));
        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
      }
    }
  }
}

exports.callRef = callRef;
exports["default"] = def;