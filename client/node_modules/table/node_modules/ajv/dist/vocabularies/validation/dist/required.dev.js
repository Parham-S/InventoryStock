"use strict";

function _templateObject2() {
  var data = _taggedTemplateLiteral(["{missingProperty: ", "}"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["must have required property '", "'"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var code_1 = require("../code");

var codegen_1 = require("../../compile/codegen");

var util_1 = require("../../compile/util");

var error = {
  message: function message(_ref) {
    var missingProperty = _ref.params.missingProperty;
    return (0, codegen_1.str)(_templateObject(), missingProperty);
  },
  params: function params(_ref2) {
    var missingProperty = _ref2.params.missingProperty;
    return (0, codegen_1._)(_templateObject2(), missingProperty);
  }
};
var def = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error,
  code: function code(cxt) {
    var gen = cxt.gen,
        schema = cxt.schema,
        schemaCode = cxt.schemaCode,
        data = cxt.data,
        $data = cxt.$data,
        it = cxt.it;
    var opts = it.opts;
    if (!$data && schema.length === 0) return;
    var useLoop = schema.length >= opts.loopRequired;
    if (it.allErrors) allErrorsMode();else exitOnErrorMode();

    if (opts.strictRequired) {
      var props = cxt.parentSchema.properties;
      var definedProperties = cxt.it.definedProperties;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = schema[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var requiredKey = _step.value;

          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            var msg = "required property \"".concat(requiredKey, "\" is not defined at \"").concat(schemaPath, "\" (strictRequired)");
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1.nil, loopAllRequired);
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = schema[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var prop = _step2.value;
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }

    function exitOnErrorMode() {
      var missing = gen["let"]("missing");

      if (useLoop || $data) {
        var valid = gen["let"]("valid", true);
        cxt.block$data(valid, function () {
          return loopUntilMissing(missing, valid);
        });
        cxt.ok(valid);
      } else {
        gen["if"]((0, code_1.checkMissingProp)(cxt, schema, missing));
        (0, code_1.reportMissingProp)(cxt, missing);
        gen["else"]();
      }
    }

    function loopAllRequired() {
      gen.forOf("prop", schemaCode, function (prop) {
        cxt.setParams({
          missingProperty: prop
        });
        gen["if"]((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), function () {
          return cxt.error();
        });
      });
    }

    function loopUntilMissing(missing, valid) {
      cxt.setParams({
        missingProperty: missing
      });
      gen.forOf(missing, schemaCode, function () {
        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
        gen["if"]((0, codegen_1.not)(valid), function () {
          cxt.error();
          gen["break"]();
        });
      }, codegen_1.nil);
    }
  }
};
exports["default"] = def;