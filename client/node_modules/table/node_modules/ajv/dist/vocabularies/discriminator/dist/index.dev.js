"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", " === ", ""]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["typeof ", " == \"string\""]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["", "", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["{error: ", ", tag: ", ", tagValue: ", "}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var codegen_1 = require("../../compile/codegen");

var types_1 = require("../discriminator/types");

var error = {
  message: function message(_ref) {
    var _ref$params = _ref.params,
        discrError = _ref$params.discrError,
        tagName = _ref$params.tagName;
    return discrError === types_1.DiscrError.Tag ? "tag \"".concat(tagName, "\" must be string") : "value of tag \"".concat(tagName, "\" must be in oneOf");
  },
  params: function params(_ref2) {
    var _ref2$params = _ref2.params,
        discrError = _ref2$params.discrError,
        tag = _ref2$params.tag,
        tagName = _ref2$params.tagName;
    return (0, codegen_1._)(_templateObject(), discrError, tagName, tag);
  }
};
var def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: error,
  code: function code(cxt) {
    var gen = cxt.gen,
        data = cxt.data,
        schema = cxt.schema,
        parentSchema = cxt.parentSchema,
        it = cxt.it;
    var oneOf = parentSchema.oneOf;

    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }

    var tagName = schema.propertyName;
    if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
    if (schema.mapping) throw new Error("discriminator: mapping is not supported");
    if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
    var valid = gen["let"]("valid", false);
    var tag = gen["const"]("tag", (0, codegen_1._)(_templateObject2(), data, (0, codegen_1.getProperty)(tagName)));
    gen["if"]((0, codegen_1._)(_templateObject3(), tag), function () {
      return validateMapping();
    }, function () {
      return cxt.error(false, {
        discrError: types_1.DiscrError.Tag,
        tag: tag,
        tagName: tagName
      });
    });
    cxt.ok(valid);

    function validateMapping() {
      var mapping = getMapping();
      gen["if"](false);

      for (var tagValue in mapping) {
        gen.elseIf((0, codegen_1._)(_templateObject4(), tag, tagValue));
        gen.assign(valid, applyTagSchema(mapping[tagValue]));
      }

      gen["else"]();
      cxt.error(false, {
        discrError: types_1.DiscrError.Mapping,
        tag: tag,
        tagName: tagName
      });
      gen.endIf();
    }

    function applyTagSchema(schemaProp) {
      var _valid = gen.name("valid");

      var schCxt = cxt.subschema({
        keyword: "oneOf",
        schemaProp: schemaProp
      }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }

    function getMapping() {
      var _a;

      var oneOfMapping = {};
      var topRequired = hasRequired(parentSchema);
      var tagRequired = true;

      for (var i = 0; i < oneOf.length; i++) {
        var sch = oneOf[i];
        var propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];

        if (_typeof(propSch) != "object") {
          throw new Error("discriminator: oneOf schemas must have \"properties/".concat(tagName, "\""));
        }

        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }

      if (!tagRequired) throw new Error("discriminator: \"".concat(tagName, "\" must be required"));
      return oneOfMapping;

      function hasRequired(_ref3) {
        var required = _ref3.required;
        return Array.isArray(required) && required.includes(tagName);
      }

      function addMappings(sch, i) {
        if (sch["const"]) {
          addMapping(sch["const"], i);
        } else if (sch["enum"]) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = sch["enum"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var tagValue = _step.value;
              addMapping(tagValue, i);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          throw new Error("discriminator: \"properties/".concat(tagName, "\" must have \"const\" or \"enum\""));
        }
      }

      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error("discriminator: \"".concat(tagName, "\" values must be unique strings"));
        }

        oneOfMapping[tagValue] = i;
      }
    }
  }
};
exports["default"] = def;