"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
exports.callRef = exports.getValidate = void 0;
var ref_error_1 = require("../../compile/ref_error");
var code_1 = require("../code");
var codegen_1 = require("../../compile/codegen");
var names_1 = require("../../compile/names");
var compile_1 = require("../../compile");
var util_1 = require("../../compile/util");
var def = {
    keyword: "$ref",
    schemaType: "string",
    code: function (cxt) {
        var gen = cxt.gen, $ref = cxt.schema, it = cxt.it;
        var baseId = it.baseId, env = it.schemaEnv, validateName = it.validateName, opts = it.opts, self = it.self;
        var root = env.root;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1["default"](baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            var rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, codegen_1._(templateObject_1 || (templateObject_1 = __makeTemplateObject(["", ".validate"], ["", ".validate"])), rootName), root, root.$async);
        }
        function callValidate(sch) {
            var v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            var schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen_1.stringify(sch) } : { ref: sch });
            var valid = gen.name("valid");
            var schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    }
};
function getValidate(cxt, sch) {
    var gen = cxt.gen;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : codegen_1._(templateObject_2 || (templateObject_2 = __makeTemplateObject(["", ".validate"], ["", ".validate"])), gen.scopeValue("wrapper", { ref: sch }));
}
exports.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    var gen = cxt.gen, it = cxt.it;
    var allErrors = it.allErrors, env = it.schemaEnv, opts = it.opts;
    var passCxt = opts.passContext ? names_1["default"]["this"] : codegen_1.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        var valid = gen.let("valid");
        gen["try"](function () {
            gen.code(codegen_1._(templateObject_3 || (templateObject_3 = __makeTemplateObject(["await ", ""], ["await ", ""])), code_1.callValidateCode(cxt, v, passCxt)));
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, function (e) {
            gen["if"](codegen_1._(templateObject_4 || (templateObject_4 = __makeTemplateObject(["!(", " instanceof ", ")"], ["!(", " instanceof ", ")"])), e, it.ValidationError), function () { return gen["throw"](e); });
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result(code_1.callValidateCode(cxt, v, passCxt), function () { return addEvaluatedFrom(v); }, function () { return addErrorsFrom(v); });
    }
    function addErrorsFrom(source) {
        var errs = codegen_1._(templateObject_5 || (templateObject_5 = __makeTemplateObject(["", ".errors"], ["", ".errors"])), source);
        gen.assign(names_1["default"].vErrors, codegen_1._(templateObject_6 || (templateObject_6 = __makeTemplateObject(["", " === null ? ", " : ", ".concat(", ")"], ["", " === null ? ", " : ", ".concat(", ")"])), names_1["default"].vErrors, errs, names_1["default"].vErrors, errs)); // TODO tagged
        gen.assign(names_1["default"].errors, codegen_1._(templateObject_7 || (templateObject_7 = __makeTemplateObject(["", ".length"], ["", ".length"])), names_1["default"].vErrors));
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        var schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                var props = gen["var"]("props", codegen_1._(templateObject_8 || (templateObject_8 = __makeTemplateObject(["", ".evaluated.props"], ["", ".evaluated.props"])), source));
                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                var items = gen["var"]("items", codegen_1._(templateObject_9 || (templateObject_9 = __makeTemplateObject(["", ".evaluated.items"], ["", ".evaluated.items"])), source));
                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
        }
    }
}
exports.callRef = callRef;
exports["default"] = def;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9;
