"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
exports.validateTuple = void 0;
var codegen_1 = require("../../compile/codegen");
var util_1 = require("../../compile/util");
var code_1 = require("../code");
var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code: function (cxt) {
        var schema = cxt.schema, it = cxt.it;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if (util_1.alwaysValidSchema(it, schema))
            return;
        cxt.ok(code_1.validateArray(cxt));
    }
};
function validateTuple(cxt, extraItems, schArr) {
    if (schArr === void 0) { schArr = cxt.schema; }
    var gen = cxt.gen, parentSchema = cxt.parentSchema, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    var valid = gen.name("valid");
    var len = gen["const"]("len", codegen_1._(templateObject_1 || (templateObject_1 = __makeTemplateObject(["", ".length"], ["", ".length"])), data));
    schArr.forEach(function (sch, i) {
        if (util_1.alwaysValidSchema(it, sch))
            return;
        gen["if"](codegen_1._(templateObject_2 || (templateObject_2 = __makeTemplateObject(["", " > ", ""], ["", " > ", ""])), len, i), function () {
            return cxt.subschema({
                keyword: keyword,
                schemaProp: i,
                dataProp: i
            }, valid);
        });
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        var opts = it.opts, errSchemaPath = it.errSchemaPath;
        var l = schArr.length;
        var fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            var msg = "\"" + keyword + "\" is " + l + "-tuple, but minItems or maxItems/" + extraItems + " are not specified or different at path \"" + errSchemaPath + "\"";
            util_1.checkStrictMode(it, msg, opts.strictTuples);
        }
    }
}
exports.validateTuple = validateTuple;
exports["default"] = def;
var templateObject_1, templateObject_2;
