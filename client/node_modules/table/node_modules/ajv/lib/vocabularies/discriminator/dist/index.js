"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var codegen_1 = require("../../compile/codegen");
var types_1 = require("../discriminator/types");
var error = {
    message: function (_a) {
        var _b = _a.params, discrError = _b.discrError, tagName = _b.tagName;
        return discrError === types_1.DiscrError.Tag
            ? "tag \"" + tagName + "\" must be string"
            : "value of tag \"" + tagName + "\" must be in oneOf";
    },
    params: function (_a) {
        var _b = _a.params, discrError = _b.discrError, tag = _b.tag, tagName = _b.tagName;
        return codegen_1._(templateObject_1 || (templateObject_1 = __makeTemplateObject(["{error: ", ", tag: ", ", tagValue: ", "}"], ["{error: ", ", tag: ", ", tagValue: ", "}"])), discrError, tagName, tag);
    }
};
var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error,
    code: function (cxt) {
        var gen = cxt.gen, data = cxt.data, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
        var oneOf = parentSchema.oneOf;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        var tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        var valid = gen.let("valid", false);
        var tag = gen["const"]("tag", codegen_1._(templateObject_2 || (templateObject_2 = __makeTemplateObject(["", "", ""], ["", "", ""])), data, codegen_1.getProperty(tagName)));
        gen["if"](codegen_1._(templateObject_3 || (templateObject_3 = __makeTemplateObject(["typeof ", " == \"string\""], ["typeof ", " == \"string\""])), tag), function () { return validateMapping(); }, function () { return cxt.error(false, { discrError: types_1.DiscrError.Tag, tag: tag, tagName: tagName }); });
        cxt.ok(valid);
        function validateMapping() {
            var mapping = getMapping();
            gen["if"](false);
            for (var tagValue in mapping) {
                gen.elseIf(codegen_1._(templateObject_4 || (templateObject_4 = __makeTemplateObject(["", " === ", ""], ["", " === ", ""])), tag, tagValue));
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen["else"]();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag: tag, tagName: tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            var _valid = gen.name("valid");
            var schCxt = cxt.subschema({ keyword: "oneOf", schemaProp: schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            var oneOfMapping = {};
            var topRequired = hasRequired(parentSchema);
            var tagRequired = true;
            for (var i = 0; i < oneOf.length; i++) {
                var sch = oneOf[i];
                var propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error("discriminator: oneOf schemas must have \"properties/" + tagName + "\"");
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error("discriminator: \"" + tagName + "\" must be required");
            return oneOfMapping;
            function hasRequired(_a) {
                var required = _a.required;
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch["const"]) {
                    addMapping(sch["const"], i);
                }
                else if (sch["enum"]) {
                    for (var _i = 0, _a = sch["enum"]; _i < _a.length; _i++) {
                        var tagValue = _a[_i];
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error("discriminator: \"properties/" + tagName + "\" must have \"const\" or \"enum\"");
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error("discriminator: \"" + tagName + "\" values must be unique strings");
                }
                oneOfMapping[tagValue] = i;
            }
        }
    }
};
exports["default"] = def;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;
