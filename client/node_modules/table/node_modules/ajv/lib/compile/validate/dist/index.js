"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
var boolSchema_1 = require("./boolSchema");
var dataType_1 = require("./dataType");
var applicability_1 = require("./applicability");
var dataType_2 = require("./dataType");
var defaults_1 = require("./defaults");
var keyword_1 = require("./keyword");
var subschema_1 = require("./subschema");
var codegen_1 = require("../codegen");
var names_1 = require("../names");
var resolve_1 = require("../resolve");
var util_1 = require("../util");
var errors_1 = require("../errors");
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, function () { return boolSchema_1.topBoolOrEmptySchema(it); });
}
exports.validateFunctionCode = validateFunctionCode;
function validateFunction(_a, body) {
    var gen = _a.gen, validateName = _a.validateName, schema = _a.schema, schemaEnv = _a.schemaEnv, opts = _a.opts;
    if (opts.code.es5) {
        gen.func(validateName, codegen_1._(templateObject_1 || (templateObject_1 = __makeTemplateObject(["", ", ", ""], ["", ", ", ""])), names_1["default"].data, names_1["default"].valCxt), schemaEnv.$async, function () {
            gen.code(codegen_1._(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\"use strict\"; ", ""], ["\"use strict\"; ", ""])), funcSourceUrl(schema, opts)));
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, codegen_1._(templateObject_3 || (templateObject_3 = __makeTemplateObject(["", ", ", ""], ["", ", ", ""])), names_1["default"].data, destructureValCxt(opts)), schemaEnv.$async, function () {
            return gen.code(funcSourceUrl(schema, opts)).code(body);
        });
    }
}
function destructureValCxt(opts) {
    return codegen_1._(templateObject_5 || (templateObject_5 = __makeTemplateObject(["{", "=\"\", ", ", ", ", ", "=", "", "}={}"], ["{", "=\"\", ", ", ", ", ", "=",
        "", "}={}"])), names_1["default"].instancePath, names_1["default"].parentData, names_1["default"].parentDataProperty, names_1["default"].rootData, names_1["default"].data, opts.dynamicRef ? codegen_1._(templateObject_4 || (templateObject_4 = __makeTemplateObject([", ", "={}"], [", ", "={}"])), names_1["default"].dynamicAnchors) : codegen_1.nil);
}
function destructureValCxtES5(gen, opts) {
    gen["if"](names_1["default"].valCxt, function () {
        gen["var"](names_1["default"].instancePath, codegen_1._(templateObject_6 || (templateObject_6 = __makeTemplateObject(["", ".", ""], ["", ".", ""])), names_1["default"].valCxt, names_1["default"].instancePath));
        gen["var"](names_1["default"].parentData, codegen_1._(templateObject_7 || (templateObject_7 = __makeTemplateObject(["", ".", ""], ["", ".", ""])), names_1["default"].valCxt, names_1["default"].parentData));
        gen["var"](names_1["default"].parentDataProperty, codegen_1._(templateObject_8 || (templateObject_8 = __makeTemplateObject(["", ".", ""], ["", ".", ""])), names_1["default"].valCxt, names_1["default"].parentDataProperty));
        gen["var"](names_1["default"].rootData, codegen_1._(templateObject_9 || (templateObject_9 = __makeTemplateObject(["", ".", ""], ["", ".", ""])), names_1["default"].valCxt, names_1["default"].rootData));
        if (opts.dynamicRef)
            gen["var"](names_1["default"].dynamicAnchors, codegen_1._(templateObject_10 || (templateObject_10 = __makeTemplateObject(["", ".", ""], ["", ".", ""])), names_1["default"].valCxt, names_1["default"].dynamicAnchors));
    }, function () {
        gen["var"](names_1["default"].instancePath, codegen_1._(templateObject_11 || (templateObject_11 = __makeTemplateObject(["\"\""], ["\"\""]))));
        gen["var"](names_1["default"].parentData, codegen_1._(templateObject_12 || (templateObject_12 = __makeTemplateObject(["undefined"], ["undefined"]))));
        gen["var"](names_1["default"].parentDataProperty, codegen_1._(templateObject_13 || (templateObject_13 = __makeTemplateObject(["undefined"], ["undefined"]))));
        gen["var"](names_1["default"].rootData, names_1["default"].data);
        if (opts.dynamicRef)
            gen["var"](names_1["default"].dynamicAnchors, codegen_1._(templateObject_14 || (templateObject_14 = __makeTemplateObject(["{}"], ["{}"]))));
    });
}
function topSchemaObjCode(it) {
    var schema = it.schema, opts = it.opts, gen = it.gen;
    validateFunction(it, function () {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1["default"].vErrors, null);
        gen.let(names_1["default"].errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    var gen = it.gen, validateName = it.validateName;
    it.evaluated = gen["const"]("evaluated", codegen_1._(templateObject_15 || (templateObject_15 = __makeTemplateObject(["", ".evaluated"], ["", ".evaluated"])), validateName));
    gen["if"](codegen_1._(templateObject_16 || (templateObject_16 = __makeTemplateObject(["", ".dynamicProps"], ["", ".dynamicProps"])), it.evaluated), function () { return gen.assign(codegen_1._(templateObject_17 || (templateObject_17 = __makeTemplateObject(["", ".props"], ["", ".props"])), it.evaluated), codegen_1._(templateObject_18 || (templateObject_18 = __makeTemplateObject(["undefined"], ["undefined"])))); });
    gen["if"](codegen_1._(templateObject_19 || (templateObject_19 = __makeTemplateObject(["", ".dynamicItems"], ["", ".dynamicItems"])), it.evaluated), function () { return gen.assign(codegen_1._(templateObject_20 || (templateObject_20 = __makeTemplateObject(["", ".items"], ["", ".items"])), it.evaluated), codegen_1._(templateObject_21 || (templateObject_21 = __makeTemplateObject(["undefined"], ["undefined"])))); });
}
function funcSourceUrl(schema, opts) {
    var schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? codegen_1._(templateObject_22 || (templateObject_22 = __makeTemplateObject(["/*# sourceURL=", " */"], ["/*# sourceURL=", " */"])), schId) : codegen_1.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    boolSchema_1.boolOrEmptySchema(it, valid);
}
function schemaCxtHasRules(_a) {
    var schema = _a.schema, self = _a.self;
    if (typeof schema == "boolean")
        return !schema;
    for (var key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    var schema = it.schema, gen = it.gen, opts = it.opts;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    var errsCount = gen["const"]("_errs", names_1["default"].errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen["var"](valid, codegen_1._(templateObject_23 || (templateObject_23 = __makeTemplateObject(["", " === ", ""], ["", " === ", ""])), errsCount, names_1["default"].errors));
}
function checkKeywords(it) {
    util_1.checkUnknownRules(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
    var types = dataType_1.getSchemaTypes(it.schema);
    var checkedTypes = dataType_1.coerceAndCheckDataType(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    var schema = it.schema, errSchemaPath = it.errSchemaPath, opts = it.opts, self = it.self;
    if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {
        self.logger.warn("$ref: keywords ignored in schema at path \"" + errSchemaPath + "\"");
    }
}
function checkNoDefault(it) {
    var schema = it.schema, opts = it.opts;
    if (schema["default"] !== undefined && opts.useDefaults && opts.strictSchema) {
        util_1.checkStrictMode(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    var schId = it.schema[it.opts.schemaId];
    if (schId)
        it.baseId = resolve_1.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword(_a) {
    var gen = _a.gen, schemaEnv = _a.schemaEnv, schema = _a.schema, errSchemaPath = _a.errSchemaPath, opts = _a.opts;
    var msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code(codegen_1._(templateObject_24 || (templateObject_24 = __makeTemplateObject(["", ".logger.log(", ")"], ["", ".logger.log(", ")"])), names_1["default"].self, msg));
    }
    else if (typeof opts.$comment == "function") {
        var schemaPath = codegen_1.str(templateObject_25 || (templateObject_25 = __makeTemplateObject(["", "/$comment"], ["", "/$comment"])), errSchemaPath);
        var rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code(codegen_1._(templateObject_26 || (templateObject_26 = __makeTemplateObject(["", ".opts.$comment(", ", ", ", ", ".schema)"], ["", ".opts.$comment(", ", ", ", ", ".schema)"])), names_1["default"].self, msg, schemaPath, rootName));
    }
}
function returnResults(it) {
    var gen = it.gen, schemaEnv = it.schemaEnv, validateName = it.validateName, ValidationError = it.ValidationError, opts = it.opts;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen["if"](codegen_1._(templateObject_27 || (templateObject_27 = __makeTemplateObject(["", " === 0"], ["", " === 0"])), names_1["default"].errors), function () { return gen["return"](names_1["default"].data); }, function () { return gen["throw"](codegen_1._(templateObject_28 || (templateObject_28 = __makeTemplateObject(["new ", "(", ")"], ["new ", "(", ")"])), ValidationError, names_1["default"].vErrors)); });
    }
    else {
        gen.assign(codegen_1._(templateObject_29 || (templateObject_29 = __makeTemplateObject(["", ".errors"], ["", ".errors"])), validateName), names_1["default"].vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen["return"](codegen_1._(templateObject_30 || (templateObject_30 = __makeTemplateObject(["", " === 0"], ["", " === 0"])), names_1["default"].errors));
    }
}
function assignEvaluated(_a) {
    var gen = _a.gen, evaluated = _a.evaluated, props = _a.props, items = _a.items;
    if (props instanceof codegen_1.Name)
        gen.assign(codegen_1._(templateObject_31 || (templateObject_31 = __makeTemplateObject(["", ".props"], ["", ".props"])), evaluated), props);
    if (items instanceof codegen_1.Name)
        gen.assign(codegen_1._(templateObject_32 || (templateObject_32 = __makeTemplateObject(["", ".items"], ["", ".items"])), evaluated), items);
}
function schemaKeywords(it, types, typeErrors, errsCount) {
    var gen = it.gen, schema = it.schema, data = it.data, allErrors = it.allErrors, opts = it.opts, self = it.self;
    var RULES = self.RULES;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {
        gen.block(function () { return keywordCode(it, "$ref", RULES.all.$ref.definition); }); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(function () {
        for (var _i = 0, _a = RULES.rules; _i < _a.length; _i++) {
            var group = _a[_i];
            groupKeywords(group);
        }
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!applicability_1.shouldUseGroup(schema, group))
            return;
        if (group.type) {
            gen["if"](dataType_2.checkDataType(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen["else"]();
                dataType_2.reportTypeError(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen["if"](codegen_1._(templateObject_33 || (templateObject_33 = __makeTemplateObject(["", " === ", ""], ["", " === ", ""])), names_1["default"].errors, errsCount || 0));
    }
}
function iterateKeywords(it, group) {
    var gen = it.gen, schema = it.schema, useDefaults = it.opts.useDefaults;
    if (useDefaults)
        defaults_1.assignDefaults(it, group.type);
    gen.block(function () {
        for (var _i = 0, _a = group.rules; _i < _a.length; _i++) {
            var rule = _a[_i];
            if (applicability_1.shouldUseRule(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach(function (t) {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, "type \"" + t + "\" not allowed by context \"" + it.dataTypes.join(",") + "\"");
        }
    });
    it.dataTypes = it.dataTypes.filter(function (t) { return includesType(types, t); });
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    var rules = it.self.RULES.all;
    for (var keyword in rules) {
        var rule = rules[keyword];
        if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
            var type = rule.definition.type;
            if (type.length && !type.some(function (t) { return hasApplicableType(ts, t); })) {
                strictTypesError(it, "missing type \"" + type.join(",") + "\" for keyword \"" + keyword + "\"");
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function strictTypesError(it, msg) {
    var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += " at \"" + schemaPath + "\" (strictTypes)";
    util_1.checkStrictMode(it, msg, it.opts.strictTypes);
}
var KeywordCxt = /** @class */ (function () {
    function KeywordCxt(it, def, keyword) {
        keyword_1.validateKeywordUsage(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen["const"]("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(keyword + " value must be " + JSON.stringify(def.schemaType));
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen["const"]("_errs", names_1["default"].errors);
        }
    }
    KeywordCxt.prototype.result = function (condition, successAction, failAction) {
        this.failResult(codegen_1.not(condition), successAction, failAction);
    };
    KeywordCxt.prototype.failResult = function (condition, successAction, failAction) {
        this.gen["if"](condition);
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen["else"]();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen["else"]();
        }
    };
    KeywordCxt.prototype.pass = function (condition, failAction) {
        this.failResult(codegen_1.not(condition), undefined, failAction);
    };
    KeywordCxt.prototype.fail = function (condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen["if"](false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen["if"](condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen["else"]();
    };
    KeywordCxt.prototype.fail$data = function (condition) {
        if (!this.$data)
            return this.fail(condition);
        var schemaCode = this.schemaCode;
        this.fail(codegen_1._(templateObject_34 || (templateObject_34 = __makeTemplateObject(["", " !== undefined && (", ")"], ["", " !== undefined && (", ")"])), schemaCode, codegen_1.or(this.invalid$data(), condition)));
    };
    KeywordCxt.prototype.error = function (append, errorParams, errorPaths) {
        if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
        }
        this._error(append, errorPaths);
    };
    KeywordCxt.prototype._error = function (append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    };
    KeywordCxt.prototype.$dataError = function () {
        errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
    };
    KeywordCxt.prototype.reset = function () {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        errors_1.resetErrorsCount(this.gen, this.errsCount);
    };
    KeywordCxt.prototype.ok = function (cond) {
        if (!this.allErrors)
            this.gen["if"](cond);
    };
    KeywordCxt.prototype.setParams = function (obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    };
    KeywordCxt.prototype.block$data = function (valid, codeBlock, $dataValid) {
        var _this = this;
        if ($dataValid === void 0) { $dataValid = codegen_1.nil; }
        this.gen.block(function () {
            _this.check$data(valid, $dataValid);
            codeBlock();
        });
    };
    KeywordCxt.prototype.check$data = function (valid, $dataValid) {
        if (valid === void 0) { valid = codegen_1.nil; }
        if ($dataValid === void 0) { $dataValid = codegen_1.nil; }
        if (!this.$data)
            return;
        var _a = this, gen = _a.gen, schemaCode = _a.schemaCode, schemaType = _a.schemaType, def = _a.def;
        gen["if"](codegen_1.or(codegen_1._(templateObject_35 || (templateObject_35 = __makeTemplateObject(["", " === undefined"], ["", " === undefined"])), schemaCode), $dataValid));
        if (valid !== codegen_1.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
                gen.assign(valid, false);
        }
        gen["else"]();
    };
    KeywordCxt.prototype.invalid$data = function () {
        var _a = this, gen = _a.gen, schemaCode = _a.schemaCode, schemaType = _a.schemaType, def = _a.def, it = _a.it;
        return codegen_1.or(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name))
                    throw new Error("ajv implementation error");
                var st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return codegen_1._(templateObject_36 || (templateObject_36 = __makeTemplateObject(["", ""], ["", ""])), dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));
            }
            return codegen_1.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                var validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return codegen_1._(templateObject_37 || (templateObject_37 = __makeTemplateObject(["!", "(", ")"], ["!", "(", ")"])), validateSchemaRef, schemaCode);
            }
            return codegen_1.nil;
        }
    };
    KeywordCxt.prototype.subschema = function (appl, valid) {
        var subschema = subschema_1.getSubschema(this.it, appl);
        subschema_1.extendSubschemaData(subschema, this.it, appl);
        subschema_1.extendSubschemaMode(subschema, appl);
        var nextContext = __assign(__assign(__assign({}, this.it), subschema), { items: undefined, props: undefined });
        subschemaCode(nextContext, valid);
        return nextContext;
    };
    KeywordCxt.prototype.mergeEvaluated = function (schemaCxt, toName) {
        var _a = this, it = _a.it, gen = _a.gen;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    };
    KeywordCxt.prototype.mergeValidEvaluated = function (schemaCxt, valid) {
        var _this = this;
        var _a = this, it = _a.it, gen = _a.gen;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen["if"](valid, function () { return _this.mergeEvaluated(schemaCxt, codegen_1.Name); });
            return true;
        }
    };
    return KeywordCxt;
}());
exports.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword, def, ruleType) {
    var cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        keyword_1.funcKeywordCode(cxt, def);
    }
    else if ("macro" in def) {
        keyword_1.macroKeywordCode(cxt, def);
    }
    else if (def.compile || def.validate) {
        keyword_1.funcKeywordCode(cxt, def);
    }
}
var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, _a) {
    var dataLevel = _a.dataLevel, dataNames = _a.dataNames, dataPathArr = _a.dataPathArr;
    var jsonPointer;
    var data;
    if ($data === "")
        return names_1["default"].rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = names_1["default"].rootData;
    }
    else {
        var matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error("Invalid JSON-pointer: " + $data);
        var up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
        var segment = segments_1[_i];
        if (segment) {
            data = codegen_1._(templateObject_38 || (templateObject_38 = __makeTemplateObject(["", "", ""], ["", "", ""])), data, codegen_1.getProperty(util_1.unescapeJsonPointer(segment)));
            expr = codegen_1._(templateObject_39 || (templateObject_39 = __makeTemplateObject(["", " && ", ""], ["", " && ", ""])), expr, data);
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return "Cannot access " + pointerType + " " + up + " levels up, current level is " + dataLevel;
    }
}
exports.getData = getData;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13, templateObject_14, templateObject_15, templateObject_16, templateObject_17, templateObject_18, templateObject_19, templateObject_20, templateObject_21, templateObject_22, templateObject_23, templateObject_24, templateObject_25, templateObject_26, templateObject_27, templateObject_28, templateObject_29, templateObject_30, templateObject_31, templateObject_32, templateObject_33, templateObject_34, templateObject_35, templateObject_36, templateObject_37, templateObject_38, templateObject_39;
