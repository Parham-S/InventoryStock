"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapWord = void 0;

var slice_ansi_1 = __importDefault(require("slice-ansi"));

var strip_ansi_1 = __importDefault(require("strip-ansi"));

var calculateStringLengths = function calculateStringLengths(input, size) {
  var subject = strip_ansi_1["default"](input);
  var chunks = []; // https://regex101.com/r/gY5kZ1/1

  var re = new RegExp('(^.{1,' + String(size) + '}(\\s+|$))|(^.{1,' + String(size - 1) + '}(\\\\|/|_|\\.|,|;|-))');

  do {
    var chunk = void 0;
    var match = re.exec(subject);

    if (match) {
      chunk = match[0];
      subject = subject.slice(chunk.length);
      var trimmedLength = chunk.trim().length;
      var offset = chunk.length - trimmedLength;
      chunks.push([trimmedLength, offset]);
    } else {
      chunk = subject.slice(0, size);
      subject = subject.slice(size);
      chunks.push([chunk.length, 0]);
    }
  } while (subject.length);

  return chunks;
};

var wrapWord = function wrapWord(input, size) {
  var result = [];
  var startIndex = 0;
  calculateStringLengths(input, size).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        length = _ref2[0],
        offset = _ref2[1];

    result.push(slice_ansi_1["default"](input, startIndex, startIndex + length));
    startIndex += length + offset;
  });
  return result;
};

exports.wrapWord = wrapWord;