"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapDataUsingRowHeights = void 0;

var wrapCell_1 = require("./wrapCell");

var createEmptyStrings = function createEmptyStrings(length) {
  return new Array(length).fill('');
};

var padCellVertically = function padCellVertically(lines, rowHeight, columnConfig) {
  var verticalAlignment = columnConfig.verticalAlignment;
  var availableLines = rowHeight - lines.length;

  if (verticalAlignment === 'top') {
    return [].concat(_toConsumableArray(lines), _toConsumableArray(createEmptyStrings(availableLines)));
  }

  if (verticalAlignment === 'bottom') {
    return [].concat(_toConsumableArray(createEmptyStrings(availableLines)), _toConsumableArray(lines));
  }

  return [].concat(_toConsumableArray(createEmptyStrings(Math.floor(availableLines / 2))), _toConsumableArray(lines), _toConsumableArray(createEmptyStrings(Math.ceil(availableLines / 2))));
};

var flatten = function flatten(array) {
  var _ref;

  return (_ref = []).concat.apply(_ref, _toConsumableArray(array));
};

var mapDataUsingRowHeights = function mapDataUsingRowHeights(unmappedRows, rowHeights, config) {
  var tableWidth = unmappedRows[0].length;
  var mappedRows = unmappedRows.map(function (unmappedRow, unmappedRowIndex) {
    var outputRowHeight = rowHeights[unmappedRowIndex];
    var outputRow = Array.from({
      length: outputRowHeight
    }, function () {
      return new Array(tableWidth).fill('');
    });
    unmappedRow.forEach(function (cell, cellIndex) {
      var cellLines = wrapCell_1.wrapCell(cell, config.columns[cellIndex].width, config.columns[cellIndex].wrapWord);
      var paddedCellLines = padCellVertically(cellLines, outputRowHeight, config.columns[cellIndex]);
      paddedCellLines.forEach(function (cellLine, cellLineIndex) {
        outputRow[cellLineIndex][cellIndex] = cellLine;
      });
    });
    return outputRow;
  });
  return flatten(mappedRows);
};

exports.mapDataUsingRowHeights = mapDataUsingRowHeights;