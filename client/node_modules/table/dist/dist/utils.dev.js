"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distributeUnevenly = exports.countSpaceSequence = exports.groupBySizes = exports.makeBorderConfig = exports.splitAnsi = exports.normalizeString = void 0;

var slice_ansi_1 = __importDefault(require("slice-ansi"));

var string_width_1 = __importDefault(require("string-width"));

var strip_ansi_1 = __importDefault(require("strip-ansi"));

var getBorderCharacters_1 = require("./getBorderCharacters");
/**
 * Converts Windows-style newline to Unix-style
 *
 * @internal
 */


var normalizeString = function normalizeString(input) {
  return input.replace(/\r\n/g, '\n');
};

exports.normalizeString = normalizeString;
/**
 * Splits ansi string by newlines
 *
 * @internal
 */

var splitAnsi = function splitAnsi(input) {
  var lengths = strip_ansi_1["default"](input).split('\n').map(string_width_1["default"]);
  var result = [];
  var startIndex = 0;
  lengths.forEach(function (length) {
    result.push(length === 0 ? '' : slice_ansi_1["default"](input, startIndex, startIndex + length)); // Plus 1 for the newline character itself

    startIndex += length + 1;
  });
  return result;
};

exports.splitAnsi = splitAnsi;
/**
 * Merges user provided border characters with the default border ("honeywell") characters.
 *
 * @internal
 */

var makeBorderConfig = function makeBorderConfig(border) {
  return _objectSpread({}, getBorderCharacters_1.getBorderCharacters('honeywell'), {}, border);
};

exports.makeBorderConfig = makeBorderConfig;
/**
 * Groups the array into sub-arrays by sizes.
 *
 * @internal
 * @example
 * groupBySizes(['a', 'b', 'c', 'd', 'e'], [2, 1, 2]) = [ ['a', 'b'], ['c'], ['d', 'e'] ]
 */

var groupBySizes = function groupBySizes(array, sizes) {
  var startIndex = 0;
  return sizes.map(function (size) {
    var group = array.slice(startIndex, startIndex + size);
    startIndex += size;
    return group;
  });
};

exports.groupBySizes = groupBySizes;
/**
 * Counts the number of continuous spaces in a string
 *
 * @internal
 * @example
 * countGroupSpaces('a  bc  de f') = 3
 */

var countSpaceSequence = function countSpaceSequence(input) {
  var _a, _b;

  return (_b = (_a = input.match(/\s+/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
};

exports.countSpaceSequence = countSpaceSequence;
/**
 * Creates the non-increasing number array given sum and length
 * whose the difference between maximum and minimum is not greater than 1
 *
 * @internal
 * @example
 * distributeUnevenly(6, 3) = [2, 2, 2]
 * distributeUnevenly(8, 3) = [3, 3, 2]
 */

var distributeUnevenly = function distributeUnevenly(sum, length) {
  var result = Array.from({
    length: length
  }).fill(Math.floor(sum / length));
  return result.map(function (element, index) {
    return element + (index < sum % length ? 1 : 0);
  });
};

exports.distributeUnevenly = distributeUnevenly;