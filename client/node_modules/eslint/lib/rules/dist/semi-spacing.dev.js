/**
 * @fileoverview Validates spacing before and after semicolon
 * @author Mathias Schreck
 */
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after semicolons",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          "default": false
        },
        after: {
          type: "boolean",
          "default": true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
      unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
      missingWhitespaceBefore: "Missing whitespace before semicolon.",
      missingWhitespaceAfter: "Missing whitespace after semicolon."
    }
  },
  create: function create(context) {
    var config = context.options[0],
        sourceCode = context.getSourceCode();
    var requireSpaceBefore = false,
        requireSpaceAfter = true;

    if (_typeof(config) === "object") {
      requireSpaceBefore = config.before;
      requireSpaceAfter = config.after;
    }
    /**
     * Checks if a given token has leading whitespace.
     * @param {Object} token The token to check.
     * @returns {boolean} True if the given token has leading space, false if not.
     */


    function hasLeadingSpace(token) {
      var tokenBefore = sourceCode.getTokenBefore(token);
      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
    }
    /**
     * Checks if a given token has trailing whitespace.
     * @param {Object} token The token to check.
     * @returns {boolean} True if the given token has trailing space, false if not.
     */


    function hasTrailingSpace(token) {
      var tokenAfter = sourceCode.getTokenAfter(token);
      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
    }
    /**
     * Checks if the given token is the last token in its line.
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the token is the last in its line.
     */


    function isLastTokenInCurrentLine(token) {
      var tokenAfter = sourceCode.getTokenAfter(token);
      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
    }
    /**
     * Checks if the given token is the first token in its line
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the token is the first in its line.
     */


    function isFirstTokenInCurrentLine(token) {
      var tokenBefore = sourceCode.getTokenBefore(token);
      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
    }
    /**
     * Checks if the next token of a given token is a closing parenthesis.
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.
     */


    function isBeforeClosingParen(token) {
      var nextToken = sourceCode.getTokenAfter(token);
      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
    }
    /**
     * Report location example :
     *
     * for unexpected space `before`
     *
     * var a = 'b'   ;
     *            ^^^
     *
     * for unexpected space `after`
     *
     * var a = 'b';  c = 10;
     *             ^^
     *
     * Reports if the given token has invalid spacing.
     * @param {Token} token The semicolon token to check.
     * @param {ASTNode} node The corresponding node of the token.
     * @returns {void}
     */


    function checkSemicolonSpacing(token, node) {
      if (astUtils.isSemicolonToken(token)) {
        if (hasLeadingSpace(token)) {
          if (!requireSpaceBefore) {
            var tokenBefore = sourceCode.getTokenBefore(token);
            var loc = {
              start: tokenBefore.loc.end,
              end: token.loc.start
            };
            context.report({
              node: node,
              loc: loc,
              messageId: "unexpectedWhitespaceBefore",
              fix: function fix(fixer) {
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
              }
            });
          }
        } else {
          if (requireSpaceBefore) {
            var _loc = token.loc;
            context.report({
              node: node,
              loc: _loc,
              messageId: "missingWhitespaceBefore",
              fix: function fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }
            });
          }
        }

        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
          if (hasTrailingSpace(token)) {
            if (!requireSpaceAfter) {
              var tokenAfter = sourceCode.getTokenAfter(token);
              var _loc2 = {
                start: token.loc.end,
                end: tokenAfter.loc.start
              };
              context.report({
                node: node,
                loc: _loc2,
                messageId: "unexpectedWhitespaceAfter",
                fix: function fix(fixer) {
                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                }
              });
            }
          } else {
            if (requireSpaceAfter) {
              var _loc3 = token.loc;
              context.report({
                node: node,
                loc: _loc3,
                messageId: "missingWhitespaceAfter",
                fix: function fix(fixer) {
                  return fixer.insertTextAfter(token, " ");
                }
              });
            }
          }
        }
      }
    }
    /**
     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */


    function checkNode(node) {
      var token = sourceCode.getLastToken(node);
      checkSemicolonSpacing(token, node);
    }

    return {
      VariableDeclaration: checkNode,
      ExpressionStatement: checkNode,
      BreakStatement: checkNode,
      ContinueStatement: checkNode,
      DebuggerStatement: checkNode,
      DoWhileStatement: checkNode,
      ReturnStatement: checkNode,
      ThrowStatement: checkNode,
      ImportDeclaration: checkNode,
      ExportNamedDeclaration: checkNode,
      ExportAllDeclaration: checkNode,
      ExportDefaultDeclaration: checkNode,
      ForStatement: function ForStatement(node) {
        if (node.init) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
        }

        if (node.test) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
        }
      }
    };
  }
};