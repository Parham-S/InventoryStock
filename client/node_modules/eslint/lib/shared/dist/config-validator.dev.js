/*
 * STOP!!! DO NOT MODIFY.
 *
 * This file is part of the ongoing work to move the eslintrc-style config
 * system into the @eslint/eslintrc package. This file needs to remain
 * unchanged in order for this work to proceed.
 *
 * If you think you need to change this file, please contact @nzakas first.
 *
 * Thanks in advance for your cooperation.
 */

/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var util = require("util"),
    configSchema = require("../../conf/config-schema"),
    BuiltInEnvironments = require("@eslint/eslintrc/conf/environments"),
    BuiltInRules = require("../rules"),
    ConfigOps = require("@eslint/eslintrc/lib/shared/config-ops"),
    _require = require("./deprecation-warnings"),
    emitDeprecationWarning = _require.emitDeprecationWarning;

var ajv = require("./ajv")();

var ruleValidators = new WeakMap();
var noop = Function.prototype; //------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var validateSchema;
var severityMap = {
  error: 2,
  warn: 1,
  off: 0
};
/**
 * Gets a complete options schema for a rule.
 * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
 * @returns {Object} JSON Schema for the rule's options.
 */

function getRuleOptionsSchema(rule) {
  if (!rule) {
    return null;
  }

  var schema = rule.schema || rule.meta && rule.meta.schema; // Given a tuple of schemas, insert warning level at the beginning

  if (Array.isArray(schema)) {
    if (schema.length) {
      return {
        type: "array",
        items: schema,
        minItems: 0,
        maxItems: schema.length
      };
    }

    return {
      type: "array",
      minItems: 0,
      maxItems: 0
    };
  } // Given a full schema, leave it alone


  return schema || null;
}
/**
 * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
 * @param {options} options The given options for the rule.
 * @returns {number|string} The rule's severity value
 */


function validateRuleSeverity(options) {
  var severity = Array.isArray(options) ? options[0] : options;
  var normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

  if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
    return normSeverity;
  }

  throw new Error("\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '".concat(util.inspect(severity).replace(/'/g, "\"").replace(/\n/g, ""), "').\n"));
}
/**
 * Validates the non-severity options passed to a rule, based on its schema.
 * @param {{create: Function}} rule The rule to validate
 * @param {Array} localOptions The options for the rule, excluding severity
 * @returns {void}
 */


function validateRuleSchema(rule, localOptions) {
  if (!ruleValidators.has(rule)) {
    var schema = getRuleOptionsSchema(rule);

    if (schema) {
      ruleValidators.set(rule, ajv.compile(schema));
    }
  }

  var validateRule = ruleValidators.get(rule);

  if (validateRule) {
    validateRule(localOptions);

    if (validateRule.errors) {
      throw new Error(validateRule.errors.map(function (error) {
        return "\tValue ".concat(JSON.stringify(error.data), " ").concat(error.message, ".\n");
      }).join(""));
    }
  }
}
/**
 * Validates a rule's options against its schema.
 * @param {{create: Function}|null} rule The rule that the config is being validated for
 * @param {string} ruleId The rule's unique name.
 * @param {Array|number} options The given options for the rule.
 * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
 * no source is prepended to the message.
 * @returns {void}
 */


function validateRuleOptions(rule, ruleId, options) {
  var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  try {
    var severity = validateRuleSeverity(options);

    if (severity !== 0) {
      validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
    }
  } catch (err) {
    var enhancedMessage = "Configuration for rule \"".concat(ruleId, "\" is invalid:\n").concat(err.message);

    if (typeof source === "string") {
      throw new Error("".concat(source, ":\n\t").concat(enhancedMessage));
    } else {
      throw new Error(enhancedMessage);
    }
  }
}
/**
 * Validates an environment object
 * @param {Object} environment The environment config object to validate.
 * @param {string} source The name of the configuration source to report in any errors.
 * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
 * @returns {void}
 */


function validateEnvironment(environment, source) {
  var getAdditionalEnv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  // not having an environment is ok
  if (!environment) {
    return;
  }

  Object.keys(environment).forEach(function (id) {
    var env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;

    if (!env) {
      var message = "".concat(source, ":\n\tEnvironment key \"").concat(id, "\" is unknown\n");
      throw new Error(message);
    }
  });
}
/**
 * Validates a rules config object
 * @param {Object} rulesConfig The rules config object to validate.
 * @param {string} source The name of the configuration source to report in any errors.
 * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
 * @returns {void}
 */


function validateRules(rulesConfig, source) {
  var getAdditionalRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (!rulesConfig) {
    return;
  }

  Object.keys(rulesConfig).forEach(function (id) {
    var rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;
    validateRuleOptions(rule, id, rulesConfig[id], source);
  });
}
/**
 * Validates a `globals` section of a config file
 * @param {Object} globalsConfig The `globals` section
 * @param {string|null} source The name of the configuration source to report in the event of an error.
 * @returns {void}
 */


function validateGlobals(globalsConfig) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!globalsConfig) {
    return;
  }

  Object.entries(globalsConfig).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        configuredGlobal = _ref2[0],
        configuredValue = _ref2[1];

    try {
      ConfigOps.normalizeConfigGlobal(configuredValue);
    } catch (err) {
      throw new Error("ESLint configuration of global '".concat(configuredGlobal, "' in ").concat(source, " is invalid:\n").concat(err.message));
    }
  });
}
/**
 * Validate `processor` configuration.
 * @param {string|undefined} processorName The processor name.
 * @param {string} source The name of config file.
 * @param {function(id:string): Processor} getProcessor The getter of defined processors.
 * @returns {void}
 */


function validateProcessor(processorName, source, getProcessor) {
  if (processorName && !getProcessor(processorName)) {
    throw new Error("ESLint configuration of processor in '".concat(source, "' is invalid: '").concat(processorName, "' was not found."));
  }
}
/**
 * Formats an array of schema validation errors.
 * @param {Array} errors An array of error messages to format.
 * @returns {string} Formatted error message
 */


function formatErrors(errors) {
  return errors.map(function (error) {
    if (error.keyword === "additionalProperties") {
      var formattedPropertyPath = error.dataPath.length ? "".concat(error.dataPath.slice(1), ".").concat(error.params.additionalProperty) : error.params.additionalProperty;
      return "Unexpected top-level property \"".concat(formattedPropertyPath, "\"");
    }

    if (error.keyword === "type") {
      var formattedField = error.dataPath.slice(1);
      var formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
      var formattedValue = JSON.stringify(error.data);
      return "Property \"".concat(formattedField, "\" is the wrong type (expected ").concat(formattedExpectedType, " but got `").concat(formattedValue, "`)");
    }

    var field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
    return "\"".concat(field, "\" ").concat(error.message, ". Value: ").concat(JSON.stringify(error.data));
  }).map(function (message) {
    return "\t- ".concat(message, ".\n");
  }).join("");
}
/**
 * Validates the top level properties of the config object.
 * @param {Object} config The config object to validate.
 * @param {string} source The name of the configuration source to report in any errors.
 * @returns {void}
 */


function validateConfigSchema(config) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  validateSchema = validateSchema || ajv.compile(configSchema);

  if (!validateSchema(config)) {
    throw new Error("ESLint configuration in ".concat(source, " is invalid:\n").concat(formatErrors(validateSchema.errors)));
  }

  if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
    emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
  }
}
/**
 * Validates an entire config object.
 * @param {Object} config The config object to validate.
 * @param {string} source The name of the configuration source to report in any errors.
 * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
 * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
 * @returns {void}
 */


function validate(config, source, getAdditionalRule, getAdditionalEnv) {
  validateConfigSchema(config, source);
  validateRules(config.rules, source, getAdditionalRule);
  validateEnvironment(config.env, source, getAdditionalEnv);
  validateGlobals(config.globals, source);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (config.overrides || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var override = _step.value;
      validateRules(override.rules, source, getAdditionalRule);
      validateEnvironment(override.env, source, getAdditionalEnv);
      validateGlobals(config.globals, source);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var validated = new WeakSet();
/**
 * Validate config array object.
 * @param {ConfigArray} configArray The config array to validate.
 * @returns {void}
 */

function validateConfigArray(configArray) {
  var getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
  var getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
  var getPluginRule = Map.prototype.get.bind(configArray.pluginRules); // Validate.

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = configArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var element = _step2.value;

      if (validated.has(element)) {
        continue;
      }

      validated.add(element);
      validateEnvironment(element.env, element.name, getPluginEnv);
      validateGlobals(element.globals, element.name);
      validateProcessor(element.processor, element.name, getPluginProcessor);
      validateRules(element.rules, element.name, getPluginRule);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


module.exports = {
  getRuleOptionsSchema: getRuleOptionsSchema,
  validate: validate,
  validateConfigArray: validateConfigArray,
  validateConfigSchema: validateConfigSchema,
  validateRuleOptions: validateRuleOptions
};