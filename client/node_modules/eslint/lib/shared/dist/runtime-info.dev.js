/**
 * @fileoverview Utility to get information about the execution environment.
 * @author Kai Cataldo
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var path = require("path");

var spawn = require("cross-spawn");

var os = require("os");

var log = require("../shared/logging");

var packageJson = require("../../package.json"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Generates and returns execution environment information.
 * @returns {string} A string that contains execution environment information.
 */


function environment() {
  var cache = new Map();
  /**
   * Checks if a path is a child of a directory.
   * @param {string} parentPath The parent path to check.
   * @param {string} childPath The path to check.
   * @returns {boolean} Whether or not the given path is a child of a directory.
   */

  function isChildOfDirectory(parentPath, childPath) {
    return !path.relative(parentPath, childPath).startsWith("..");
  }
  /**
   * Synchronously executes a shell command and formats the result.
   * @param {string} cmd The command to execute.
   * @param {Array} args The arguments to be executed with the command.
   * @returns {string} The version returned by the command.
   */


  function execCommand(cmd, args) {
    var key = [cmd].concat(_toConsumableArray(args)).join(" ");

    if (cache.has(key)) {
      return cache.get(key);
    }

    var process = spawn.sync(cmd, args, {
      encoding: "utf8"
    });

    if (process.error) {
      throw process.error;
    }

    var result = process.stdout.trim();
    cache.set(key, result);
    return result;
  }
  /**
   * Normalizes a version number.
   * @param {string} versionStr The string to normalize.
   * @returns {string} The normalized version number.
   */


  function normalizeVersionStr(versionStr) {
    return versionStr.startsWith("v") ? versionStr : "v".concat(versionStr);
  }
  /**
   * Gets bin version.
   * @param {string} bin The bin to check.
   * @returns {string} The normalized version returned by the command.
   */


  function getBinVersion(bin) {
    var binArgs = ["--version"];

    try {
      return normalizeVersionStr(execCommand(bin, binArgs));
    } catch (e) {
      log.error("Error finding ".concat(bin, " version running the command `").concat(bin, " ").concat(binArgs.join(" "), "`"));
      throw e;
    }
  }
  /**
   * Gets installed npm package version.
   * @param {string} pkg The package to check.
   * @param {boolean} global Whether to check globally or not.
   * @returns {string} The normalized version returned by the command.
   */


  function getNpmPackageVersion(pkg) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$global = _ref.global,
        global = _ref$global === void 0 ? false : _ref$global;

    var npmBinArgs = ["bin", "-g"];
    var npmLsArgs = ["ls", "--depth=0", "--json", "eslint"];

    if (global) {
      npmLsArgs.push("-g");
    }

    try {
      var parsedStdout = JSON.parse(execCommand("npm", npmLsArgs));
      /*
       * Checking globally returns an empty JSON object, while local checks
       * include the name and version of the local project.
       */

      if (Object.keys(parsedStdout).length === 0 || !(parsedStdout.dependencies && parsedStdout.dependencies.eslint)) {
        return "Not found";
      }

      var _process$argv = _slicedToArray(process.argv, 2),
          processBinPath = _process$argv[1];

      var npmBinPath;

      try {
        npmBinPath = execCommand("npm", npmBinArgs);
      } catch (e) {
        log.error("Error finding npm binary path when running command `npm ".concat(npmBinArgs.join(" "), "`"));
        throw e;
      }

      var isGlobal = isChildOfDirectory(npmBinPath, processBinPath);
      var pkgVersion = parsedStdout.dependencies.eslint.version;

      if (global && isGlobal || !global && !isGlobal) {
        pkgVersion += " (Currently used)";
      }

      return normalizeVersionStr(pkgVersion);
    } catch (e) {
      log.error("Error finding ".concat(pkg, " version running the command `npm ").concat(npmLsArgs.join(" "), "`"));
      throw e;
    }
  }

  return ["Environment Info:", "", "Node version: ".concat(getBinVersion("node")), "npm version: ".concat(getBinVersion("npm")), "Local ESLint version: ".concat(getNpmPackageVersion("eslint", {
    global: false
  })), "Global ESLint version: ".concat(getNpmPackageVersion("eslint", {
    global: true
  })), "Operating System: ".concat(os.platform(), " ").concat(os.release())].join("\n");
}
/**
 * Returns version of currently executing ESLint.
 * @returns {string} The version from the currently executing ESLint's package.json.
 */


function version() {
  return "v".concat(packageJson.version);
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


module.exports = {
  environment: environment,
  version: version
};