'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = _interopDefault(require('postcss'));

var valueParser = _interopDefault(require('postcss-values-parser'));

var index = postcss.plugin('postcss-double-position-gradients', function (opts) {
  var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;
  return function (root) {
    // walk every declaration
    root.walkDecls(function (decl) {
      var originalValue = decl.value; // if the declaration value contains a gradient

      if (gradientFunctionRegExp.test(originalValue)) {
        var ast = valueParser(originalValue).parse(); // walk every function in the declaration value

        ast.walkFunctionNodes(function (fn) {
          // if the function is a gradient
          if (gradientFunctionNameRegExp.test(fn.value)) {
            var nodes = fn.nodes.slice(1, -1); // walk every argument to the function

            nodes.forEach(function (node, index) {
              var node1back = Object(nodes[index - 1]);
              var node2back = Object(nodes[index - 2]);
              var isDoublePositionLength = node2back.type && node1back.type === 'number' && node.type === 'number'; // if the argument concludes a double-position gradient

              if (isDoublePositionLength) {
                // insert the fallback colors
                var color = node2back.clone();
                var comma = valueParser.comma({
                  value: ',',
                  raws: {
                    after: ' '
                  }
                });
                fn.insertBefore(node, comma);
                fn.insertBefore(node, color);
              }
            });
          }
        });
        var modifiedValue = ast.toString(); // if the value has changed due to double-position gradients

        if (originalValue !== modifiedValue) {
          // add the fallback value
          decl.cloneBefore({
            value: modifiedValue
          }); // conditionally remove the double-position gradient

          if (!preserve) {
            decl.remove();
          }
        }
      }
    });
  };
});
var gradientFunctionRegExp = /(repeating-)?(conic|linear|radial)-gradient\([\W\w]*\)/i;
var gradientFunctionNameRegExp = /^(repeating-)?(conic|linear|radial)-gradient$/i;
module.exports = index;