'use strict';

var _require = require('util'),
    promisify = _require.promisify;

var fs = require('fs');

var path = require('path');

var fastGlob = require('fast-glob');

var gitIgnore = require('ignore');

var slash = require('slash');

var DEFAULT_IGNORE = ['**/node_modules/**', '**/flow-typed/**', '**/coverage/**', '**/.git'];
var readFileP = promisify(fs.readFile);

var mapGitIgnorePatternTo = function mapGitIgnorePatternTo(base) {
  return function (ignore) {
    if (ignore.startsWith('!')) {
      return '!' + path.posix.join(base, ignore.slice(1));
    }

    return path.posix.join(base, ignore);
  };
};

var parseGitIgnore = function parseGitIgnore(content, options) {
  var base = slash(path.relative(options.cwd, path.dirname(options.fileName)));
  return content.split(/\r?\n/).filter(Boolean).filter(function (line) {
    return !line.startsWith('#');
  }).map(mapGitIgnorePatternTo(base));
};

var reduceIgnore = function reduceIgnore(files) {
  return files.reduce(function (ignores, file) {
    ignores.add(parseGitIgnore(file.content, {
      cwd: file.cwd,
      fileName: file.filePath
    }));
    return ignores;
  }, gitIgnore());
};

var ensureAbsolutePathForCwd = function ensureAbsolutePathForCwd(cwd, p) {
  cwd = slash(cwd);

  if (path.isAbsolute(p)) {
    if (p.startsWith(cwd)) {
      return p;
    }

    throw new Error("Path ".concat(p, " is not in cwd ").concat(cwd));
  }

  return path.join(cwd, p);
};

var getIsIgnoredPredecate = function getIsIgnoredPredecate(ignores, cwd) {
  return function (p) {
    return ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));
  };
};

var getFile = function getFile(file, cwd) {
  var filePath, content;
  return regeneratorRuntime.async(function getFile$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          filePath = path.join(cwd, file);
          _context.next = 3;
          return regeneratorRuntime.awrap(readFileP(filePath, 'utf8'));

        case 3:
          content = _context.sent;
          return _context.abrupt("return", {
            cwd: cwd,
            filePath: filePath,
            content: content
          });

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
};

var getFileSync = function getFileSync(file, cwd) {
  var filePath = path.join(cwd, file);
  var content = fs.readFileSync(filePath, 'utf8');
  return {
    cwd: cwd,
    filePath: filePath,
    content: content
  };
};

var normalizeOptions = function normalizeOptions() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ignore = _ref.ignore,
      ignore = _ref$ignore === void 0 ? [] : _ref$ignore,
      _ref$cwd = _ref.cwd,
      cwd = _ref$cwd === void 0 ? slash(process.cwd()) : _ref$cwd;

  return {
    ignore: ignore,
    cwd: cwd
  };
};

module.exports = function _callee(options) {
  var paths, files, ignores;
  return regeneratorRuntime.async(function _callee$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = normalizeOptions(options);
          _context2.next = 3;
          return regeneratorRuntime.awrap(fastGlob('**/.gitignore', {
            ignore: DEFAULT_IGNORE.concat(options.ignore),
            cwd: options.cwd
          }));

        case 3:
          paths = _context2.sent;
          _context2.next = 6;
          return regeneratorRuntime.awrap(Promise.all(paths.map(function (file) {
            return getFile(file, options.cwd);
          })));

        case 6:
          files = _context2.sent;
          ignores = reduceIgnore(files);
          return _context2.abrupt("return", getIsIgnoredPredecate(ignores, options.cwd));

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports.sync = function (options) {
  options = normalizeOptions(options);
  var paths = fastGlob.sync('**/.gitignore', {
    ignore: DEFAULT_IGNORE.concat(options.ignore),
    cwd: options.cwd
  });
  var files = paths.map(function (file) {
    return getFileSync(file, options.cwd);
  });
  var ignores = reduceIgnore(files);
  return getIsIgnoredPredecate(ignores, options.cwd);
};