/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var address = require('address');

var fs = require('fs');

var path = require('path');

var url = require('url');

var chalk = require('chalk');

var detect = require('detect-port-alt');

var isRoot = require('is-root');

var prompts = require('prompts');

var clearConsole = require('./clearConsole');

var formatWebpackMessages = require('./formatWebpackMessages');

var getProcessForPort = require('./getProcessForPort');

var typescriptFormatter = require('./typescriptFormatter');

var forkTsCheckerWebpackPlugin = require('./ForkTsCheckerWebpackPlugin');

var isInteractive = process.stdout.isTTY;

function prepareUrls(protocol, host, port) {
  var pathname = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';

  var formatUrl = function formatUrl(hostname) {
    return url.format({
      protocol: protocol,
      hostname: hostname,
      port: port,
      pathname: pathname
    });
  };

  var prettyPrintUrl = function prettyPrintUrl(hostname) {
    return url.format({
      protocol: protocol,
      hostname: hostname,
      port: chalk.bold(port),
      pathname: pathname
    });
  };

  var isUnspecifiedHost = host === '0.0.0.0' || host === '::';
  var prettyHost, lanUrlForConfig, lanUrlForTerminal;

  if (isUnspecifiedHost) {
    prettyHost = 'localhost';

    try {
      // This can only return an IPv4 address
      lanUrlForConfig = address.ip();

      if (lanUrlForConfig) {
        // Check if the address is a private ip
        // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
        if (/^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(lanUrlForConfig)) {
          // Address is private, format it for later use
          lanUrlForTerminal = prettyPrintUrl(lanUrlForConfig);
        } else {
          // Address is not private, so we will discard it
          lanUrlForConfig = undefined;
        }
      }
    } catch (_e) {// ignored
    }
  } else {
    prettyHost = host;
  }

  var localUrlForTerminal = prettyPrintUrl(prettyHost);
  var localUrlForBrowser = formatUrl(prettyHost);
  return {
    lanUrlForConfig: lanUrlForConfig,
    lanUrlForTerminal: lanUrlForTerminal,
    localUrlForTerminal: localUrlForTerminal,
    localUrlForBrowser: localUrlForBrowser
  };
}

function printInstructions(appName, urls, useYarn) {
  console.log();
  console.log("You can now view ".concat(chalk.bold(appName), " in the browser."));
  console.log();

  if (urls.lanUrlForTerminal) {
    console.log("  ".concat(chalk.bold('Local:'), "            ").concat(urls.localUrlForTerminal));
    console.log("  ".concat(chalk.bold('On Your Network:'), "  ").concat(urls.lanUrlForTerminal));
  } else {
    console.log("  ".concat(urls.localUrlForTerminal));
  }

  console.log();
  console.log('Note that the development build is not optimized.');
  console.log("To create a production build, use " + "".concat(chalk.cyan("".concat(useYarn ? 'yarn' : 'npm run', " build")), "."));
  console.log();
}

function createCompiler(_ref) {
  var appName = _ref.appName,
      config = _ref.config,
      devSocket = _ref.devSocket,
      urls = _ref.urls,
      useYarn = _ref.useYarn,
      useTypeScript = _ref.useTypeScript,
      tscCompileOnError = _ref.tscCompileOnError,
      webpack = _ref.webpack;
  // "Compiler" is a low-level interface to webpack.
  // It lets us listen to some events and provide our own custom messages.
  var compiler;

  try {
    compiler = webpack(config);
  } catch (err) {
    console.log(chalk.red('Failed to compile.'));
    console.log();
    console.log(err.message || err);
    console.log();
    process.exit(1);
  } // "invalid" event fires when you have changed a file, and webpack is
  // recompiling a bundle. WebpackDevServer takes care to pause serving the
  // bundle, so if you refresh, it'll wait instead of serving the old one.
  // "invalid" is short for "bundle invalidated", it doesn't imply any errors.


  compiler.hooks.invalid.tap('invalid', function () {
    if (isInteractive) {
      clearConsole();
    }

    console.log('Compiling...');
  });
  var isFirstCompile = true;
  var tsMessagesPromise;
  var tsMessagesResolver;

  if (useTypeScript) {
    compiler.hooks.beforeCompile.tap('beforeCompile', function () {
      tsMessagesPromise = new Promise(function (resolve) {
        tsMessagesResolver = function tsMessagesResolver(msgs) {
          return resolve(msgs);
        };
      });
    });
    forkTsCheckerWebpackPlugin.getCompilerHooks(compiler).receive.tap('afterTypeScriptCheck', function (diagnostics, lints) {
      var allMsgs = [].concat(_toConsumableArray(diagnostics), _toConsumableArray(lints));

      var format = function format(message) {
        return "".concat(message.file, "\n").concat(typescriptFormatter(message, true));
      };

      tsMessagesResolver({
        errors: allMsgs.filter(function (msg) {
          return msg.severity === 'error';
        }).map(format),
        warnings: allMsgs.filter(function (msg) {
          return msg.severity === 'warning';
        }).map(format)
      });
    });
  } // "done" event fires when webpack has finished recompiling the bundle.
  // Whether or not you have warnings or errors, you will get this event.


  compiler.hooks.done.tap('done', function _callee(stats) {
    var statsData, _statsData$warnings2, _stats$compilation$wa2, delayedMsg, _messages, _statsData$warnings, _statsData$errors, _stats$compilation$wa, _stats$compilation$er, messages, isSuccessful;

    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (isInteractive) {
              clearConsole();
            } // We have switched off the default webpack output in WebpackDevServer
            // options so we are going to "massage" the warnings and errors and present
            // them in a readable focused way.
            // We only construct the warnings and errors for speed:
            // https://github.com/facebook/create-react-app/issues/4492#issuecomment-421959548


            statsData = stats.toJson({
              all: false,
              warnings: true,
              errors: true
            });

            if (!(useTypeScript && statsData.errors.length === 0)) {
              _context.next = 14;
              break;
            }

            delayedMsg = setTimeout(function () {
              console.log(chalk.yellow('Files successfully emitted, waiting for typecheck results...'));
            }, 100);
            _context.next = 6;
            return regeneratorRuntime.awrap(tsMessagesPromise);

          case 6:
            _messages = _context.sent;
            clearTimeout(delayedMsg);

            if (tscCompileOnError) {
              (_statsData$warnings = statsData.warnings).push.apply(_statsData$warnings, _toConsumableArray(_messages.errors));
            } else {
              (_statsData$errors = statsData.errors).push.apply(_statsData$errors, _toConsumableArray(_messages.errors));
            }

            (_statsData$warnings2 = statsData.warnings).push.apply(_statsData$warnings2, _toConsumableArray(_messages.warnings)); // Push errors and warnings into compilation result
            // to show them after page refresh triggered by user.


            if (tscCompileOnError) {
              (_stats$compilation$wa = stats.compilation.warnings).push.apply(_stats$compilation$wa, _toConsumableArray(_messages.errors));
            } else {
              (_stats$compilation$er = stats.compilation.errors).push.apply(_stats$compilation$er, _toConsumableArray(_messages.errors));
            }

            (_stats$compilation$wa2 = stats.compilation.warnings).push.apply(_stats$compilation$wa2, _toConsumableArray(_messages.warnings));

            if (_messages.errors.length > 0) {
              if (tscCompileOnError) {
                devSocket.warnings(_messages.errors);
              } else {
                devSocket.errors(_messages.errors);
              }
            } else if (_messages.warnings.length > 0) {
              devSocket.warnings(_messages.warnings);
            }

            if (isInteractive) {
              clearConsole();
            }

          case 14:
            messages = formatWebpackMessages(statsData);
            isSuccessful = !messages.errors.length && !messages.warnings.length;

            if (isSuccessful) {
              console.log(chalk.green('Compiled successfully!'));
            }

            if (isSuccessful && (isInteractive || isFirstCompile)) {
              printInstructions(appName, urls, useYarn);
            }

            isFirstCompile = false; // If errors exist, only show errors.

            if (!messages.errors.length) {
              _context.next = 24;
              break;
            }

            // Only keep the first error. Others are often indicative
            // of the same problem, but confuse the reader with noise.
            if (messages.errors.length > 1) {
              messages.errors.length = 1;
            }

            console.log(chalk.red('Failed to compile.\n'));
            console.log(messages.errors.join('\n\n'));
            return _context.abrupt("return");

          case 24:
            // Show warnings if no errors were found.
            if (messages.warnings.length) {
              console.log(chalk.yellow('Compiled with warnings.\n'));
              console.log(messages.warnings.join('\n\n')); // Teach some ESLint tricks.

              console.log('\nSearch for the ' + chalk.underline(chalk.yellow('keywords')) + ' to learn more about each warning.');
              console.log('To ignore, add ' + chalk.cyan('// eslint-disable-next-line') + ' to the line before.\n');
            }

          case 25:
          case "end":
            return _context.stop();
        }
      }
    });
  }); // You can safely remove this after ejecting.
  // We only use this block for testing of Create React App itself:

  var isSmokeTest = process.argv.some(function (arg) {
    return arg.indexOf('--smoke-test') > -1;
  });

  if (isSmokeTest) {
    compiler.hooks.failed.tap('smokeTest', function _callee2() {
      return regeneratorRuntime.async(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return regeneratorRuntime.awrap(tsMessagesPromise);

            case 2:
              process.exit(1);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      });
    });
    compiler.hooks.done.tap('smokeTest', function _callee3(stats) {
      return regeneratorRuntime.async(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return regeneratorRuntime.awrap(tsMessagesPromise);

            case 2:
              if (stats.hasErrors() || stats.hasWarnings()) {
                process.exit(1);
              } else {
                process.exit(0);
              }

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      });
    });
  }

  return compiler;
}

function resolveLoopback(proxy) {
  var o = url.parse(proxy);
  o.host = undefined;

  if (o.hostname !== 'localhost') {
    return proxy;
  } // Unfortunately, many languages (unlike node) do not yet support IPv6.
  // This means even though localhost resolves to ::1, the application
  // must fall back to IPv4 (on 127.0.0.1).
  // We can re-enable this in a few years.

  /*try {
    o.hostname = address.ipv6() ? '::1' : '127.0.0.1';
  } catch (_ignored) {
    o.hostname = '127.0.0.1';
  }*/


  try {
    // Check if we're on a network; if we are, chances are we can resolve
    // localhost. Otherwise, we can just be safe and assume localhost is
    // IPv4 for maximum compatibility.
    if (!address.ip()) {
      o.hostname = '127.0.0.1';
    }
  } catch (_ignored) {
    o.hostname = '127.0.0.1';
  }

  return url.format(o);
} // We need to provide a custom onError function for httpProxyMiddleware.
// It allows us to log custom error messages on the console.


function onProxyError(proxy) {
  return function (err, req, res) {
    var host = req.headers && req.headers.host;
    console.log(chalk.red('Proxy error:') + ' Could not proxy request ' + chalk.cyan(req.url) + ' from ' + chalk.cyan(host) + ' to ' + chalk.cyan(proxy) + '.');
    console.log('See https://nodejs.org/api/errors.html#errors_common_system_errors for more information (' + chalk.cyan(err.code) + ').');
    console.log(); // And immediately send the proper error response to the client.
    // Otherwise, the request will eventually timeout with ERR_EMPTY_RESPONSE on the client side.

    if (res.writeHead && !res.headersSent) {
      res.writeHead(500);
    }

    res.end('Proxy error: Could not proxy request ' + req.url + ' from ' + host + ' to ' + proxy + ' (' + err.code + ').');
  };
}

function prepareProxy(proxy, appPublicFolder, servedPathname) {
  // `proxy` lets you specify alternate servers for specific requests.
  if (!proxy) {
    return undefined;
  }

  if (typeof proxy !== 'string') {
    console.log(chalk.red('When specified, "proxy" in package.json must be a string.'));
    console.log(chalk.red('Instead, the type of "proxy" was "' + _typeof(proxy) + '".'));
    console.log(chalk.red('Either remove "proxy" from package.json, or make it a string.'));
    process.exit(1);
  } // If proxy is specified, let it handle any request except for
  // files in the public folder and requests to the WebpackDevServer socket endpoint.
  // https://github.com/facebook/create-react-app/issues/6720


  var sockPath = process.env.WDS_SOCKET_PATH || '/sockjs-node';
  var isDefaultSockHost = !process.env.WDS_SOCKET_HOST;

  function mayProxy(pathname) {
    var maybePublicPath = path.resolve(appPublicFolder, pathname.replace(new RegExp('^' + servedPathname), ''));
    var isPublicFileRequest = fs.existsSync(maybePublicPath); // used by webpackHotDevClient

    var isWdsEndpointRequest = isDefaultSockHost && pathname.startsWith(sockPath);
    return !(isPublicFileRequest || isWdsEndpointRequest);
  }

  if (!/^http(s)?:\/\//.test(proxy)) {
    console.log(chalk.red('When "proxy" is specified in package.json it must start with either http:// or https://'));
    process.exit(1);
  }

  var target;

  if (process.platform === 'win32') {
    target = resolveLoopback(proxy);
  } else {
    target = proxy;
  }

  return [{
    target: target,
    logLevel: 'silent',
    // For single page apps, we generally want to fallback to /index.html.
    // However we also want to respect `proxy` for API calls.
    // So if `proxy` is specified as a string, we need to decide which fallback to use.
    // We use a heuristic: We want to proxy all the requests that are not meant
    // for static assets and as all the requests for static assets will be using
    // `GET` method, we can proxy all non-`GET` requests.
    // For `GET` requests, if request `accept`s text/html, we pick /index.html.
    // Modern browsers include text/html into `accept` header when navigating.
    // However API calls like `fetch()` won’t generally accept text/html.
    // If this heuristic doesn’t work well for you, use `src/setupProxy.js`.
    context: function context(pathname, req) {
      return req.method !== 'GET' || mayProxy(pathname) && req.headers.accept && req.headers.accept.indexOf('text/html') === -1;
    },
    onProxyReq: function onProxyReq(proxyReq) {
      // Browsers may send Origin headers even with same-origin
      // requests. To prevent CORS issues, we have to change
      // the Origin to match the target URL.
      if (proxyReq.getHeader('origin')) {
        proxyReq.setHeader('origin', target);
      }
    },
    onError: onProxyError(target),
    secure: false,
    changeOrigin: true,
    ws: true,
    xfwd: true
  }];
}

function choosePort(host, defaultPort) {
  return detect(defaultPort, host).then(function (port) {
    return new Promise(function (resolve) {
      if (port === defaultPort) {
        return resolve(port);
      }

      var message = process.platform !== 'win32' && defaultPort < 1024 && !isRoot() ? "Admin permissions are required to run a server on a port below 1024." : "Something is already running on port ".concat(defaultPort, ".");

      if (isInteractive) {
        clearConsole();
        var existingProcess = getProcessForPort(defaultPort);
        var question = {
          type: 'confirm',
          name: 'shouldChangePort',
          message: chalk.yellow(message + "".concat(existingProcess ? " Probably:\n  ".concat(existingProcess) : '')) + '\n\nWould you like to run the app on another port instead?',
          initial: true
        };
        prompts(question).then(function (answer) {
          if (answer.shouldChangePort) {
            resolve(port);
          } else {
            resolve(null);
          }
        });
      } else {
        console.log(chalk.red(message));
        resolve(null);
      }
    });
  }, function (err) {
    throw new Error(chalk.red("Could not find an open port at ".concat(chalk.bold(host), ".")) + '\n' + ('Network error message: ' + err.message || err) + '\n');
  });
}

module.exports = {
  choosePort: choosePort,
  createCompiler: createCompiler,
  prepareProxy: prepareProxy,
  prepareUrls: prepareUrls
};