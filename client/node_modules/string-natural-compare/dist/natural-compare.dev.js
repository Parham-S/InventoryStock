'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var defaultAlphabetIndexMap = [];

function isNumberCode(code) {
  return code >= 48
  /* '0' */
  && code <= 57
  /* '9' */
  ;
}

function naturalCompare(a, b, opts) {
  if (typeof a !== 'string') {
    throw new TypeError("The first argument must be a string. Received type '".concat(_typeof(a), "'"));
  }

  if (typeof b !== 'string') {
    throw new TypeError("The second argument must be a string. Received type '".concat(_typeof(b), "'"));
  }

  var lengthA = a.length;
  var lengthB = b.length;
  var indexA = 0;
  var indexB = 0;
  var alphabetIndexMap = defaultAlphabetIndexMap;
  var firstDifferenceInLeadingZeros = 0;

  if (opts) {
    if (opts.caseInsensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }

    if (opts.alphabet) {
      alphabetIndexMap = buildAlphabetIndexMap(opts.alphabet);
    }
  }

  while (indexA < lengthA && indexB < lengthB) {
    var charCodeA = a.charCodeAt(indexA);
    var charCodeB = b.charCodeAt(indexB);

    if (isNumberCode(charCodeA)) {
      if (!isNumberCode(charCodeB)) {
        return charCodeA - charCodeB;
      }

      var numStartA = indexA;
      var numStartB = indexB;

      while (charCodeA === 48
      /* '0' */
      && ++numStartA < lengthA) {
        charCodeA = a.charCodeAt(numStartA);
      }

      while (charCodeB === 48
      /* '0' */
      && ++numStartB < lengthB) {
        charCodeB = b.charCodeAt(numStartB);
      }

      if (numStartA !== numStartB && firstDifferenceInLeadingZeros === 0) {
        firstDifferenceInLeadingZeros = numStartA - numStartB;
      }

      var numEndA = numStartA;
      var numEndB = numStartB;

      while (numEndA < lengthA && isNumberCode(a.charCodeAt(numEndA))) {
        ++numEndA;
      }

      while (numEndB < lengthB && isNumberCode(b.charCodeAt(numEndB))) {
        ++numEndB;
      }

      var difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length

      if (difference !== 0) {
        return difference;
      }

      while (numStartA < numEndA) {
        difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);

        if (difference !== 0) {
          return difference;
        }
      }

      indexA = numEndA;
      indexB = numEndB;
      continue;
    }

    if (charCodeA !== charCodeB) {
      if (charCodeA < alphabetIndexMap.length && charCodeB < alphabetIndexMap.length && alphabetIndexMap[charCodeA] !== -1 && alphabetIndexMap[charCodeB] !== -1) {
        return alphabetIndexMap[charCodeA] - alphabetIndexMap[charCodeB];
      }

      return charCodeA - charCodeB;
    }

    ++indexA;
    ++indexB;
  }

  if (indexA < lengthA) {
    // `b` is a substring of `a`
    return 1;
  }

  if (indexB < lengthB) {
    // `a` is a substring of `b`
    return -1;
  }

  return firstDifferenceInLeadingZeros;
}

var alphabetIndexMapCache = {};

function buildAlphabetIndexMap(alphabet) {
  var existingMap = alphabetIndexMapCache[alphabet];

  if (existingMap !== undefined) {
    return existingMap;
  }

  var indexMap = [];
  var maxCharCode = alphabet.split('').reduce(function (maxCode, _char) {
    return Math.max(maxCode, _char.charCodeAt(0));
  }, 0);

  for (var i = 0; i <= maxCharCode; i++) {
    indexMap.push(-1);
  }

  for (var _i = 0; _i < alphabet.length; _i++) {
    indexMap[alphabet.charCodeAt(_i)] = _i;
  }

  alphabetIndexMapCache[alphabet] = indexMap;
  return indexMap;
}

module.exports = naturalCompare;