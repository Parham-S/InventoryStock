'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require('path');

var pathType = require('path-type');

var getExtensions = function getExtensions(extensions) {
  return extensions.length > 1 ? "{".concat(extensions.join(','), "}") : extensions[0];
};

var getPath = function getPath(filepath, cwd) {
  var pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
  return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
};

var addExtensions = function addExtensions(file, extensions) {
  if (path.extname(file)) {
    return "**/".concat(file);
  }

  return "**/".concat(file, ".").concat(getExtensions(extensions));
};

var getGlob = function getGlob(directory, options) {
  if (options.files && !Array.isArray(options.files)) {
    throw new TypeError("Expected `files` to be of type `Array` but received type `".concat(_typeof(options.files), "`"));
  }

  if (options.extensions && !Array.isArray(options.extensions)) {
    throw new TypeError("Expected `extensions` to be of type `Array` but received type `".concat(_typeof(options.extensions), "`"));
  }

  if (options.files && options.extensions) {
    return options.files.map(function (x) {
      return path.posix.join(directory, addExtensions(x, options.extensions));
    });
  }

  if (options.files) {
    return options.files.map(function (x) {
      return path.posix.join(directory, "**/".concat(x));
    });
  }

  if (options.extensions) {
    return [path.posix.join(directory, "**/*.".concat(getExtensions(options.extensions)))];
  }

  return [path.posix.join(directory, '**')];
};

module.exports = function _callee2(input, options) {
  var globs;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = _objectSpread({
            cwd: process.cwd()
          }, options);

          if (!(typeof options.cwd !== 'string')) {
            _context2.next = 3;
            break;
          }

          throw new TypeError("Expected `cwd` to be of type `string` but received type `".concat(_typeof(options.cwd), "`"));

        case 3:
          _context2.next = 5;
          return regeneratorRuntime.awrap(Promise.all([].concat(input).map(function _callee(x) {
            var isDirectory;
            return regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return regeneratorRuntime.awrap(pathType.isDirectory(getPath(x, options.cwd)));

                  case 2:
                    isDirectory = _context.sent;
                    return _context.abrupt("return", isDirectory ? getGlob(x, options) : x);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            });
          })));

        case 5:
          globs = _context2.sent;
          return _context2.abrupt("return", [].concat.apply([], globs));

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports.sync = function (input, options) {
  options = _objectSpread({
    cwd: process.cwd()
  }, options);

  if (typeof options.cwd !== 'string') {
    throw new TypeError("Expected `cwd` to be of type `string` but received type `".concat(_typeof(options.cwd), "`"));
  }

  var globs = [].concat(input).map(function (x) {
    return pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x;
  });
  return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};