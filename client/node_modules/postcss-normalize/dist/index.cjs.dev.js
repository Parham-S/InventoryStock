"use strict";

var _create;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var postcss = _interopDefault(require('postcss'));

var postcssBrowserComments = _interopDefault(require('postcss-browser-comments'));

var Module = _interopDefault(require('module'));

var path = _interopDefault(require('path'));

var fs = _interopDefault(require('fs'));

var assign = function assign() {
  return Object.assign.apply(Object, arguments);
};

var create = function create() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return assign.apply(void 0, [Object.create(null)].concat(objects));
};

var currentFilename = __filename;
var currentDirname = path.dirname(currentFilename); // get resolved filenames for css libraries

var normalizeCSS = resolve('@csstools/normalize.css');
var normalizeOpinionatedCSS = resolve('@csstools/normalize.css/opinionated.css');
var sanitizeCSS = resolve('sanitize.css');
var sanitizeFormsCSS = resolve('sanitize.css/forms.css');
var sanitizePageCSS = resolve('sanitize.css/page.css');
var sanitizeTypographyCSS = resolve('sanitize.css/typography.css'); // export a hashmap of css library filenames

var parsableFilenames = create((_create = {}, _defineProperty(_create, normalizeCSS, true), _defineProperty(_create, normalizeOpinionatedCSS, true), _defineProperty(_create, sanitizeCSS, true), _defineProperty(_create, sanitizeFormsCSS, true), _defineProperty(_create, sanitizePageCSS, true), _defineProperty(_create, sanitizeTypographyCSS, true), _create)); // export a hashmap of css library filenames by id

var resolvedFilenamesById = create({
  'normalize': [normalizeCSS],
  'normalize/opinionated': [normalizeOpinionatedCSS],
  'normalize/*': [normalizeOpinionatedCSS],
  'sanitize': [sanitizeCSS],
  'sanitize/forms': [sanitizeCSS, sanitizeFormsCSS],
  'sanitize/page': [sanitizeCSS, sanitizePageCSS],
  'sanitize/typography': [sanitizeCSS, sanitizeTypographyCSS],
  'sanitize/*': [sanitizeCSS, sanitizeFormsCSS, sanitizePageCSS, sanitizeTypographyCSS]
}); // get the resolved filename of a package/module

function resolve(id) {
  return resolve[id] = resolve[id] || Module._resolveFilename(id, {
    id: currentFilename,
    filename: currentFilename,
    paths: Module._nodeModulePaths(currentDirname)
  });
}

var cache = create();

function readFile(filename) {
  return regeneratorRuntime.async(function readFile$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          filename = path.resolve(filename);
          cache[filename] = cache[filename] || create();
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            return fs.stat(filename, function (statsError, _ref) {
              var mtime = _ref.mtime;
              return statsError ? reject(statsError) : mtime === cache[filename].mtime ? resolve(cache[filename].data) : fs.readFile(filename, 'utf8', function (readFileError, data) {
                return readFileError ? reject(readFileError) : resolve((cache[filename] = {
                  data: data,
                  mtime: mtime
                }).data);
              });
            });
          }));

        case 3:
        case "end":
          return _context.stop();
      }
    }
  });
}

var cache$1 = create(null);

var parse = function parse(filename, transformer) {
  return readFile(filename).then( // cache the parsed css root
  function (css) {
    return cache$1[css] = cache$1[css] || postcss.parse(css, {
      from: filename
    });
  }).then( // clone the cached root
  function (root) {
    return root.clone();
  }).then( // transform the cloned root
  function (clone) {
    return Promise.resolve(transformer(clone)).then( // resolve the cloned root
    function () {
      return clone;
    });
  });
};

var postcssImportNormalize = function postcssImportNormalize(commentsTransformer) {
  return function (opts) {
    opts = create(opts); // return an postcss-import configuration

    return create({
      load: function load(filename, importOptions) {
        return filename in parsableFilenames // parse the file (the file and css are conservatively cached)
        ? parse(filename, commentsTransformer).then(function (root) {
          return root.toResult({
            to: filename,
            map: true
          }).css;
        }) : typeof opts.load === 'function' // otherwise, use the override loader
        ? opts.load.call(null, filename, importOptions) // otherwise, return the (conservatively cached) contents of the file
        : readFile(filename);
      },
      resolve: function resolve(id, basedir, importOptions) {
        // get the css id by removing css extensions
        var cssId = id.replace(cssExtRegExp, '');
        return cssId in resolvedFilenamesById // return the known resolved path for the css id
        ? resolvedFilenamesById[cssId] : typeof opts.resolve === 'function' // otherwise, use the override resolver
        ? opts.resolve.call(null, id, basedir, importOptions) // otherwise, return the id to be resolved by postcss-import
        : id;
      }
    });
  };
};

var cssExtRegExp = /\.css\b/g;

var postcssPlugin = function postcssPlugin(commentsTransformer, opts) {
  return function (root) {
    var promises = [];
    var insertedFilenames = {}; // use @import insertion point

    root.walkAtRules(importRegExp, function (atrule) {
      // get name as a fallback value for the library (e.g. @import-normalize is like @import "normalize.css")
      var name = atrule.name.match(importRegExp)[1]; // get url from "library", 'library', url("library"), url('library'), or the fallback value

      var url = (atrule.params.match(paramsRegExp) || []).slice(1).find(function (part) {
        return part;
      }) || name;

      if (url) {
        // get the css id by removing css extensions
        var cssId = url.replace(cssExtRegExp$1, '');

        if (cssId in resolvedFilenamesById) {
          // promise the library import is replaced with its contents
          promises.push(Promise.all(resolvedFilenamesById[cssId].filter( // ignore filenames that have already been inserted
          function (filename) {
            return insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames);
          }).map( // parse the file (the file and css are conservatively cached)
          function (filename) {
            return parse(filename, commentsTransformer);
          })).then(function (roots) {
            if (roots.length) {
              // combine all the library nodes returned by the parsed files
              var nodes = roots.reduce(function (all, root) {
                return all.concat(root.nodes);
              }, []); // replace the import with all the library nodes

              atrule.replaceWith.apply(atrule, _toConsumableArray(nodes));
            }
          }));
        }
      }
    });
    return Promise.all([].concat( // promise the library imports are replaced with their contents
    promises, // promise certain libraries are prepended
    Promise.all([].concat(opts.forceImport || []).reduce( // filter the id to be a known id or boolean true
    function (all, id) {
      if (id === true) {
        all.push.apply(all, _toConsumableArray(resolvedFilenamesById.normalize));
      } else if (typeof id === 'string') {
        var cssId = id.replace(cssExtRegExp$1, '');

        if (cssId in resolvedFilenamesById) {
          all.push.apply(all, _toConsumableArray(resolvedFilenamesById[cssId]));
        }
      }

      return all;
    }, []).filter( // ignore filenames that have already been inserted
    function (filename) {
      return insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames);
    }).map( // parse the file (the file and css are conservatively cached)
    function (filename) {
      return parse(filename, commentsTransformer);
    })).then(function (roots) {
      if (roots.length) {
        // combine all the library nodes returned by the parsed files
        var nodes = roots.reduce(function (all, root) {
          return all.concat(root.nodes);
        }, []); // prepend the stylesheet with all the library nodes

        root.prepend.apply(root, _toConsumableArray(nodes));
      }
    })));
  };
};

var cssExtRegExp$1 = /\.css\b/g;
var importRegExp = /^import(?:-(normalize|sanitize))?$/;
var paramsRegExp = /^\s*(?:url\((?:"(.+)"|'(.+)')\)|"(.+)"|'(.+)')[\W\w]*$/;
var index = postcss.plugin('postcss-normalize', function (opts) {
  opts = create(opts);
  var commentsTransformer = postcssBrowserComments(opts);
  var normalizeTransformer = postcssPlugin(commentsTransformer, opts);
  var postcssImportConfig = postcssImportNormalize(commentsTransformer);
  return assign(normalizeTransformer, {
    postcssImport: postcssImportConfig
  });
});
module.exports = index;