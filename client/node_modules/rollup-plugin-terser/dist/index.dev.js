"use strict";

var _require = require("@babel/code-frame"),
    codeFrameColumns = _require.codeFrameColumns;

var Worker = require("jest-worker")["default"];

var serialize = require("serialize-javascript");

var _require2 = require("rollup-pluginutils"),
    createFilter = _require2.createFilter;

function terser() {
  var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (userOptions.sourceMap != null) {
    throw Error("sourceMap option is removed, use sourcemap instead");
  }

  var filter = createFilter(userOptions.include, userOptions.exclude, {
    resolve: false
  });
  return {
    name: "terser",
    renderChunk: function renderChunk(code, chunk, outputOptions) {
      var _this = this;

      if (!filter(chunk.fileName)) {
        return null;
      }

      if (!this.worker) {
        this.worker = new Worker(require.resolve("./transform.js"), {
          numWorkers: userOptions.numWorkers
        });
        this.numOfBundles = 0;
      }

      this.numOfBundles++;
      var defaultOptions = {
        sourceMap: userOptions.sourcemap !== false
      };

      if (outputOptions.format === "es" || outputOptions.format === "esm") {
        defaultOptions.module = true;
      }

      if (outputOptions.format === "cjs") {
        defaultOptions.toplevel = true;
      } // TODO rewrite with object spread after dropping node v6


      var normalizedOptions = Object.assign({}, defaultOptions, userOptions); // remove plugin specific options

      for (var _i = 0, _arr = ["include", "exclude", "sourcemap", "numWorkers"]; _i < _arr.length; _i++) {
        var key = _arr[_i];

        if (normalizedOptions.hasOwnProperty(key)) {
          delete normalizedOptions[key];
        }
      }

      var serializedOptions = serialize(normalizedOptions);
      var result = this.worker.transform(code, serializedOptions)["catch"](function (error) {
        var message = error.message,
            line = error.line,
            column = error.col;
        console.error(codeFrameColumns(code, {
          start: {
            line: line,
            column: column
          }
        }, {
          message: message
        }));
        throw error;
      });

      var handler = function handler() {
        _this.numOfBundles--;

        if (_this.numOfBundles === 0) {
          _this.worker.end();

          _this.worker = 0;
        }
      };

      result.then(handler, handler);
      return result.then(function (result) {
        if (result.nameCache) {
          var _userOptions$nameCach = userOptions.nameCache,
              vars = _userOptions$nameCach.vars,
              props = _userOptions$nameCach.props; // only assign nameCache.vars if it was provided, and if terser produced values:

          if (vars) {
            var newVars = result.nameCache.vars && result.nameCache.vars.props;

            if (newVars) {
              vars.props = vars.props || {};
              Object.assign(vars.props, newVars);
            }
          } // support populating an empty nameCache object:


          if (!props) {
            props = userOptions.nameCache.props = {};
          } // merge updated props into original nameCache object:


          var newProps = result.nameCache.props && result.nameCache.props.props;

          if (newProps) {
            props.props = props.props || {};
            Object.assign(props.props, newProps);
          }
        }

        return result.result;
      });
    }
  };
}

exports.terser = terser;