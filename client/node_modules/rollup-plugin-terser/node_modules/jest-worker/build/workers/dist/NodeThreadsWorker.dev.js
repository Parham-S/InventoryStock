'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _stream() {
  var data = require('stream');

  _stream = function _stream() {
    return data;
  };

  return data;
}

function _worker_threads() {
  var data = require('worker_threads');

  _worker_threads = function _worker_threads() {
    return data;
  };

  return data;
}

function _mergeStream() {
  var data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function _mergeStream() {
    return data;
  };

  return data;
}

var _types = require('../types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var ExperimentalWorker =
/*#__PURE__*/
function () {
  function ExperimentalWorker(options) {
    _classCallCheck(this, ExperimentalWorker);

    _defineProperty(this, '_worker', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_onProcessEnd', void 0);

    _defineProperty(this, '_request', void 0);

    _defineProperty(this, '_retries', void 0);

    _defineProperty(this, '_stderr', void 0);

    _defineProperty(this, '_stdout', void 0);

    _defineProperty(this, '_fakeStream', void 0);

    this._options = options;
    this._request = null;
    this._stderr = null;
    this._stdout = null;
    this._fakeStream = null;
    this.initialize();
  }

  _createClass(ExperimentalWorker, [{
    key: "initialize",
    value: function initialize() {
      this._worker = new (_worker_threads().Worker)(_path()["default"].resolve(__dirname, './threadChild.js'), {
        eval: false,
        stderr: true,
        stdout: true,
        workerData: _objectSpread({
          cwd: process.cwd(),
          env: _objectSpread({}, process.env, {
            JEST_WORKER_ID: String(this._options.workerId + 1) // 0-indexed workerId, 1-indexed JEST_WORKER_ID

          }),
          // Suppress --debug / --inspect flags while preserving others (like --harmony).
          execArgv: process.execArgv.filter(function (v) {
            return !/^--(debug|inspect)/.test(v);
          }),
          silent: true
        }, this._options.forkOptions)
      });

      if (this._worker.stdout) {
        if (!this._stdout) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stdout = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stdout.add(this._worker.stdout);
      }

      if (this._worker.stderr) {
        if (!this._stderr) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stderr = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stderr.add(this._worker.stderr);
      }

      this._worker.on('message', this.onMessage.bind(this));

      this._worker.on('exit', this.onExit.bind(this));

      this._worker.postMessage([_types.CHILD_MESSAGE_INITIALIZE, false, this._options.workerPath, this._options.setupArgs]);

      this._retries++; // If we exceeded the amount of retries, we will emulate an error reply
      // coming from the child. This avoids code duplication related with cleaning
      // the queue, and scheduling the next call.

      if (this._retries > this._options.maxRetries) {
        var error = new Error('Call retries were exceeded');
        this.onMessage([_types.PARENT_MESSAGE_CLIENT_ERROR, error.name, error.message, error.stack, {
          type: 'WorkerError'
        }]);
      }
    }
  }, {
    key: "_shutdown",
    value: function _shutdown() {
      // End the permanent stream so the merged stream end too
      if (this._fakeStream) {
        this._fakeStream.end();

        this._fakeStream = null;
      }
    }
  }, {
    key: "onMessage",
    value: function onMessage(response) {
      var error;

      switch (response[0]) {
        case _types.PARENT_MESSAGE_OK:
          this._onProcessEnd(null, response[1]);

          break;

        case _types.PARENT_MESSAGE_CLIENT_ERROR:
          error = response[4];

          if (error != null && _typeof(error) === 'object') {
            var extra = error; // @ts-ignore: no index

            var NativeCtor = global[response[1]];
            var Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;
            error = new Ctor(response[2]);
            error.type = response[1];
            error.stack = response[3];

            for (var key in extra) {
              // @ts-ignore: no index
              error[key] = extra[key];
            }
          }

          this._onProcessEnd(error, null);

          break;

        case _types.PARENT_MESSAGE_SETUP_ERROR:
          error = new Error('Error when calling setup: ' + response[2]); // @ts-ignore: adding custom properties to errors.

          error.type = response[1];
          error.stack = response[3];

          this._onProcessEnd(error, null);

          break;

        default:
          throw new TypeError('Unexpected response from worker: ' + response[0]);
      }
    }
  }, {
    key: "onExit",
    value: function onExit(exitCode) {
      if (exitCode !== 0) {
        this.initialize();

        if (this._request) {
          this._worker.postMessage(this._request);
        }
      } else {
        this._shutdown();
      }
    }
  }, {
    key: "send",
    value: function send(request, onProcessStart, onProcessEnd) {
      var _this = this;

      onProcessStart(this);

      this._onProcessEnd = function () {
        // Clean the request to avoid sending past requests to workers that fail
        // while waiting for a new request (timers, unhandled rejections...)
        _this._request = null;
        return onProcessEnd.apply(void 0, arguments);
      };

      this._request = request;
      this._retries = 0;

      this._worker.postMessage(request);
    }
  }, {
    key: "getWorkerId",
    value: function getWorkerId() {
      return this._options.workerId;
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._stdout;
    }
  }, {
    key: "getStderr",
    value: function getStderr() {
      return this._stderr;
    }
  }, {
    key: "_getFakeStream",
    value: function _getFakeStream() {
      if (!this._fakeStream) {
        this._fakeStream = new (_stream().PassThrough)();
      }

      return this._fakeStream;
    }
  }]);

  return ExperimentalWorker;
}();

exports["default"] = ExperimentalWorker;