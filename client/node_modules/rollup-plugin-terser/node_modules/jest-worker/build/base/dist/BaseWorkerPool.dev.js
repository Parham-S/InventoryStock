'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _mergeStream() {
  var data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function _mergeStream() {
    return data;
  };

  return data;
}

var _types = require('../types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* istanbul ignore next */


var emptyMethod = function emptyMethod() {};

var BaseWorkerPool =
/*#__PURE__*/
function () {
  function BaseWorkerPool(workerPath, options) {
    _classCallCheck(this, BaseWorkerPool);

    _defineProperty(this, '_stderr', void 0);

    _defineProperty(this, '_stdout', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_workers', void 0);

    this._options = options;
    this._workers = new Array(options.numWorkers);

    if (!_path()["default"].isAbsolute(workerPath)) {
      workerPath = require.resolve(workerPath);
    }

    var stdout = (0, _mergeStream()["default"])();
    var stderr = (0, _mergeStream()["default"])();
    var forkOptions = options.forkOptions,
        maxRetries = options.maxRetries,
        setupArgs = options.setupArgs;

    for (var i = 0; i < options.numWorkers; i++) {
      var workerOptions = {
        forkOptions: forkOptions,
        maxRetries: maxRetries,
        setupArgs: setupArgs,
        workerId: i,
        workerPath: workerPath
      };
      var worker = this.createWorker(workerOptions);
      var workerStdout = worker.getStdout();
      var workerStderr = worker.getStderr();

      if (workerStdout) {
        stdout.add(workerStdout);
      }

      if (workerStderr) {
        stderr.add(workerStderr);
      }

      this._workers[i] = worker;
    }

    this._stdout = stdout;
    this._stderr = stderr;
  }

  _createClass(BaseWorkerPool, [{
    key: "getStderr",
    value: function getStderr() {
      return this._stderr;
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._stdout;
    }
  }, {
    key: "getWorkers",
    value: function getWorkers() {
      return this._workers;
    }
  }, {
    key: "getWorkerById",
    value: function getWorkerById(workerId) {
      return this._workers[workerId];
    }
  }, {
    key: "createWorker",
    value: function createWorker(_workerOptions) {
      throw Error('Missing method createWorker in WorkerPool');
    }
  }, {
    key: "end",
    value: function end() {
      // We do not cache the request object here. If so, it would only be only
      // processed by one of the workers, and we want them all to close.
      for (var i = 0; i < this._workers.length; i++) {
        this._workers[i].send([_types.CHILD_MESSAGE_END, false], emptyMethod, emptyMethod);
      }
    }
  }]);

  return BaseWorkerPool;
}();

exports["default"] = BaseWorkerPool;