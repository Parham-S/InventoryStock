"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _webpack = _interopRequireWildcard(require("webpack"));

var _schemaUtils = _interopRequireDefault(require("schema-utils"));

var _CssModuleFactory = _interopRequireDefault(require("./CssModuleFactory"));

var _CssDependencyTemplate = _interopRequireDefault(require("./CssDependencyTemplate"));

var _CssDependency = _interopRequireDefault(require("./CssDependency"));

var _pluginOptions = _interopRequireDefault(require("./plugin-options.json"));

var _utils = require("./utils");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/* eslint-disable class-methods-use-this */
// webpack 5 exposes the sources property to ensure the right version of webpack-sources is used


var _ref = // eslint-disable-next-line global-require
_webpack["default"].sources || require('webpack-sources'),
    ConcatSource = _ref.ConcatSource,
    SourceMapSource = _ref.SourceMapSource,
    OriginalSource = _ref.OriginalSource;

var _webpack$default = _webpack["default"],
    Template = _webpack$default.Template,
    createHash = _webpack$default.util.createHash;
var isWebpack4 = _webpack.version[0] === '4';
var pluginName = 'mini-css-extract-plugin';
var REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/i;
var REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/i;
var REGEXP_NAME = /\[name\]/i;
var REGEXP_PLACEHOLDERS = /\[(name|id|chunkhash)\]/g;
var DEFAULT_FILENAME = '[name].css';

var MiniCssExtractPlugin =
/*#__PURE__*/
function () {
  function MiniCssExtractPlugin() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MiniCssExtractPlugin);

    (0, _schemaUtils["default"])(_pluginOptions["default"], options, 'Mini CSS Extract Plugin');
    this.options = Object.assign({
      filename: DEFAULT_FILENAME,
      moduleFilename: function moduleFilename() {
        return _this.options.filename || DEFAULT_FILENAME;
      },
      ignoreOrder: false
    }, options);

    if (!this.options.chunkFilename) {
      var filename = this.options.filename; // Anything changing depending on chunk is fine

      if (filename.match(REGEXP_PLACEHOLDERS)) {
        this.options.chunkFilename = filename;
      } else {
        // Elsewise prefix '[id].' in front of the basename to make it changing
        this.options.chunkFilename = filename.replace(/(^|\/)([^/]*(?:\?|$))/, '$1[id].$2');
      }
    }

    if (!isWebpack4 && 'hmr' in this.options) {
      throw new Error("The 'hmr' option doesn't exist for the mini-css-extract-plugin when using webpack 5 (it's automatically determined)");
    }
  }
  /** @param {import("webpack").Compiler} compiler */


  _createClass(MiniCssExtractPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this2 = this;

      if (!isWebpack4) {
        var splitChunks = compiler.options.optimization.splitChunks;

        if (splitChunks) {
          if (splitChunks.defaultSizeTypes.includes('...')) {
            splitChunks.defaultSizeTypes.push(_utils.MODULE_TYPE);
          }
        }
      }

      compiler.hooks.thisCompilation.tap(pluginName, function (compilation) {
        compilation.dependencyFactories.set(_CssDependency["default"], new _CssModuleFactory["default"]());
        compilation.dependencyTemplates.set(_CssDependency["default"], new _CssDependencyTemplate["default"]());

        if (isWebpack4) {
          compilation.mainTemplate.hooks.renderManifest.tap(pluginName, function (result, _ref2) {
            var chunk = _ref2.chunk;
            var chunkGraph = compilation.chunkGraph;
            var renderedModules = Array.from(_this2.getChunkModules(chunk, chunkGraph)).filter(function (module) {
              return module.type === _utils.MODULE_TYPE;
            });

            var filenameTemplate = chunk.filenameTemplate || function (_ref3) {
              var chunkData = _ref3.chunk;
              return _this2.options.moduleFilename(chunkData);
            };

            if (renderedModules.length > 0) {
              result.push({
                render: function render() {
                  return _this2.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
                },
                filenameTemplate: filenameTemplate,
                pathOptions: {
                  chunk: chunk,
                  contentHashType: _utils.MODULE_TYPE
                },
                identifier: "".concat(pluginName, ".").concat(chunk.id),
                hash: chunk.contentHash[_utils.MODULE_TYPE]
              });
            }
          });
          compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, function (result, _ref4) {
            var chunk = _ref4.chunk;
            var chunkGraph = compilation.chunkGraph;
            var renderedModules = Array.from(_this2.getChunkModules(chunk, chunkGraph)).filter(function (module) {
              return module.type === _utils.MODULE_TYPE;
            });
            var filenameTemplate = chunk.filenameTemplate || _this2.options.chunkFilename;

            if (renderedModules.length > 0) {
              result.push({
                render: function render() {
                  return _this2.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
                },
                filenameTemplate: filenameTemplate,
                pathOptions: {
                  chunk: chunk,
                  contentHashType: _utils.MODULE_TYPE
                },
                identifier: "".concat(pluginName, ".").concat(chunk.id),
                hash: chunk.contentHash[_utils.MODULE_TYPE]
              });
            }
          });
        } else {
          compilation.hooks.renderManifest.tap(pluginName, function (result, _ref5) {
            var chunk = _ref5.chunk;
            var chunkGraph = compilation.chunkGraph; // We don't need hot update chunks for css
            // We will use the real asset instead to update

            if (chunk instanceof _webpack["default"].HotUpdateChunk) return;
            var renderedModules = Array.from(_this2.getChunkModules(chunk, chunkGraph)).filter(function (module) {
              return module.type === _utils.MODULE_TYPE;
            });
            var filenameTemplate = chunk.canBeInitial() ? function (_ref6) {
              var chunkData = _ref6.chunk;
              return _this2.options.moduleFilename(chunkData);
            } : _this2.options.chunkFilename;

            if (renderedModules.length > 0) {
              result.push({
                render: function render() {
                  return _this2.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
                },
                filenameTemplate: filenameTemplate,
                pathOptions: {
                  chunk: chunk,
                  contentHashType: _utils.MODULE_TYPE
                },
                identifier: "".concat(pluginName, ".").concat(chunk.id),
                hash: chunk.contentHash[_utils.MODULE_TYPE]
              });
            }
          });
        }
        /*
         * For webpack 5 this will be unneeded once the logic uses a RuntimeModule
         * as the content of runtime modules is hashed and added to the chunk hash automatically
         * */


        if (isWebpack4) {
          compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, function (hash, chunk) {
            var chunkFilename = _this2.options.chunkFilename;

            if (REGEXP_CHUNKHASH.test(chunkFilename)) {
              hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
            }

            if (REGEXP_CONTENTHASH.test(chunkFilename)) {
              hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[_utils.MODULE_TYPE] || {}));
            }

            if (REGEXP_NAME.test(chunkFilename)) {
              hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
            }
          });
        }

        compilation.hooks.contentHash.tap(pluginName, function (chunk) {
          var outputOptions = compilation.outputOptions,
              chunkGraph = compilation.chunkGraph;
          var hashFunction = outputOptions.hashFunction,
              hashDigest = outputOptions.hashDigest,
              hashDigestLength = outputOptions.hashDigestLength;
          var hash = createHash(hashFunction);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _this2.getChunkModules(chunk, chunkGraph)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var m = _step.value;

              if (m.type === _utils.MODULE_TYPE) {
                m.updateHash(hash, {
                  chunkGraph: chunkGraph
                });
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var contentHash = chunk.contentHash;
          contentHash[_utils.MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);
        });
        var mainTemplate = compilation.mainTemplate;

        if (isWebpack4) {
          mainTemplate.hooks.localVars.tap(pluginName, function (source, chunk) {
            var chunkMap = _this2.getCssChunkObject(chunk, compilation);

            if (Object.keys(chunkMap).length > 0) {
              return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(function (id) {
                return "".concat(JSON.stringify(id), ": 0");
              }).join(',\n')), '};']);
            }

            return source;
          });
          mainTemplate.hooks.requireEnsure.tap(pluginName, function (source, chunk, hash) {
            var chunkMap = _this2.getCssChunkObject(chunk, compilation);

            if (Object.keys(chunkMap).length > 0) {
              var chunkMaps = chunk.getChunkMaps();
              var crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading;
              var linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(_this2.options.chunkFilename), {
                hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
                hashWithLength: function hashWithLength(length) {
                  return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
                },
                chunk: {
                  id: '" + chunkId + "',
                  hash: "\" + ".concat(JSON.stringify(chunkMaps.hash), "[chunkId] + \""),
                  hashWithLength: function hashWithLength(length) {
                    var shortChunkHashMap = Object.create(null);

                    for (var _i = 0, _Object$keys = Object.keys(chunkMaps.hash); _i < _Object$keys.length; _i++) {
                      var chunkId = _Object$keys[_i];

                      if (typeof chunkMaps.hash[chunkId] === 'string') {
                        shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);
                      }
                    }

                    return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[chunkId] + \"");
                  },
                  contentHash: _defineProperty({}, _utils.MODULE_TYPE, "\" + ".concat(JSON.stringify(chunkMaps.contentHash[_utils.MODULE_TYPE]), "[chunkId] + \"")),
                  contentHashWithLength: _defineProperty({}, _utils.MODULE_TYPE, function (length) {
                    var shortContentHashMap = {};
                    var contentHash = chunkMaps.contentHash[_utils.MODULE_TYPE];

                    for (var _i2 = 0, _Object$keys2 = Object.keys(contentHash); _i2 < _Object$keys2.length; _i2++) {
                      var chunkId = _Object$keys2[_i2];

                      if (typeof contentHash[chunkId] === 'string') {
                        shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);
                      }
                    }

                    return "\" + ".concat(JSON.stringify(shortContentHashMap), "[chunkId] + \"");
                  }),
                  name: "\" + (".concat(JSON.stringify(chunkMaps.name), "[chunkId]||chunkId) + \"")
                },
                contentHashType: _utils.MODULE_TYPE
              });
              return Template.asString([source, '', "// ".concat(pluginName, " CSS loading"), "var cssChunks = ".concat(JSON.stringify(chunkMap), ";"), 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent(["var href = ".concat(linkHrefPath, ";"), "var fullhref = ".concat(mainTemplate.requireFn, ".p + href;"), 'var existingLinkTags = document.getElementsByTagName("link");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");', 'if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName("style");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute("data-href");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement("link");', 'linkTag.rel = "stylesheet";', 'linkTag.type = "text/css";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error("Loading CSS chunk " + chunkId + " failed.\\n(" + request + ")");', 'err.code = "CSS_CHUNK_LOAD_FAILED";', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString(["if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent("linkTag.crossOrigin = ".concat(JSON.stringify(crossOriginLoading), ";")), '}']) : '', 'var head = document.getElementsByTagName("head")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);
            }

            return source;
          });
        } else {
          var enabledChunks = new WeakSet();

          var handler = function handler(chunk, set) {
            if (enabledChunks.has(chunk)) return;
            enabledChunks.add(chunk); // eslint-disable-next-line global-require

            var CssLoadingRuntimeModule = require('./CssLoadingRuntimeModule');

            set.add(_webpack["default"].RuntimeGlobals.publicPath);
            compilation.addRuntimeModule(chunk, new _webpack["default"].runtime.GetChunkFilenameRuntimeModule(_utils.MODULE_TYPE, 'mini-css', "".concat(_webpack["default"].RuntimeGlobals.require, ".miniCssF"), function (referencedChunk) {
              return referencedChunk.canBeInitial() ? function (_ref7) {
                var chunkData = _ref7.chunk;
                return _this2.options.moduleFilename(chunkData);
              } : _this2.options.chunkFilename;
            }, true));
            compilation.addRuntimeModule(chunk, new CssLoadingRuntimeModule(set));
          };

          compilation.hooks.runtimeRequirementInTree["for"](_webpack["default"].RuntimeGlobals.ensureChunkHandlers).tap(pluginName, handler);
          compilation.hooks.runtimeRequirementInTree["for"](_webpack["default"].RuntimeGlobals.hmrDownloadUpdateHandlers).tap(pluginName, handler);
        }
      });
    }
  }, {
    key: "getChunkModules",
    value: function getChunkModules(chunk, chunkGraph) {
      return typeof chunkGraph !== 'undefined' ? chunkGraph.getOrderedChunkModulesIterable(chunk, _utils.compareModulesByIdentifier) : chunk.modulesIterable;
    }
  }, {
    key: "getCssChunkObject",
    value: function getCssChunkObject(mainChunk, compilation) {
      var obj = {};
      var chunkGraph = compilation.chunkGraph;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = mainChunk.getAllAsyncChunks()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var chunk = _step2.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.getChunkModules(chunk, chunkGraph)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var module = _step3.value;

              if (module.type === _utils.MODULE_TYPE) {
                obj[chunk.id] = 1;
                break;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return obj;
    }
  }, {
    key: "renderContentAsset",
    value: function renderContentAsset(compilation, chunk, modules, requestShortener) {
      var _this3 = this;

      var usedModules;

      var _chunk$groupsIterable = _slicedToArray(chunk.groupsIterable, 1),
          chunkGroup = _chunk$groupsIterable[0];

      var moduleIndexFunctionName = typeof compilation.chunkGraph !== 'undefined' ? 'getModulePostOrderIndex' : 'getModuleIndex2';

      if (typeof chunkGroup[moduleIndexFunctionName] === 'function') {
        (function () {
          // Store dependencies for modules
          var moduleDependencies = new Map(modules.map(function (m) {
            return [m, new Set()];
          }));
          var moduleDependenciesReasons = new Map(modules.map(function (m) {
            return [m, new Map()];
          })); // Get ordered list of modules per chunk group
          // This loop also gathers dependencies from the ordered lists
          // Lists are in reverse order to allow to use Array.pop()

          var modulesByChunkGroup = Array.from(chunk.groupsIterable, function (cg) {
            var sortedModules = modules.map(function (m) {
              return {
                module: m,
                index: cg[moduleIndexFunctionName](m)
              };
            }) // eslint-disable-next-line no-undefined
            .filter(function (item) {
              return item.index !== undefined;
            }).sort(function (a, b) {
              return b.index - a.index;
            }).map(function (item) {
              return item.module;
            });

            for (var i = 0; i < sortedModules.length; i++) {
              var set = moduleDependencies.get(sortedModules[i]);
              var reasons = moduleDependenciesReasons.get(sortedModules[i]);

              for (var j = i + 1; j < sortedModules.length; j++) {
                var module = sortedModules[j];
                set.add(module);
                var reason = reasons.get(module) || new Set();
                reason.add(cg);
                reasons.set(module, reason);
              }
            }

            return sortedModules;
          }); // set with already included modules in correct order

          usedModules = new Set();

          var unusedModulesFilter = function unusedModulesFilter(m) {
            return !usedModules.has(m);
          };

          while (usedModules.size < modules.length) {
            var success = false;
            var bestMatch = void 0;
            var bestMatchDeps = void 0; // get first module where dependencies are fulfilled

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = modulesByChunkGroup[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var list = _step4.value;

                // skip and remove already added modules
                while (list.length > 0 && usedModules.has(list[list.length - 1])) {
                  list.pop();
                } // skip empty lists


                if (list.length !== 0) {
                  var module = list[list.length - 1];
                  var deps = moduleDependencies.get(module); // determine dependencies that are not yet included

                  var failedDeps = Array.from(deps).filter(unusedModulesFilter); // store best match for fallback behavior

                  if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {
                    bestMatch = list;
                    bestMatchDeps = failedDeps;
                  }

                  if (failedDeps.length === 0) {
                    // use this module and remove it from list
                    usedModules.add(list.pop());
                    success = true;
                    break;
                  }
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (!success) {
              (function () {
                // no module found => there is a conflict
                // use list with fewest failed deps
                // and emit a warning
                var fallbackModule = bestMatch.pop();

                if (!_this3.options.ignoreOrder) {
                  var reasons = moduleDependenciesReasons.get(fallbackModule);
                  compilation.warnings.push(new Error(["chunk ".concat(chunk.name || chunk.id, " [").concat(pluginName, "]"), 'Conflicting order. Following module has been added:', " * ".concat(fallbackModule.readableIdentifier(requestShortener)), 'despite it was not able to fulfill desired ordering with these modules:'].concat(_toConsumableArray(bestMatchDeps.map(function (m) {
                    var goodReasonsMap = moduleDependenciesReasons.get(m);
                    var goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);
                    var failedChunkGroups = Array.from(reasons.get(m), function (cg) {
                      return cg.name;
                    }).join(', ');
                    var goodChunkGroups = goodReasons && Array.from(goodReasons, function (cg) {
                      return cg.name;
                    }).join(', ');
                    return [" * ".concat(m.readableIdentifier(requestShortener)), "   - couldn't fulfill desired order of chunk group(s) ".concat(failedChunkGroups), goodChunkGroups && "   - while fulfilling desired order of chunk group(s) ".concat(goodChunkGroups)].filter(Boolean).join('\n');
                  }))).join('\n')));
                }

                usedModules.add(fallbackModule);
              })();
            }
          }
        })();
      } else {
        // fallback for older webpack versions
        // (to avoid a breaking change)
        // TODO remove this in next major version
        // and increase minimum webpack version to 4.12.0
        modules.sort(function (a, b) {
          return a.index2 - b.index2;
        });
        usedModules = modules;
      }

      var source = new ConcatSource();
      var externalsSource = new ConcatSource();
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = usedModules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var m = _step5.value;

          if (/^@import url/.test(m.content)) {
            // HACK for IE
            // http://stackoverflow.com/a/14676665/1458162
            var content = m.content;

            if (m.media) {
              // insert media into the @import
              // this is rar
              // TODO improve this and parse the CSS to support multiple medias
              content = content.replace(/;|\s*$/, m.media);
            }

            externalsSource.add(content);
            externalsSource.add('\n');
          } else {
            if (m.media) {
              source.add("@media ".concat(m.media, " {\n"));
            }

            if (m.sourceMap) {
              source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));
            } else {
              source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));
            }

            source.add('\n');

            if (m.media) {
              source.add('}\n');
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return new ConcatSource(externalsSource, source);
    }
  }]);

  return MiniCssExtractPlugin;
}();

MiniCssExtractPlugin.loader = require.resolve('./loader');
var _default = MiniCssExtractPlugin;
exports["default"] = _default;