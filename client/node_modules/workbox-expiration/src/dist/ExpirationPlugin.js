"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.ExpirationPlugin = void 0;
var assert_js_1 = require("workbox-core/_private/assert.js");
var cacheNames_js_1 = require("workbox-core/_private/cacheNames.js");
var dontWaitFor_js_1 = require("workbox-core/_private/dontWaitFor.js");
var getFriendlyURL_js_1 = require("workbox-core/_private/getFriendlyURL.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var registerQuotaErrorCallback_js_1 = require("workbox-core/registerQuotaErrorCallback.js");
var WorkboxError_js_1 = require("workbox-core/_private/WorkboxError.js");
var CacheExpiration_js_1 = require("./CacheExpiration.js");
require("./_version.js");
/**
 * This plugin can be used in the Workbox APIs to regularly enforce a
 * limit on the age and / or the number of cached requests.
 *
 * Whenever a cached request is used or updated, this plugin will look
 * at the used Cache and remove any old or extra requests.
 *
 * When using `maxAgeSeconds`, requests may be used *once* after expiring
 * because the expiration clean up will not have occurred until *after* the
 * cached request has been used. If the request has a "Date" header, then
 * a light weight expiration check is performed and the request will not be
 * used immediately.
 *
 * When using `maxEntries`, the entry least-recently requested will be removed
 * from the cache first.
 *
 * @memberof module:workbox-expiration
 */
var ExpirationPlugin = /** @class */ (function () {
    /**
     * @param {Object} config
     * @param {number} [config.maxEntries] The maximum number of entries to cache.
     * Entries used the least will be removed as the maximum is reached.
     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
     * it's treated as stale and removed.
     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
     * automatic deletion if the available storage quota has been exceeded.
     */
    function ExpirationPlugin(config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        /**
         * A "lifecycle" callback that will be triggered automatically by the
         * `workbox-strategies` handlers when a `Response` is about to be returned
         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
         * the handler. It allows the `Response` to be inspected for freshness and
         * prevents it from being used if the `Response`'s `Date` header value is
         * older than the configured `maxAgeSeconds`.
         *
         * @param {Object} options
         * @param {string} options.cacheName Name of the cache the response is in.
         * @param {Response} options.cachedResponse The `Response` object that's been
         *     read from a cache and whose freshness should be checked.
         * @return {Response} Either the `cachedResponse`, if it's
         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
         *
         * @private
         */
        this.cachedResponseWillBeUsed = function (_a) {
            var event = _a.event, request = _a.request, cacheName = _a.cacheName, cachedResponse = _a.cachedResponse;
            return __awaiter(_this, void 0, void 0, function () {
                var isFresh, cacheExpiration, updateTimestampDone;
                return __generator(this, function (_b) {
                    if (!cachedResponse) {
                        return [2 /*return*/, null];
                    }
                    isFresh = this._isResponseDateFresh(cachedResponse);
                    cacheExpiration = this._getCacheExpiration(cacheName);
                    dontWaitFor_js_1.dontWaitFor(cacheExpiration.expireEntries());
                    updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
                    if (event) {
                        try {
                            event.waitUntil(updateTimestampDone);
                        }
                        catch (error) {
                            if (process.env.NODE_ENV !== 'production') {
                                // The event may not be a fetch event; only log the URL if it is.
                                if ('request' in event) {
                                    logger_js_1.logger.warn("Unable to ensure service worker stays alive when " +
                                        "updating cache entry for " +
                                        ("'" + getFriendlyURL_js_1.getFriendlyURL(event.request.url) + "'."));
                                }
                            }
                        }
                    }
                    return [2 /*return*/, isFresh ? cachedResponse : null];
                });
            });
        };
        /**
         * A "lifecycle" callback that will be triggered automatically by the
         * `workbox-strategies` handlers when an entry is added to a cache.
         *
         * @param {Object} options
         * @param {string} options.cacheName Name of the cache that was updated.
         * @param {string} options.request The Request for the cached entry.
         *
         * @private
         */
        this.cacheDidUpdate = function (_a) {
            var cacheName = _a.cacheName, request = _a.request;
            return __awaiter(_this, void 0, void 0, function () {
                var cacheExpiration;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (process.env.NODE_ENV !== 'production') {
                                assert_js_1.assert.isType(cacheName, 'string', {
                                    moduleName: 'workbox-expiration',
                                    className: 'Plugin',
                                    funcName: 'cacheDidUpdate',
                                    paramName: 'cacheName'
                                });
                                assert_js_1.assert.isInstance(request, Request, {
                                    moduleName: 'workbox-expiration',
                                    className: 'Plugin',
                                    funcName: 'cacheDidUpdate',
                                    paramName: 'request'
                                });
                            }
                            cacheExpiration = this._getCacheExpiration(cacheName);
                            return [4 /*yield*/, cacheExpiration.updateTimestamp(request.url)];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, cacheExpiration.expireEntries()];
                        case 2:
                            _b.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        if (process.env.NODE_ENV !== 'production') {
            if (!(config.maxEntries || config.maxAgeSeconds)) {
                throw new WorkboxError_js_1.WorkboxError('max-entries-or-age-required', {
                    moduleName: 'workbox-expiration',
                    className: 'Plugin',
                    funcName: 'constructor'
                });
            }
            if (config.maxEntries) {
                assert_js_1.assert.isType(config.maxEntries, 'number', {
                    moduleName: 'workbox-expiration',
                    className: 'Plugin',
                    funcName: 'constructor',
                    paramName: 'config.maxEntries'
                });
            }
            if (config.maxAgeSeconds) {
                assert_js_1.assert.isType(config.maxAgeSeconds, 'number', {
                    moduleName: 'workbox-expiration',
                    className: 'Plugin',
                    funcName: 'constructor',
                    paramName: 'config.maxAgeSeconds'
                });
            }
        }
        this._config = config;
        this._maxAgeSeconds = config.maxAgeSeconds;
        this._cacheExpirations = new Map();
        if (config.purgeOnQuotaError) {
            registerQuotaErrorCallback_js_1.registerQuotaErrorCallback(function () { return _this.deleteCacheAndMetadata(); });
        }
    }
    /**
     * A simple helper method to return a CacheExpiration instance for a given
     * cache name.
     *
     * @param {string} cacheName
     * @return {CacheExpiration}
     *
     * @private
     */
    ExpirationPlugin.prototype._getCacheExpiration = function (cacheName) {
        if (cacheName === cacheNames_js_1.cacheNames.getRuntimeName()) {
            throw new WorkboxError_js_1.WorkboxError('expire-custom-caches-only');
        }
        var cacheExpiration = this._cacheExpirations.get(cacheName);
        if (!cacheExpiration) {
            cacheExpiration = new CacheExpiration_js_1.CacheExpiration(cacheName, this._config);
            this._cacheExpirations.set(cacheName, cacheExpiration);
        }
        return cacheExpiration;
    };
    /**
     * @param {Response} cachedResponse
     * @return {boolean}
     *
     * @private
     */
    ExpirationPlugin.prototype._isResponseDateFresh = function (cachedResponse) {
        if (!this._maxAgeSeconds) {
            // We aren't expiring by age, so return true, it's fresh
            return true;
        }
        // Check if the 'date' header will suffice a quick expiration check.
        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
        // discussion.
        var dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
        if (dateHeaderTimestamp === null) {
            // Unable to parse date, so assume it's fresh.
            return true;
        }
        // If we have a valid headerTime, then our response is fresh iff the
        // headerTime plus maxAgeSeconds is greater than the current time.
        var now = Date.now();
        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);
    };
    /**
     * This method will extract the data header and parse it into a useful
     * value.
     *
     * @param {Response} cachedResponse
     * @return {number|null}
     *
     * @private
     */
    ExpirationPlugin.prototype._getDateHeaderTimestamp = function (cachedResponse) {
        if (!cachedResponse.headers.has('date')) {
            return null;
        }
        var dateHeader = cachedResponse.headers.get('date');
        var parsedDate = new Date(dateHeader);
        var headerTime = parsedDate.getTime();
        // If the Date header was invalid for some reason, parsedDate.getTime()
        // will return NaN.
        if (isNaN(headerTime)) {
            return null;
        }
        return headerTime;
    };
    /**
     * This is a helper method that performs two operations:
     *
     * - Deletes *all* the underlying Cache instances associated with this plugin
     * instance, by calling caches.delete() on your behalf.
     * - Deletes the metadata from IndexedDB used to keep track of expiration
     * details for each Cache instance.
     *
     * When using cache expiration, calling this method is preferable to calling
     * `caches.delete()` directly, since this will ensure that the IndexedDB
     * metadata is also cleanly removed and open IndexedDB instances are deleted.
     *
     * Note that if you're *not* using cache expiration for a given cache, calling
     * `caches.delete()` and passing in the cache's name should be sufficient.
     * There is no Workbox-specific method needed for cleanup in that case.
     */
    ExpirationPlugin.prototype.deleteCacheAndMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, _b, cacheName, cacheExpiration;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _i = 0, _a = this._cacheExpirations;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 5];
                        _b = _a[_i], cacheName = _b[0], cacheExpiration = _b[1];
                        return [4 /*yield*/, self.caches["delete"](cacheName)];
                    case 2:
                        _c.sent();
                        return [4 /*yield*/, cacheExpiration["delete"]()];
                    case 3:
                        _c.sent();
                        _c.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 1];
                    case 5:
                        // Reset this._cacheExpirations to its initial state.
                        this._cacheExpirations = new Map();
                        return [2 /*return*/];
                }
            });
        });
    };
    return ExpirationPlugin;
}());
exports.ExpirationPlugin = ExpirationPlugin;
