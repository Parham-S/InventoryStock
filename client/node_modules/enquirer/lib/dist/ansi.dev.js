'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';

var colors = require('ansi-colors');

var utils = require('./utils');

var ansi = module.exports = exports;
var ESC = "\x1B[";
var BEL = "\x07";
var hidden = false;
var code = ansi.code = {
  bell: BEL,
  beep: BEL,
  beginning: "".concat(ESC, "G"),
  down: "".concat(ESC, "J"),
  esc: ESC,
  getPosition: "".concat(ESC, "6n"),
  hide: "".concat(ESC, "?25l"),
  line: "".concat(ESC, "2K"),
  lineEnd: "".concat(ESC, "K"),
  lineStart: "".concat(ESC, "1K"),
  restorePosition: ESC + (isTerm ? '8' : 'u'),
  savePosition: ESC + (isTerm ? '7' : 's'),
  screen: "".concat(ESC, "2J"),
  show: "".concat(ESC, "?25h"),
  up: "".concat(ESC, "1J")
};
var cursor = ansi.cursor = {
  get hidden() {
    return hidden;
  },

  hide: function hide() {
    hidden = true;
    return code.hide;
  },
  show: function show() {
    hidden = false;
    return code.show;
  },
  forward: function forward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "C");
  },
  backward: function backward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "D");
  },
  nextLine: function nextLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "E").repeat(count);
  },
  prevLine: function prevLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "F").repeat(count);
  },
  up: function up() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "A") : '';
  },
  down: function down() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "B") : '';
  },
  right: function right() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "C") : '';
  },
  left: function left() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "D") : '';
  },
  to: function to(x, y) {
    return y ? "".concat(ESC).concat(y + 1, ";").concat(x + 1, "H") : "".concat(ESC).concat(x + 1, "G");
  },
  move: function move() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var res = '';
    res += x < 0 ? cursor.left(-x) : x > 0 ? cursor.right(x) : '';
    res += y < 0 ? cursor.up(-y) : y > 0 ? cursor.down(y) : '';
    return res;
  },
  restore: function restore() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var after = state.after,
        cursor = state.cursor,
        initial = state.initial,
        input = state.input,
        prompt = state.prompt,
        size = state.size,
        value = state.value;
    initial = utils.isPrimitive(initial) ? String(initial) : '';
    input = utils.isPrimitive(input) ? String(input) : '';
    value = utils.isPrimitive(value) ? String(value) : '';

    if (size) {
      var codes = ansi.cursor.up(size) + ansi.cursor.to(prompt.length);
      var diff = input.length - cursor;

      if (diff > 0) {
        codes += ansi.cursor.left(diff);
      }

      return codes;
    }

    if (value || after) {
      var pos = !input && !!initial ? -initial.length : -input.length + cursor;
      if (after) pos -= after.length;

      if (input === '' && initial && !prompt.includes(initial)) {
        pos += initial.length;
      }

      return ansi.cursor.move(pos);
    }
  }
};
var erase = ansi.erase = {
  screen: code.screen,
  up: code.up,
  down: code.down,
  line: code.line,
  lineEnd: code.lineEnd,
  lineStart: code.lineStart,
  lines: function lines(n) {
    var str = '';

    for (var i = 0; i < n; i++) {
      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
    }

    if (n) str += ansi.code.beginning;
    return str;
  }
};

ansi.clear = function () {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.stdout.columns;
  if (!columns) return erase.line + cursor.to(0);

  var width = function width(str) {
    return _toConsumableArray(colors.unstyle(str)).length;
  };

  var lines = input.split(/\r?\n/);
  var rows = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
};