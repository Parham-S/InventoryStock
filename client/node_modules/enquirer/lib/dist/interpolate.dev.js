'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var colors = require('ansi-colors');

var clean = function clean() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return typeof str === 'string' ? str.replace(/^['"]|['"]$/g, '') : '';
};
/**
 * This file contains the interpolation and rendering logic for
 * the Snippet prompt.
 */


var Item = function Item(token) {
  _classCallCheck(this, Item);

  this.name = token.key;
  this.field = token.field || {};
  this.value = clean(token.initial || this.field.initial || '');
  this.message = token.message || this.name;
  this.cursor = 0;
  this.input = '';
  this.lines = [];
};

var tokenize = function tokenize() {
  var options,
      defaults,
      fn,
      unique,
      fields,
      input,
      tabstops,
      items,
      keys,
      line,
      i,
      next,
      peek,
      push,
      value,
      _ret,
      last,
      _args = arguments;

  return regeneratorRuntime.async(function tokenize$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
          defaults = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          fn = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (token) {
            return token;
          };
          unique = new Set();
          fields = options.fields || [];
          input = options.template;
          tabstops = [];
          items = [];
          keys = [];
          line = 1;

          if (!(typeof input === 'function')) {
            _context.next = 14;
            break;
          }

          _context.next = 13;
          return regeneratorRuntime.awrap(input());

        case 13:
          input = _context.sent;

        case 14:
          i = -1;

          next = function next() {
            return input[++i];
          };

          peek = function peek() {
            return input[i + 1];
          };

          push = function push(token) {
            token.line = line;
            tabstops.push(token);
          };

          push({
            type: 'bos',
            value: ''
          });

        case 19:
          if (!(i < input.length - 1)) {
            _context.next = 40;
            break;
          }

          value = next();

          if (!/^[^\S\n ]$/.test(value)) {
            _context.next = 24;
            break;
          }

          push({
            type: 'text',
            value: value
          });
          return _context.abrupt("continue", 19);

        case 24:
          if (!(value === '\n')) {
            _context.next = 28;
            break;
          }

          push({
            type: 'newline',
            value: value
          });
          line++;
          return _context.abrupt("continue", 19);

        case 28:
          if (!(value === '\\')) {
            _context.next = 32;
            break;
          }

          value += next();
          push({
            type: 'text',
            value: value
          });
          return _context.abrupt("continue", 19);

        case 32:
          if (!((value === '$' || value === '#' || value === '{') && peek() === '{')) {
            _context.next = 36;
            break;
          }

          _ret = function () {
            var n = next();
            value += n;
            var token = {
              type: 'template',
              open: value,
              inner: '',
              close: '',
              value: value
            };
            var ch = void 0;

            while (ch = next()) {
              if (ch === '}') {
                if (peek() === '}') ch += next();
                token.value += ch;
                token.close = ch;
                break;
              }

              if (ch === ':') {
                token.initial = '';
                token.key = token.inner;
              } else if (token.initial !== void 0) {
                token.initial += ch;
              }

              token.value += ch;
              token.inner += ch;
            }

            token.template = token.open + (token.initial || token.inner) + token.close;
            token.key = token.key || token.inner;

            if (defaults.hasOwnProperty(token.key)) {
              token.initial = defaults[token.key];
            }

            token = fn(token);
            push(token);
            keys.push(token.key);
            unique.add(token.key);
            var item = items.find(function (item) {
              return item.name === token.key;
            });
            token.field = fields.find(function (ch) {
              return ch.name === token.key;
            });

            if (!item) {
              item = new Item(token);
              items.push(item);
            }

            item.lines.push(token.line - 1);
            return "continue";
          }();

          if (!(_ret === "continue")) {
            _context.next = 36;
            break;
          }

          return _context.abrupt("continue", 19);

        case 36:
          last = tabstops[tabstops.length - 1];

          if (last.type === 'text' && last.line === line) {
            last.value += value;
          } else {
            push({
              type: 'text',
              value: value
            });
          }

          _context.next = 19;
          break;

        case 40:
          push({
            type: 'eos',
            value: ''
          });
          return _context.abrupt("return", {
            input: input,
            tabstops: tabstops,
            unique: unique,
            keys: keys,
            items: items
          });

        case 42:
        case "end":
          return _context.stop();
      }
    }
  });
};

module.exports = function _callee2(prompt) {
  var options, required, defaults, _ref, tabstops, items, keys, result, format, isValid, isVal;

  return regeneratorRuntime.async(function _callee2$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          options = prompt.options;
          required = new Set(options.required === true ? [] : options.required || []);
          defaults = _objectSpread({}, options.values, {}, options.initial);
          _context5.next = 5;
          return regeneratorRuntime.awrap(tokenize(options, defaults));

        case 5:
          _ref = _context5.sent;
          tabstops = _ref.tabstops;
          items = _ref.items;
          keys = _ref.keys;
          result = createFn('result', prompt, options);
          format = createFn('format', prompt, options);
          isValid = createFn('validate', prompt, options, true);
          isVal = prompt.isValue.bind(prompt);
          return _context5.abrupt("return", function _callee() {
            var state,
                submitted,
                index,
                validate,
                _iteratorNormalCompletion,
                _didIteratorError,
                _iteratorError,
                _loop,
                _iterator,
                _step,
                _ret2,
                lines,
                len,
                done,
                _iteratorNormalCompletion2,
                _didIteratorError2,
                _iteratorError2,
                _iterator2,
                _step2,
                item,
                _args4 = arguments;

            return regeneratorRuntime.async(function _callee$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    state = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                    submitted = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
                    index = 0;
                    state.required = required;
                    state.items = items;
                    state.keys = keys;
                    state.output = '';

                    validate = function validate(value, state, item, index) {
                      var error;
                      return regeneratorRuntime.async(function validate$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return regeneratorRuntime.awrap(isValid(value, state, item, index));

                            case 2:
                              error = _context2.sent;

                              if (!(error === false)) {
                                _context2.next = 5;
                                break;
                              }

                              return _context2.abrupt("return", 'Invalid field ' + item.name);

                            case 5:
                              return _context2.abrupt("return", error);

                            case 6:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      });
                    };

                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _iteratorError = undefined;
                    _context4.prev = 11;

                    _loop = function _loop() {
                      var token, value, key, item, val, field, message, error, res, before;
                      return regeneratorRuntime.async(function _loop$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              token = _step.value;
                              value = token.value;
                              key = token.key;

                              if (!(token.type !== 'template')) {
                                _context3.next = 6;
                                break;
                              }

                              if (value) state.output += value;
                              return _context3.abrupt("return", "continue");

                            case 6:
                              if (!(token.type === 'template')) {
                                _context3.next = 35;
                                break;
                              }

                              item = items.find(function (ch) {
                                return ch.name === key;
                              });

                              if (options.required === true) {
                                state.required.add(item.name);
                              }

                              val = [item.input, state.values[item.value], item.value, value].find(isVal);
                              field = item.field || {};
                              message = field.message || token.inner;

                              if (!submitted) {
                                _context3.next = 25;
                                break;
                              }

                              _context3.next = 15;
                              return regeneratorRuntime.awrap(validate(state.values[key], state, item, index));

                            case 15:
                              error = _context3.sent;

                              if (!(error && typeof error === 'string' || error === false)) {
                                _context3.next = 19;
                                break;
                              }

                              state.invalid.set(key, error);
                              return _context3.abrupt("return", "continue");

                            case 19:
                              state.invalid["delete"](key);
                              _context3.next = 22;
                              return regeneratorRuntime.awrap(result(state.values[key], state, item, index));

                            case 22:
                              res = _context3.sent;
                              state.output += colors.unstyle(res);
                              return _context3.abrupt("return", "continue");

                            case 25:
                              item.placeholder = false;
                              before = value;
                              _context3.next = 29;
                              return regeneratorRuntime.awrap(format(value, state, item, index));

                            case 29:
                              value = _context3.sent;

                              if (val !== value) {
                                state.values[key] = val;
                                value = prompt.styles.typing(val);
                                state.missing["delete"](message);
                              } else {
                                state.values[key] = void 0;
                                val = "<".concat(message, ">");
                                value = prompt.styles.primary(val);
                                item.placeholder = true;

                                if (state.required.has(key)) {
                                  state.missing.add(message);
                                }
                              }

                              if (state.missing.has(message) && state.validating) {
                                value = prompt.styles.warning(val);
                              }

                              if (state.invalid.has(key) && state.validating) {
                                value = prompt.styles.danger(val);
                              }

                              if (index === state.index) {
                                if (before !== value) {
                                  value = prompt.styles.underline(value);
                                } else {
                                  value = prompt.styles.heading(colors.unstyle(value));
                                }
                              }

                              index++;

                            case 35:
                              if (value) {
                                state.output += value;
                              }

                            case 36:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      });
                    };

                    _iterator = tabstops[Symbol.iterator]();

                  case 14:
                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                      _context4.next = 23;
                      break;
                    }

                    _context4.next = 17;
                    return regeneratorRuntime.awrap(_loop());

                  case 17:
                    _ret2 = _context4.sent;

                    if (!(_ret2 === "continue")) {
                      _context4.next = 20;
                      break;
                    }

                    return _context4.abrupt("continue", 20);

                  case 20:
                    _iteratorNormalCompletion = true;
                    _context4.next = 14;
                    break;

                  case 23:
                    _context4.next = 29;
                    break;

                  case 25:
                    _context4.prev = 25;
                    _context4.t0 = _context4["catch"](11);
                    _didIteratorError = true;
                    _iteratorError = _context4.t0;

                  case 29:
                    _context4.prev = 29;
                    _context4.prev = 30;

                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }

                  case 32:
                    _context4.prev = 32;

                    if (!_didIteratorError) {
                      _context4.next = 35;
                      break;
                    }

                    throw _iteratorError;

                  case 35:
                    return _context4.finish(32);

                  case 36:
                    return _context4.finish(29);

                  case 37:
                    lines = state.output.split('\n').map(function (l) {
                      return ' ' + l;
                    });
                    len = items.length;
                    done = 0;
                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;
                    _context4.prev = 43;

                    for (_iterator2 = items[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                      item = _step2.value;

                      if (state.invalid.has(item.name)) {
                        item.lines.forEach(function (i) {
                          if (lines[i][0] !== ' ') return;
                          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
                        });
                      }

                      if (prompt.isValue(state.values[item.name])) {
                        done++;
                      }
                    }

                    _context4.next = 51;
                    break;

                  case 47:
                    _context4.prev = 47;
                    _context4.t1 = _context4["catch"](43);
                    _didIteratorError2 = true;
                    _iteratorError2 = _context4.t1;

                  case 51:
                    _context4.prev = 51;
                    _context4.prev = 52;

                    if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                      _iterator2["return"]();
                    }

                  case 54:
                    _context4.prev = 54;

                    if (!_didIteratorError2) {
                      _context4.next = 57;
                      break;
                    }

                    throw _iteratorError2;

                  case 57:
                    return _context4.finish(54);

                  case 58:
                    return _context4.finish(51);

                  case 59:
                    state.completed = (done / len * 100).toFixed(0);
                    state.output = lines.join('\n');
                    return _context4.abrupt("return", state.output);

                  case 62:
                  case "end":
                    return _context4.stop();
                }
              }
            }, null, null, [[11, 25, 29, 37], [30,, 32, 36], [43, 47, 51, 59], [52,, 54, 58]]);
          });

        case 14:
        case "end":
          return _context5.stop();
      }
    }
  });
};

function createFn(prop, prompt, options, fallback) {
  return function (value, state, item, index) {
    if (typeof item.field[prop] === 'function') {
      return item.field[prop].call(prompt, value, state, item, index);
    }

    return [fallback, value].find(function (v) {
      return prompt.isValue(v);
    });
  };
}