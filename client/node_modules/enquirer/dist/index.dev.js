'use strict';

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var assert = require('assert');

var Events = require('events');

var utils = require('./lib/utils');
/**
 * Create an instance of `Enquirer`.
 *
 * ```js
 * const Enquirer = require('enquirer');
 * const enquirer = new Enquirer();
 * ```
 * @name Enquirer
 * @param {Object} `options` (optional) Options to use with all prompts.
 * @param {Object} `answers` (optional) Answers object to initialize with.
 * @api public
 */


var Enquirer =
/*#__PURE__*/
function (_Events) {
  _inherits(Enquirer, _Events);

  function Enquirer(options, answers) {
    var _this;

    _classCallCheck(this, Enquirer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Enquirer).call(this));
    _this.options = utils.merge({}, options);
    _this.answers = _objectSpread({}, answers);
    return _this;
  }
  /**
   * Register a custom prompt type.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * enquirer.register('customType', require('./custom-prompt'));
   * ```
   * @name register()
   * @param {String} `type`
   * @param {Function|Prompt} `fn` `Prompt` class, or a function that returns a `Prompt` class.
   * @return {Object} Returns the Enquirer instance
   * @api public
   */


  _createClass(Enquirer, [{
    key: "register",
    value: function register(type, fn) {
      if (utils.isObject(type)) {
        for (var _i = 0, _Object$keys = Object.keys(type); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          this.register(key, type[key]);
        }

        return this;
      }

      assert.equal(_typeof(fn), 'function', 'expected a function');
      var name = type.toLowerCase();

      if (fn.prototype instanceof this.Prompt) {
        this.prompts[name] = fn;
      } else {
        this.prompts[name] = fn(this.Prompt, this);
      }

      return this;
    }
    /**
     * Prompt function that takes a "question" object or array of question objects,
     * and returns an object with responses from the user.
     *
     * ```js
     * const Enquirer = require('enquirer');
     * const enquirer = new Enquirer();
     *
     * const response = await enquirer.prompt({
     *   type: 'input',
     *   name: 'username',
     *   message: 'What is your username?'
     * });
     * console.log(response);
     * ```
     * @name prompt()
     * @param {Array|Object} `questions` Options objects for one or more prompts to run.
     * @return {Promise} Promise that returns an "answers" object with the user's responses.
     * @api public
     */

  }, {
    key: "prompt",
    value: function prompt() {
      var questions,
          _iteratorNormalCompletion,
          _didIteratorError,
          _iteratorError,
          _iterator,
          _step,
          question,
          _args = arguments;

      return regeneratorRuntime.async(function prompt$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              questions = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 4;
              _iterator = [].concat(questions)[Symbol.iterator]();

            case 6:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 23;
                break;
              }

              question = _step.value;
              _context.prev = 8;

              if (!(typeof question === 'function')) {
                _context.next = 13;
                break;
              }

              _context.next = 12;
              return regeneratorRuntime.awrap(question.call(this));

            case 12:
              question = _context.sent;

            case 13:
              _context.next = 15;
              return regeneratorRuntime.awrap(this.ask(utils.merge({}, this.options, question)));

            case 15:
              _context.next = 20;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](8);
              return _context.abrupt("return", Promise.reject(_context.t0));

            case 20:
              _iteratorNormalCompletion = true;
              _context.next = 6;
              break;

            case 23:
              _context.next = 29;
              break;

            case 25:
              _context.prev = 25;
              _context.t1 = _context["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 29:
              _context.prev = 29;
              _context.prev = 30;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 32:
              _context.prev = 32;

              if (!_didIteratorError) {
                _context.next = 35;
                break;
              }

              throw _iteratorError;

            case 35:
              return _context.finish(32);

            case 36:
              return _context.finish(29);

            case 37:
              return _context.abrupt("return", this.answers);

            case 38:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[4, 25, 29, 37], [8, 17], [30,, 32, 36]]);
    }
  }, {
    key: "ask",
    value: function ask(question) {
      var _this2 = this;

      var opts, _question, type, name, set, get, prompt, value, emit;

      return regeneratorRuntime.async(function ask$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(typeof question === 'function')) {
                _context2.next = 4;
                break;
              }

              _context2.next = 3;
              return regeneratorRuntime.awrap(question.call(this));

            case 3:
              question = _context2.sent;

            case 4:
              opts = utils.merge({}, this.options, question);
              _question = question, type = _question.type, name = _question.name;
              set = utils.set, get = utils.get;

              if (!(typeof type === 'function')) {
                _context2.next = 11;
                break;
              }

              _context2.next = 10;
              return regeneratorRuntime.awrap(type.call(this, question, this.answers));

            case 10:
              type = _context2.sent;

            case 11:
              if (type) {
                _context2.next = 13;
                break;
              }

              return _context2.abrupt("return", this.answers[name]);

            case 13:
              assert(this.prompts[type], "Prompt \"".concat(type, "\" is not registered"));
              prompt = new this.prompts[type](opts);
              value = get(this.answers, name);
              prompt.state.answers = this.answers;
              prompt.enquirer = this;

              if (name) {
                prompt.on('submit', function (value) {
                  _this2.emit('answer', name, value, prompt);

                  set(_this2.answers, name, value);
                });
              } // bubble events


              emit = prompt.emit.bind(prompt);

              prompt.emit = function () {
                var _this2$emit;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                (_this2$emit = _this2.emit).call.apply(_this2$emit, [_this2].concat(args));

                return emit.apply(void 0, args);
              };

              this.emit('prompt', prompt, this);

              if (!(opts.autofill && value != null)) {
                _context2.next = 29;
                break;
              }

              prompt.value = prompt.input = value; // if "autofill=show" render the prompt, otherwise stay "silent"

              if (!(opts.autofill === 'show')) {
                _context2.next = 27;
                break;
              }

              _context2.next = 27;
              return regeneratorRuntime.awrap(prompt.submit());

            case 27:
              _context2.next = 32;
              break;

            case 29:
              _context2.next = 31;
              return regeneratorRuntime.awrap(prompt.run());

            case 31:
              value = prompt.value = _context2.sent;

            case 32:
              return _context2.abrupt("return", value);

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Use an enquirer plugin.
     *
     * ```js
     * const Enquirer = require('enquirer');
     * const enquirer = new Enquirer();
     * const plugin = enquirer => {
     *   // do stuff to enquire instance
     * };
     * enquirer.use(plugin);
     * ```
     * @name use()
     * @param {Function} `plugin` Plugin function that takes an instance of Enquirer.
     * @return {Object} Returns the Enquirer instance.
     * @api public
     */

  }, {
    key: "use",
    value: function use(plugin) {
      plugin.call(this, this);
      return this;
    }
  }, {
    key: "Prompt",
    set: function set(value) {
      this._Prompt = value;
    },
    get: function get() {
      return this._Prompt || this.constructor.Prompt;
    }
  }, {
    key: "prompts",
    get: function get() {
      return this.constructor.prompts;
    }
  }], [{
    key: "Prompt",
    set: function set(value) {
      this._Prompt = value;
    },
    get: function get() {
      return this._Prompt || require('./lib/prompt');
    }
  }, {
    key: "prompts",
    get: function get() {
      return require('./lib/prompts');
    }
  }, {
    key: "types",
    get: function get() {
      return require('./lib/types');
    }
    /**
     * Prompt function that takes a "question" object or array of question objects,
     * and returns an object with responses from the user.
     *
     * ```js
     * const { prompt } = require('enquirer');
     * const response = await prompt({
     *   type: 'input',
     *   name: 'username',
     *   message: 'What is your username?'
     * });
     * console.log(response);
     * ```
     * @name Enquirer#prompt
     * @param {Array|Object} `questions` Options objects for one or more prompts to run.
     * @return {Promise} Promise that returns an "answers" object with the user's responses.
     * @api public
     */

  }, {
    key: "prompt",
    get: function get() {
      var _this3 = this;

      var fn = function fn(questions) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }

        var enquirer = _construct(_this3, rest);

        var emit = enquirer.emit.bind(enquirer);

        enquirer.emit = function () {
          fn.emit.apply(fn, arguments);
          return emit.apply(void 0, arguments);
        };

        return enquirer.prompt(questions);
      };

      utils.mixinEmitter(fn, new Events());
      return fn;
    }
  }]);

  return Enquirer;
}(Events);

utils.mixinEmitter(Enquirer, new Events());
var prompts = Enquirer.prompts;

var _loop = function _loop() {
  var name = _Object$keys2[_i2];
  var key = name.toLowerCase();

  var run = function run(options) {
    return new prompts[name](options).run();
  };

  Enquirer.prompt[key] = run;
  Enquirer[key] = run;

  if (!Enquirer[name]) {
    Reflect.defineProperty(Enquirer, name, {
      get: function get() {
        return prompts[name];
      }
    });
  }
};

for (var _i2 = 0, _Object$keys2 = Object.keys(prompts); _i2 < _Object$keys2.length; _i2++) {
  _loop();
}

var exp = function exp(name) {
  utils.defineExport(Enquirer, name, function () {
    return Enquirer.types[name];
  });
};

exp('ArrayPrompt');
exp('AuthPrompt');
exp('BooleanPrompt');
exp('NumberPrompt');
exp('StringPrompt');
module.exports = Enquirer;