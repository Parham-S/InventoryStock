'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Root = require('./root');

var Value = require('./value');

var AtWord = require('./atword');

var Colon = require('./colon');

var Comma = require('./comma');

var Comment = require('./comment');

var Func = require('./function');

var Numbr = require('./number');

var Operator = require('./operator');

var Paren = require('./paren');

var Str = require('./string');

var Word = require('./word');

var UnicodeRange = require('./unicode-range');

var tokenize = require('./tokenize');

var flatten = require('flatten');

var indexesOf = require('indexes-of');

var uniq = require('uniq');

var ParserError = require('./errors/ParserError');

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

module.exports =
/*#__PURE__*/
function () {
  function Parser(input, options) {
    _classCallCheck(this, Parser);

    var defaults = {
      loose: false
    }; // cache needs to be an array for values with more than 1 level of function nesting

    this.cache = [];
    this.input = input;
    this.options = Object.assign({}, defaults, options);
    this.position = 0; // we'll use this to keep track of the paren balance

    this.unbalanced = 0;
    this.root = new Root();
    var value = new Value();
    this.root.append(value);
    this.current = value;
    this.tokens = tokenize(input, this.options);
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse() {
      return this.loop();
    }
  }, {
    key: "colon",
    value: function colon() {
      var token = this.currToken;
      this.newNode(new Colon({
        value: token[1],
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6]
      }));
      this.position++;
    }
  }, {
    key: "comma",
    value: function comma() {
      var token = this.currToken;
      this.newNode(new Comma({
        value: token[1],
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6]
      }));
      this.position++;
    }
  }, {
    key: "comment",
    value: function comment() {
      var inline = false,
          value = this.currToken[1].replace(/\/\*|\*\//g, ''),
          node;

      if (this.options.loose && value.startsWith("//")) {
        value = value.substring(2);
        inline = true;
      }

      node = new Comment({
        value: value,
        inline: inline,
        source: {
          start: {
            line: this.currToken[2],
            column: this.currToken[3]
          },
          end: {
            line: this.currToken[4],
            column: this.currToken[5]
          }
        },
        sourceIndex: this.currToken[6]
      });
      this.newNode(node);
      this.position++;
    }
  }, {
    key: "error",
    value: function error(message, token) {
      throw new ParserError(message + " at line: ".concat(token[2], ", column ").concat(token[3]));
    }
  }, {
    key: "loop",
    value: function loop() {
      while (this.position < this.tokens.length) {
        this.parseTokens();
      }

      if (!this.current.last && this.spaces) {
        this.current.raws.before += this.spaces;
      } else if (this.spaces) {
        this.current.last.raws.after += this.spaces;
      }

      this.spaces = '';
      return this.root;
    }
  }, {
    key: "operator",
    value: function operator() {
      // if a +|- operator is followed by a non-word character (. is allowed) and
      // is preceded by a non-word character. (5+5)
      var _char = this.currToken[1],
          node;

      if (_char === '+' || _char === '-') {
        // only inspect if the operator is not the first token, and we're only
        // within a calc() function: the only spec-valid place for math expressions
        if (!this.options.loose) {
          if (this.position > 0) {
            if (this.current.type === 'func' && this.current.value === 'calc') {
              // allow operators to be proceeded by spaces and opening parens
              if (this.prevToken[0] !== 'space' && this.prevToken[0] !== '(') {
                this.error('Syntax Error', this.currToken);
              } // valid: calc(1 - +2)
              // invalid: calc(1 -+2)
              else if (this.nextToken[0] !== 'space' && this.nextToken[0] !== 'word') {
                  this.error('Syntax Error', this.currToken);
                } // valid: calc(1 - +2)
                // valid: calc(-0.5 + 2)
                // invalid: calc(1 -2)
                else if (this.nextToken[0] === 'word' && this.current.last.type !== 'operator' && this.current.last.value !== '(') {
                    this.error('Syntax Error', this.currToken);
                  }
            } // if we're not in a function and someone has doubled up on operators,
            // or they're trying to perform a calc outside of a calc
            // eg. +-4px or 5+ 5, throw an error
            else if (this.nextToken[0] === 'space' || this.nextToken[0] === 'operator' || this.prevToken[0] === 'operator') {
                this.error('Syntax Error', this.currToken);
              }
          }
        }

        if (!this.options.loose) {
          if (this.nextToken[0] === 'word') {
            return this.word();
          }
        } else {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === 'operator') && this.nextToken[0] === 'word') {
            return this.word();
          }
        }
      }

      node = new Operator({
        value: this.currToken[1],
        source: {
          start: {
            line: this.currToken[2],
            column: this.currToken[3]
          },
          end: {
            line: this.currToken[2],
            column: this.currToken[3]
          }
        },
        sourceIndex: this.currToken[4]
      });
      this.position++;
      return this.newNode(node);
    }
  }, {
    key: "parseTokens",
    value: function parseTokens() {
      switch (this.currToken[0]) {
        case 'space':
          this.space();
          break;

        case 'colon':
          this.colon();
          break;

        case 'comma':
          this.comma();
          break;

        case 'comment':
          this.comment();
          break;

        case '(':
          this.parenOpen();
          break;

        case ')':
          this.parenClose();
          break;

        case 'atword':
        case 'word':
          this.word();
          break;

        case 'operator':
          this.operator();
          break;

        case 'string':
          this.string();
          break;

        case 'unicoderange':
          this.unicodeRange();
          break;

        default:
          this.word();
          break;
      }
    }
  }, {
    key: "parenOpen",
    value: function parenOpen() {
      var unbalanced = 1,
          pos = this.position + 1,
          token = this.currToken,
          last; // check for balanced parens

      while (pos < this.tokens.length && unbalanced) {
        var tkn = this.tokens[pos];

        if (tkn[0] === '(') {
          unbalanced++;
        }

        if (tkn[0] === ')') {
          unbalanced--;
        }

        pos++;
      }

      if (unbalanced) {
        this.error('Expected closing parenthesis', token);
      } // ok, all parens are balanced. continue on


      last = this.current.last;

      if (last && last.type === 'func' && last.unbalanced < 0) {
        last.unbalanced = 0; // ok we're ready to add parens now

        this.current = last;
      }

      this.current.unbalanced++;
      this.newNode(new Paren({
        value: token[1],
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6]
      }));
      this.position++; // url functions get special treatment, and anything between the function
      // parens get treated as one word, if the contents aren't not a string.

      if (this.current.type === 'func' && this.current.unbalanced && this.current.value === 'url' && this.currToken[0] !== 'string' && this.currToken[0] !== ')' && !this.options.loose) {
        var nextToken = this.nextToken,
            value = this.currToken[1],
            start = {
          line: this.currToken[2],
          column: this.currToken[3]
        };

        while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {
          this.position++;
          value += this.currToken[1];
          nextToken = this.nextToken;
        }

        if (this.position !== this.tokens.length - 1) {
          // skip the following word definition, or it'll be a duplicate
          this.position++;
          this.newNode(new Word({
            value: value,
            source: {
              start: start,
              end: {
                line: this.currToken[4],
                column: this.currToken[5]
              }
            },
            sourceIndex: this.currToken[6]
          }));
        }
      }
    }
  }, {
    key: "parenClose",
    value: function parenClose() {
      var token = this.currToken;
      this.newNode(new Paren({
        value: token[1],
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6]
      }));
      this.position++;

      if (this.position >= this.tokens.length - 1 && !this.current.unbalanced) {
        return;
      }

      this.current.unbalanced--;

      if (this.current.unbalanced < 0) {
        this.error('Expected opening parenthesis', token);
      }

      if (!this.current.unbalanced && this.cache.length) {
        this.current = this.cache.pop();
      }
    }
  }, {
    key: "space",
    value: function space() {
      var token = this.currToken; // Handle space before and after the selector

      if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {
        this.current.last.raws.after += token[1];
        this.position++;
      } else {
        this.spaces = token[1];
        this.position++;
      }
    }
  }, {
    key: "unicodeRange",
    value: function unicodeRange() {
      var token = this.currToken;
      this.newNode(new UnicodeRange({
        value: token[1],
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6]
      }));
      this.position++;
    }
  }, {
    key: "splitWord",
    value: function splitWord() {
      var _this = this;

      var nextToken = this.nextToken,
          word = this.currToken[1],
          rNumber = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/,
          // treat css-like groupings differently so they can be inspected,
      // but don't address them as anything but a word, but allow hex values
      // to pass through.
      rNoFollow = /^(?!\#([a-z0-9]+))[\#\{\}]/gi,
          hasAt,
          indices;

      if (!rNoFollow.test(word)) {
        while (nextToken && nextToken[0] === 'word') {
          this.position++;
          var current = this.currToken[1];
          word += current;
          nextToken = this.nextToken;
        }
      }

      hasAt = indexesOf(word, '@');
      indices = sortAscending(uniq(flatten([[0], hasAt])));
      indices.forEach(function (ind, i) {
        var index = indices[i + 1] || word.length,
            value = word.slice(ind, index),
            node;

        if (~hasAt.indexOf(ind)) {
          node = new AtWord({
            value: value.slice(1),
            source: {
              start: {
                line: _this.currToken[2],
                column: _this.currToken[3] + ind
              },
              end: {
                line: _this.currToken[4],
                column: _this.currToken[3] + (index - 1)
              }
            },
            sourceIndex: _this.currToken[6] + indices[i]
          });
        } else if (rNumber.test(_this.currToken[1])) {
          var unit = value.replace(rNumber, '');
          node = new Numbr({
            value: value.replace(unit, ''),
            source: {
              start: {
                line: _this.currToken[2],
                column: _this.currToken[3] + ind
              },
              end: {
                line: _this.currToken[4],
                column: _this.currToken[3] + (index - 1)
              }
            },
            sourceIndex: _this.currToken[6] + indices[i],
            unit: unit
          });
        } else {
          node = new (nextToken && nextToken[0] === '(' ? Func : Word)({
            value: value,
            source: {
              start: {
                line: _this.currToken[2],
                column: _this.currToken[3] + ind
              },
              end: {
                line: _this.currToken[4],
                column: _this.currToken[3] + (index - 1)
              }
            },
            sourceIndex: _this.currToken[6] + indices[i]
          });

          if (node.constructor.name === 'Word') {
            node.isHex = /^#(.+)/.test(value);
            node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(value);
          } else {
            _this.cache.push(_this.current);
          }
        }

        _this.newNode(node);
      });
      this.position++;
    }
  }, {
    key: "string",
    value: function string() {
      var token = this.currToken,
          value = this.currToken[1],
          rQuote = /^(\"|\')/,
          quoted = rQuote.test(value),
          quote = '',
          node;

      if (quoted) {
        quote = value.match(rQuote)[0]; // set value to the string within the quotes
        // quotes are stored in raws

        value = value.slice(1, value.length - 1);
      }

      node = new Str({
        value: value,
        source: {
          start: {
            line: token[2],
            column: token[3]
          },
          end: {
            line: token[4],
            column: token[5]
          }
        },
        sourceIndex: token[6],
        quoted: quoted
      });
      node.raws.quote = quote;
      this.newNode(node);
      this.position++;
    }
  }, {
    key: "word",
    value: function word() {
      return this.splitWord();
    }
  }, {
    key: "newNode",
    value: function newNode(node) {
      if (this.spaces) {
        node.raws.before += this.spaces;
        this.spaces = '';
      }

      return this.current.append(node);
    }
  }, {
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();