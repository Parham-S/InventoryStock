'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Node = require('./node');

var Container =
/*#__PURE__*/
function (_Node) {
  _inherits(Container, _Node);

  function Container(opts) {
    var _this;

    _classCallCheck(this, Container);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, opts));

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  _createClass(Container, [{
    key: "push",
    value: function push(child) {
      child.parent = this;
      this.nodes.push(child);
      return this;
    }
  }, {
    key: "each",
    value: function each(callback) {
      if (!this.lastEach) this.lastEach = 0;
      if (!this.indexes) this.indexes = {};
      this.lastEach += 1;
      var id = this.lastEach,
          index,
          result;
      this.indexes[id] = 0;
      if (!this.nodes) return undefined;

      while (this.indexes[id] < this.nodes.length) {
        index = this.indexes[id];
        result = callback(this.nodes[index], index);
        if (result === false) break;
        this.indexes[id] += 1;
      }

      delete this.indexes[id];
      return result;
    }
  }, {
    key: "walk",
    value: function walk(callback) {
      return this.each(function (child, i) {
        var result = callback(child, i);

        if (result !== false && child.walk) {
          result = child.walk(callback);
        }

        return result;
      });
    }
  }, {
    key: "walkType",
    value: function walkType(type, callback) {
      var _this2 = this;

      if (!type || !callback) {
        throw new Error('Parameters {type} and {callback} are required.');
      } // allow users to pass a constructor, or node type string; eg. Word.


      var isTypeCallable = typeof type === 'function';
      return this.walk(function (node, index) {
        if (isTypeCallable && node instanceof type || !isTypeCallable && node.type === type) {
          return callback.call(_this2, node, index);
        }
      });
    }
  }, {
    key: "append",
    value: function append(node) {
      node.parent = this;
      this.nodes.push(node);
      return this;
    }
  }, {
    key: "prepend",
    value: function prepend(node) {
      node.parent = this;
      this.nodes.unshift(node);
      return this;
    }
  }, {
    key: "cleanRaws",
    value: function cleanRaws(keepBetween) {
      _get(_getPrototypeOf(Container.prototype), "cleanRaws", this).call(this, keepBetween);

      if (this.nodes) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;
            node.cleanRaws(keepBetween);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(oldNode, newNode) {
      var oldIndex = this.index(oldNode),
          index;
      this.nodes.splice(oldIndex + 1, 0, newNode);

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (oldIndex <= index) {
          this.indexes[id] = index + this.nodes.length;
        }
      }

      return this;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(oldNode, newNode) {
      var oldIndex = this.index(oldNode),
          index;
      this.nodes.splice(oldIndex, 0, newNode);

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (oldIndex <= index) {
          this.indexes[id] = index + this.nodes.length;
        }
      }

      return this;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      child = this.index(child);
      this.nodes[child].parent = undefined;
      this.nodes.splice(child, 1);
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }

      return this;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var node = _step2.value;
          node.parent = undefined;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.nodes = [];
      return this;
    }
  }, {
    key: "every",
    value: function every(condition) {
      return this.nodes.every(condition);
    }
  }, {
    key: "some",
    value: function some(condition) {
      return this.nodes.some(condition);
    }
  }, {
    key: "index",
    value: function index(child) {
      if (typeof child === 'number') {
        return child;
      } else {
        return this.nodes.indexOf(child);
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      var result = this.nodes.map(String).join('');

      if (this.value) {
        result = this.value + result;
      }

      if (this.raws.before) {
        result = this.raws.before + result;
      }

      if (this.raws.after) {
        result += this.raws.after;
      }

      return result;
    }
  }, {
    key: "first",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[0];
    }
  }, {
    key: "last",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[this.nodes.length - 1];
    }
  }]);

  return Container;
}(Node);

Container.registerWalker = function (constructor) {
  var walkerName = 'walk' + constructor.name; // plural sugar

  if (walkerName.lastIndexOf('s') !== walkerName.length - 1) {
    walkerName += 's';
  }

  if (Container.prototype[walkerName]) {
    return;
  } // we need access to `this` so we can't use an arrow function


  Container.prototype[walkerName] = function (callback) {
    return this.walkType(constructor, callback);
  };
};

module.exports = Container;