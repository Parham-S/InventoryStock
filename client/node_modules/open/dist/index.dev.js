'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('util'),
    promisify = _require.promisify;

var path = require('path');

var childProcess = require('child_process');

var fs = require('fs');

var isWsl = require('is-wsl');

var isDocker = require('is-docker');

var pAccess = promisify(fs.access);
var pReadFile = promisify(fs.readFile); // Path to included `xdg-open`.

var localXdgOpenPath = path.join(__dirname, 'xdg-open');
/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string} The mount point.
*/

var getWslDrivesMountPoint = function () {
  // Default value for "root" param
  // according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
  var defaultMountPoint = '/mnt/';
  var mountPoint;
  return function _callee() {
    var configFilePath, isConfigFileExists, configContent, configMountPoint;
    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!mountPoint) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", mountPoint);

          case 2:
            configFilePath = '/etc/wsl.conf';
            isConfigFileExists = false;
            _context.prev = 4;
            _context.next = 7;
            return regeneratorRuntime.awrap(pAccess(configFilePath, fs.constants.F_OK));

          case 7:
            isConfigFileExists = true;
            _context.next = 12;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](4);

          case 12:
            if (isConfigFileExists) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", defaultMountPoint);

          case 14:
            _context.next = 16;
            return regeneratorRuntime.awrap(pReadFile(configFilePath, {
              encoding: 'utf8'
            }));

          case 16:
            configContent = _context.sent;
            configMountPoint = /root\s*=\s*(.*)/g.exec(configContent);

            if (configMountPoint) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", defaultMountPoint);

          case 20:
            mountPoint = configMountPoint[1].trim();
            mountPoint = mountPoint.endsWith('/') ? mountPoint : mountPoint + '/';
            return _context.abrupt("return", mountPoint);

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, null, null, [[4, 10]]);
  };
}();

module.exports = function _callee2(target, options) {
  var command, _options, app, appArguments, cliArguments, childProcessOptions, mountPoint, encodedArguments, isBundled, exeLocalXdgOpen, useSystemXdgOpen, subprocess;

  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof target !== 'string')) {
            _context2.next = 2;
            break;
          }

          throw new TypeError('Expected a `target`');

        case 2:
          options = _objectSpread({
            wait: false,
            background: false,
            allowNonzeroExitCode: false
          }, options);
          _options = options, app = _options.app;
          appArguments = [];
          cliArguments = [];
          childProcessOptions = {};

          if (Array.isArray(app)) {
            appArguments = app.slice(1);
            app = app[0];
          }

          if (!(process.platform === 'darwin')) {
            _context2.next = 15;
            break;
          }

          command = 'open';

          if (options.wait) {
            cliArguments.push('--wait-apps');
          }

          if (options.background) {
            cliArguments.push('--background');
          }

          if (app) {
            cliArguments.push('-a', app);
          }

          _context2.next = 47;
          break;

        case 15:
          if (!(process.platform === 'win32' || isWsl && !isDocker())) {
            _context2.next = 29;
            break;
          }

          _context2.next = 18;
          return regeneratorRuntime.awrap(getWslDrivesMountPoint());

        case 18:
          mountPoint = _context2.sent;
          command = isWsl ? "".concat(mountPoint, "c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe") : "".concat(process.env.SYSTEMROOT, "\\System32\\WindowsPowerShell\\v1.0\\powershell");
          cliArguments.push('-NoProfile', '-NonInteractive', 'â€“ExecutionPolicy', 'Bypass', '-EncodedCommand');

          if (!isWsl) {
            childProcessOptions.windowsVerbatimArguments = true;
          }

          encodedArguments = ['Start'];

          if (options.wait) {
            encodedArguments.push('-Wait');
          }

          if (app) {
            // Double quote with double quotes to ensure the inner quotes are passed through.
            // Inner quotes are delimited for PowerShell interpretation with backticks.
            encodedArguments.push("\"`\"".concat(app, "`\"\""), '-ArgumentList');
            appArguments.unshift(target);
          } else {
            encodedArguments.push("\"".concat(target, "\""));
          }

          if (appArguments.length > 0) {
            appArguments = appArguments.map(function (arg) {
              return "\"`\"".concat(arg, "`\"\"");
            });
            encodedArguments.push(appArguments.join(','));
          } // Using Base64-encoded command, accepted by PowerShell, to allow special characters.


          target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
          _context2.next = 47;
          break;

        case 29:
          if (!app) {
            _context2.next = 33;
            break;
          }

          command = app;
          _context2.next = 45;
          break;

        case 33:
          // When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
          isBundled = !__dirname || __dirname === '/'; // Check if local `xdg-open` exists and is executable.

          exeLocalXdgOpen = false;
          _context2.prev = 35;
          _context2.next = 38;
          return regeneratorRuntime.awrap(pAccess(localXdgOpenPath, fs.constants.X_OK));

        case 38:
          exeLocalXdgOpen = true;
          _context2.next = 43;
          break;

        case 41:
          _context2.prev = 41;
          _context2.t0 = _context2["catch"](35);

        case 43:
          useSystemXdgOpen = process.versions.electron || process.platform === 'android' || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;

        case 45:
          if (appArguments.length > 0) {
            cliArguments.push.apply(cliArguments, _toConsumableArray(appArguments));
          }

          if (!options.wait) {
            // `xdg-open` will block the process unless stdio is ignored
            // and it's detached from the parent even if it's unref'd.
            childProcessOptions.stdio = 'ignore';
            childProcessOptions.detached = true;
          }

        case 47:
          cliArguments.push(target);

          if (process.platform === 'darwin' && appArguments.length > 0) {
            cliArguments.push.apply(cliArguments, ['--args'].concat(_toConsumableArray(appArguments)));
          }

          subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

          if (!options.wait) {
            _context2.next = 52;
            break;
          }

          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            subprocess.once('error', reject);
            subprocess.once('close', function (exitCode) {
              if (options.allowNonzeroExitCode && exitCode > 0) {
                reject(new Error("Exited with code ".concat(exitCode)));
                return;
              }

              resolve(subprocess);
            });
          }));

        case 52:
          subprocess.unref();
          return _context2.abrupt("return", subprocess);

        case 54:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[35, 41]]);
};