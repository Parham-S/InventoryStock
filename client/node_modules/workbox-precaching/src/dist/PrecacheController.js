"use strict";
/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.PrecacheController = void 0;
var assert_js_1 = require("workbox-core/_private/assert.js");
var cacheNames_js_1 = require("workbox-core/_private/cacheNames.js");
var cacheWrapper_js_1 = require("workbox-core/_private/cacheWrapper.js");
var fetchWrapper_js_1 = require("workbox-core/_private/fetchWrapper.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var WorkboxError_js_1 = require("workbox-core/_private/WorkboxError.js");
var copyResponse_js_1 = require("workbox-core/copyResponse.js");
var createCacheKey_js_1 = require("./utils/createCacheKey.js");
var printCleanupDetails_js_1 = require("./utils/printCleanupDetails.js");
var printInstallDetails_js_1 = require("./utils/printInstallDetails.js");
require("./_version.js");
/**
 * Performs efficient precaching of assets.
 *
 * @memberof module:workbox-precaching
 */
var PrecacheController = /** @class */ (function () {
    /**
     * Create a new PrecacheController.
     *
     * @param {string} [cacheName] An optional name for the cache, to override
     * the default precache name.
     */
    function PrecacheController(cacheName) {
        this._cacheName = cacheNames_js_1.cacheNames.getPrecacheName(cacheName);
        this._urlsToCacheKeys = new Map();
        this._urlsToCacheModes = new Map();
        this._cacheKeysToIntegrities = new Map();
    }
    /**
     * This method will add items to the precache list, removing duplicates
     * and ensuring the information is valid.
     *
     * @param {
     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>
     * } entries Array of entries to precache.
     */
    PrecacheController.prototype.addToCacheList = function (entries) {
        if (process.env.NODE_ENV !== 'production') {
            assert_js_1.assert.isArray(entries, {
                moduleName: 'workbox-precaching',
                className: 'PrecacheController',
                funcName: 'addToCacheList',
                paramName: 'entries'
            });
        }
        var urlsToWarnAbout = [];
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            // See https://github.com/GoogleChrome/workbox/issues/2259
            if (typeof entry === 'string') {
                urlsToWarnAbout.push(entry);
            }
            else if (entry && entry.revision === undefined) {
                urlsToWarnAbout.push(entry.url);
            }
            var _a = createCacheKey_js_1.createCacheKey(entry), cacheKey = _a.cacheKey, url = _a.url;
            var cacheMode = (typeof entry !== 'string' && entry.revision) ?
                'reload' : 'default';
            if (this._urlsToCacheKeys.has(url) &&
                this._urlsToCacheKeys.get(url) !== cacheKey) {
                throw new WorkboxError_js_1.WorkboxError('add-to-cache-list-conflicting-entries', {
                    firstEntry: this._urlsToCacheKeys.get(url),
                    secondEntry: cacheKey
                });
            }
            if (typeof entry !== 'string' && entry.integrity) {
                if (this._cacheKeysToIntegrities.has(cacheKey) &&
                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
                    throw new WorkboxError_js_1.WorkboxError('add-to-cache-list-conflicting-integrities', {
                        url: url
                    });
                }
                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
            }
            this._urlsToCacheKeys.set(url, cacheKey);
            this._urlsToCacheModes.set(url, cacheMode);
            if (urlsToWarnAbout.length > 0) {
                var warningMessage = "Workbox is precaching URLs without revision " +
                    ("info: " + urlsToWarnAbout.join(', ') + "\nThis is generally NOT safe. ") +
                    "Learn more at https://bit.ly/wb-precache";
                if (process.env.NODE_ENV === 'production') {
                    // Use console directly to display this warning without bloating
                    // bundle sizes by pulling in all of the logger codebase in prod.
                    console.warn(warningMessage);
                }
                else {
                    logger_js_1.logger.warn(warningMessage);
                }
            }
        }
    };
    /**
     * Precaches new and updated assets. Call this method from the service worker
     * install event.
     *
     * @param {Object} options
     * @param {Event} [options.event] The install event (if needed).
     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching
     * and caching during install.
     * @return {Promise<module:workbox-precaching.InstallResult>}
     */
    PrecacheController.prototype.install = function (_a) {
        var _b = _a === void 0 ? {} : _a, event = _b.event, plugins = _b.plugins;
        return __awaiter(this, void 0, void 0, function () {
            var toBePrecached, alreadyPrecached, cache, alreadyCachedRequests, existingCacheKeys, _i, _c, _d, url, cacheKey, precacheRequests, updatedURLs;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (process.env.NODE_ENV !== 'production') {
                            if (plugins) {
                                assert_js_1.assert.isArray(plugins, {
                                    moduleName: 'workbox-precaching',
                                    className: 'PrecacheController',
                                    funcName: 'install',
                                    paramName: 'plugins'
                                });
                            }
                        }
                        toBePrecached = [];
                        alreadyPrecached = [];
                        return [4 /*yield*/, self.caches.open(this._cacheName)];
                    case 1:
                        cache = _e.sent();
                        return [4 /*yield*/, cache.keys()];
                    case 2:
                        alreadyCachedRequests = _e.sent();
                        existingCacheKeys = new Set(alreadyCachedRequests.map(function (request) { return request.url; }));
                        for (_i = 0, _c = this._urlsToCacheKeys; _i < _c.length; _i++) {
                            _d = _c[_i], url = _d[0], cacheKey = _d[1];
                            if (existingCacheKeys.has(cacheKey)) {
                                alreadyPrecached.push(url);
                            }
                            else {
                                toBePrecached.push({ cacheKey: cacheKey, url: url });
                            }
                        }
                        precacheRequests = toBePrecached.map(function (_a) {
                            var cacheKey = _a.cacheKey, url = _a.url;
                            var integrity = _this._cacheKeysToIntegrities.get(cacheKey);
                            var cacheMode = _this._urlsToCacheModes.get(url);
                            return _this._addURLToCache({
                                cacheKey: cacheKey,
                                cacheMode: cacheMode,
                                event: event,
                                integrity: integrity,
                                plugins: plugins,
                                url: url
                            });
                        });
                        return [4 /*yield*/, Promise.all(precacheRequests)];
                    case 3:
                        _e.sent();
                        updatedURLs = toBePrecached.map(function (item) { return item.url; });
                        if (process.env.NODE_ENV !== 'production') {
                            printInstallDetails_js_1.printInstallDetails(updatedURLs, alreadyPrecached);
                        }
                        return [2 /*return*/, {
                                updatedURLs: updatedURLs,
                                notUpdatedURLs: alreadyPrecached
                            }];
                }
            });
        });
    };
    /**
     * Deletes assets that are no longer present in the current precache manifest.
     * Call this method from the service worker activate event.
     *
     * @return {Promise<module:workbox-precaching.CleanupResult>}
     */
    PrecacheController.prototype.activate = function () {
        return __awaiter(this, void 0, void 0, function () {
            var cache, currentlyCachedRequests, expectedCacheKeys, deletedURLs, _i, currentlyCachedRequests_1, request;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.caches.open(this._cacheName)];
                    case 1:
                        cache = _a.sent();
                        return [4 /*yield*/, cache.keys()];
                    case 2:
                        currentlyCachedRequests = _a.sent();
                        expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
                        deletedURLs = [];
                        _i = 0, currentlyCachedRequests_1 = currentlyCachedRequests;
                        _a.label = 3;
                    case 3:
                        if (!(_i < currentlyCachedRequests_1.length)) return [3 /*break*/, 6];
                        request = currentlyCachedRequests_1[_i];
                        if (!!expectedCacheKeys.has(request.url)) return [3 /*break*/, 5];
                        return [4 /*yield*/, cache["delete"](request)];
                    case 4:
                        _a.sent();
                        deletedURLs.push(request.url);
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 3];
                    case 6:
                        if (process.env.NODE_ENV !== 'production') {
                            printCleanupDetails_js_1.printCleanupDetails(deletedURLs);
                        }
                        return [2 /*return*/, { deletedURLs: deletedURLs }];
                }
            });
        });
    };
    /**
     * Requests the entry and saves it to the cache if the response is valid.
     * By default, any response with a status code of less than 400 (including
     * opaque responses) is considered valid.
     *
     * If you need to use custom criteria to determine what's valid and what
     * isn't, then pass in an item in `options.plugins` that implements the
     * `cacheWillUpdate()` lifecycle event.
     *
     * @private
     * @param {Object} options
     * @param {string} options.cacheKey The string to use a cache key.
     * @param {string} options.url The URL to fetch and cache.
     * @param {string} [options.cacheMode] The cache mode for the network request.
     * @param {Event} [options.event] The install event (if passed).
     * @param {Array<Object>} [options.plugins] An array of plugins to apply to
     * fetch and caching.
     * @param {string} [options.integrity] The value to use for the `integrity`
     * field when making the request.
     */
    PrecacheController.prototype._addURLToCache = function (_a) {
        var cacheKey = _a.cacheKey, url = _a.url, cacheMode = _a.cacheMode, event = _a.event, plugins = _a.plugins, integrity = _a.integrity;
        return __awaiter(this, void 0, void 0, function () {
            var request, response, cacheWillUpdatePlugin, _i, _b, plugin, isValidResponse, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        request = new Request(url, {
                            integrity: integrity,
                            cache: cacheMode,
                            credentials: 'same-origin'
                        });
                        return [4 /*yield*/, fetchWrapper_js_1.fetchWrapper.fetch({
                                event: event,
                                plugins: plugins,
                                request: request
                            })];
                    case 1:
                        response = _d.sent();
                        for (_i = 0, _b = (plugins || []); _i < _b.length; _i++) {
                            plugin = _b[_i];
                            if ('cacheWillUpdate' in plugin) {
                                cacheWillUpdatePlugin = plugin;
                            }
                        }
                        if (!cacheWillUpdatePlugin) return [3 /*break*/, 3];
                        // Use a callback if provided. It returns a truthy value if valid.
                        // NOTE: invoke the method on the plugin instance so the `this` context
                        // is correct.
                        return [4 /*yield*/, cacheWillUpdatePlugin.cacheWillUpdate({ event: event, request: request, response: response })];
                    case 2:
                        // Use a callback if provided. It returns a truthy value if valid.
                        // NOTE: invoke the method on the plugin instance so the `this` context
                        // is correct.
                        _c = _d.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        // Otherwise, default to considering any response status under 400 valid.
                        // This includes, by default, considering opaque responses valid.
                        _c = response.status < 400;
                        _d.label = 4;
                    case 4:
                        isValidResponse = _c;
                        // Consider this a failure, leading to the `install` handler failing, if
                        // we get back an invalid response.
                        if (!isValidResponse) {
                            throw new WorkboxError_js_1.WorkboxError('bad-precaching-response', {
                                url: url,
                                status: response.status
                            });
                        }
                        if (!response.redirected) return [3 /*break*/, 6];
                        return [4 /*yield*/, copyResponse_js_1.copyResponse(response)];
                    case 5:
                        response = _d.sent();
                        _d.label = 6;
                    case 6: return [4 /*yield*/, cacheWrapper_js_1.cacheWrapper.put({
                            event: event,
                            plugins: plugins,
                            response: response,
                            // `request` already uses `url`. We may be able to reuse it.
                            request: cacheKey === url ? request : new Request(cacheKey),
                            cacheName: this._cacheName,
                            matchOptions: {
                                ignoreSearch: true
                            }
                        })];
                    case 7:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a mapping of a precached URL to the corresponding cache key, taking
     * into account the revision information for the URL.
     *
     * @return {Map<string, string>} A URL to cache key mapping.
     */
    PrecacheController.prototype.getURLsToCacheKeys = function () {
        return this._urlsToCacheKeys;
    };
    /**
     * Returns a list of all the URLs that have been precached by the current
     * service worker.
     *
     * @return {Array<string>} The precached URLs.
     */
    PrecacheController.prototype.getCachedURLs = function () {
        return __spreadArrays(this._urlsToCacheKeys.keys());
    };
    /**
     * Returns the cache key used for storing a given URL. If that URL is
     * unversioned, like `/index.html', then the cache key will be the original
     * URL with a search parameter appended to it.
     *
     * @param {string} url A URL whose cache key you want to look up.
     * @return {string} The versioned URL that corresponds to a cache key
     * for the original URL, or undefined if that URL isn't precached.
     */
    PrecacheController.prototype.getCacheKeyForURL = function (url) {
        var urlObject = new URL(url, location.href);
        return this._urlsToCacheKeys.get(urlObject.href);
    };
    /**
     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
     * with the following differences:
     *
     * - It knows what the name of the precache is, and only checks in that cache.
     * - It allows you to pass in an "original" URL without versioning parameters,
     * and it will automatically look up the correct cache key for the currently
     * active revision of that URL.
     *
     * E.g., `matchPrecache('index.html')` will find the correct precached
     * response for the currently active service worker, even if the actual cache
     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
     *
     * @param {string|Request} request The key (without revisioning parameters)
     * to look up in the precache.
     * @return {Promise<Response|undefined>}
     */
    PrecacheController.prototype.matchPrecache = function (request) {
        return __awaiter(this, void 0, Promise, function () {
            var url, cacheKey, cache;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = request instanceof Request ? request.url : request;
                        cacheKey = this.getCacheKeyForURL(url);
                        if (!cacheKey) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.caches.open(this._cacheName)];
                    case 1:
                        cache = _a.sent();
                        return [2 /*return*/, cache.match(cacheKey)];
                    case 2: return [2 /*return*/, undefined];
                }
            });
        });
    };
    /**
     * Returns a function that can be used within a
     * {@link module:workbox-routing.Route} that will find a response for the
     * incoming request against the precache.
     *
     * If for an unexpected reason there is a cache miss for the request,
     * this will fall back to retrieving the `Response` via `fetch()` when
     * `fallbackToNetwork` is `true`.
     *
     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the
     * response from the network if there's a precache miss.
     * @return {module:workbox-routing~handlerCallback}
     */
    PrecacheController.prototype.createHandler = function (fallbackToNetwork) {
        var _this = this;
        if (fallbackToNetwork === void 0) { fallbackToNetwork = true; }
        return function (_a) {
            var request = _a.request;
            return __awaiter(_this, void 0, void 0, function () {
                var response, error_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.matchPrecache(request)];
                        case 1:
                            response = _b.sent();
                            if (response) {
                                return [2 /*return*/, response];
                            }
                            // This shouldn't normally happen, but there are edge cases:
                            // https://github.com/GoogleChrome/workbox/issues/1441
                            throw new WorkboxError_js_1.WorkboxError('missing-precache-entry', {
                                cacheName: this._cacheName,
                                url: request instanceof Request ? request.url : request
                            });
                        case 2:
                            error_1 = _b.sent();
                            if (fallbackToNetwork) {
                                if (process.env.NODE_ENV !== 'production') {
                                    logger_js_1.logger.debug("Unable to respond with precached response. " +
                                        "Falling back to network.", error_1);
                                }
                                return [2 /*return*/, fetch(request)];
                            }
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
    };
    /**
     * Returns a function that looks up `url` in the precache (taking into
     * account revision information), and returns the corresponding `Response`.
     *
     * If for an unexpected reason there is a cache miss when looking up `url`,
     * this will fall back to retrieving the `Response` via `fetch()` when
     * `fallbackToNetwork` is `true`.
     *
     * @param {string} url The precached URL which will be used to lookup the
     * `Response`.
     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the
     * response from the network if there's a precache miss.
     * @return {module:workbox-routing~handlerCallback}
     */
    PrecacheController.prototype.createHandlerBoundToURL = function (url, fallbackToNetwork) {
        if (fallbackToNetwork === void 0) { fallbackToNetwork = true; }
        var cacheKey = this.getCacheKeyForURL(url);
        if (!cacheKey) {
            throw new WorkboxError_js_1.WorkboxError('non-precached-url', { url: url });
        }
        var handler = this.createHandler(fallbackToNetwork);
        var request = new Request(url);
        return function () { return handler({ request: request }); };
    };
    return PrecacheController;
}());
exports.PrecacheController = PrecacheController;
