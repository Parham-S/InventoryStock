"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var browserslist = _interopDefault(require('browserslist'));

var postcss = _interopDefault(require('postcss'));

var index = postcss.plugin('postcss-browser-comments', function (opts) {
  return function (root) {
    // client browserslist
    var clientBrowserList = browserslist(Object(opts).browsers || null, {
      path: root.source && root.source.input && root.source.input.file
    }); // root children references

    var references = root.nodes.slice(0); // for each child node of the root children references

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        // if the node is a comment browser comment node
        if (isBrowserCommentNode(node)) {
          (function () {
            // rule following the browser comment
            var rule = node.next(); // browser data

            var browserdata = getBrowserData(node.text);

            if (browserdata.isNumbered) {
              rule.nodes.filter(isBrowserReferenceCommentNode).map(function (comment) {
                var browserdataIndex = parseFloat(comment.text) - 1;
                var browserslistPart = browserdata.browserslist[browserdataIndex]; // whether to remove the rule if the comment browserslist does not match the client browserslist

                var removeRule = !clientBrowserList.some(function (clientBrowser) {
                  return browserslist(browserslistPart).some(function (commentBrowser) {
                    return commentBrowser === clientBrowser;
                  });
                }); // conditionally remove the declaration and reference comment

                if (removeRule) {
                  comment.prev().remove();
                  comment.remove();
                }
              }); // conditionally remove the empty rule and comment

              if (!rule.nodes.length) {
                rule.remove();
                node.remove();
              }
            } else {
              // whether to remove the rule if the comment browserslist does not match the client browserslist
              var removeRule = !clientBrowserList.some(function (clientBrowser) {
                return browserslist(browserdata.browserslist).some(function (commentBrowser) {
                  return commentBrowser === clientBrowser;
                });
              }); // conditionally remove the rule and comment

              if (removeRule) {
                rule.remove();
                node.remove();
              }
            }
          })();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
}); // returns whether a node is a browser comment

var isBrowserCommentNode = function isBrowserCommentNode(node) {
  return node.type === 'comment' && isBrowserCommentNodeRegExp.test(node.text) && node.next().type === 'rule';
};

var isBrowserCommentNodeRegExp = /^\*\n * /; // returns whether a node is a browser reference comment

var isBrowserReferenceCommentNode = function isBrowserReferenceCommentNode(node) {
  return node.type === 'comment' && isBrowserReferenceCommentNodeRegExp.test(node.text);
};

var isBrowserReferenceCommentNodeRegExp = /^\d+$/; // returns browser data from comment text

var getBrowserData = function getBrowserData(text) {
  var browserDataNumbered = text.match(browserDataMutliRegExp);
  var isNumbered = Boolean(browserDataNumbered);
  return {
    browserslist: isNumbered ? browserDataNumbered.map(function (browserslistPart) {
      return getBrowsersList(browserslistPart.replace(browserDataNumberedNewlineRegExp, '$1'));
    }) : getBrowsersList(text.replace(browserDataNewlineRegExp, '')),
    isNumbered: isNumbered
  };
};

var browserDataMutliRegExp = /(\n \* \d+\. (?:[^\n]+|\n \* {4,})+)/g;
var browserDataNewlineRegExp = /^\*\n \* ?|\n \*/g;
var browserDataNumberedNewlineRegExp = /\n \* (?:( )\s*)?/g; // returns a browserlist from comment text

var getBrowsersList = function getBrowsersList(text) {
  return text.split(getBrowsersListInSplitRegExp).slice(1).map(function (part) {
    return part.split(getBrowsersListAndSplitRegExp).filter(function (part2) {
      return part2;
    });
  }).reduce(function (acc, val) {
    return acc.concat(val);
  }, []).map(function (part) {
    return part.replace(getBrowsersListQueryRegExp, function ($0, browser, query) {
      return browser === 'all' ? '> 0%' : "".concat(browser).concat(query ? /^((?:\d*\.)?\d+)-$/.test(query) ? " <= ".concat(query.slice(0, -1)) : " ".concat(query) : ' > 0');
    }).toLowerCase();
  });
};

var getBrowsersListInSplitRegExp = /\s+in\s+/;
var getBrowsersListAndSplitRegExp = /(?: and|, and|,)/;
var getBrowsersListQueryRegExp = /^\s*(\w+)(?: ((?:(?:\d*\.)?\d+-)?(?:\d*\.)?\d+[+-]?))?.*$/;
module.exports = index;