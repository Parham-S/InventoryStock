"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _browserslist = _interopRequireDefault(require("browserslist"));

var _postcss = _interopRequireDefault(require("postcss"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var index = _postcss["default"].plugin('postcss-browser-comments', function (opts) {
  return function (root) {
    // client browserslist
    var clientBrowserList = (0, _browserslist["default"])(Object(opts).browsers || null, {
      path: root.source && root.source.input && root.source.input.file
    }); // root children references

    var references = root.nodes.slice(0); // for each child node of the root children references

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        // if the node is a comment browser comment node
        if (isBrowserCommentNode(node)) {
          (function () {
            // rule following the browser comment
            var rule = node.next(); // browser data

            var browserdata = getBrowserData(node.text);

            if (browserdata.isNumbered) {
              rule.nodes.filter(isBrowserReferenceCommentNode).map(function (comment) {
                var browserdataIndex = parseFloat(comment.text) - 1;
                var browserslistPart = browserdata.browserslist[browserdataIndex]; // whether to remove the rule if the comment browserslist does not match the client browserslist

                var removeRule = !clientBrowserList.some(function (clientBrowser) {
                  return (0, _browserslist["default"])(browserslistPart).some(function (commentBrowser) {
                    return commentBrowser === clientBrowser;
                  });
                }); // conditionally remove the declaration and reference comment

                if (removeRule) {
                  comment.prev().remove();
                  comment.remove();
                }
              }); // conditionally remove the empty rule and comment

              if (!rule.nodes.length) {
                rule.remove();
                node.remove();
              }
            } else {
              // whether to remove the rule if the comment browserslist does not match the client browserslist
              var removeRule = !clientBrowserList.some(function (clientBrowser) {
                return (0, _browserslist["default"])(browserdata.browserslist).some(function (commentBrowser) {
                  return commentBrowser === clientBrowser;
                });
              }); // conditionally remove the rule and comment

              if (removeRule) {
                rule.remove();
                node.remove();
              }
            }
          })();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
}); // returns whether a node is a browser comment


var isBrowserCommentNode = function isBrowserCommentNode(node) {
  return node.type === 'comment' && isBrowserCommentNodeRegExp.test(node.text) && node.next().type === 'rule';
};

var isBrowserCommentNodeRegExp = /^\*\n * /; // returns whether a node is a browser reference comment

var isBrowserReferenceCommentNode = function isBrowserReferenceCommentNode(node) {
  return node.type === 'comment' && isBrowserReferenceCommentNodeRegExp.test(node.text);
};

var isBrowserReferenceCommentNodeRegExp = /^\d+$/; // returns browser data from comment text

var getBrowserData = function getBrowserData(text) {
  var browserDataNumbered = text.match(browserDataMutliRegExp);
  var isNumbered = Boolean(browserDataNumbered);
  return {
    browserslist: isNumbered ? browserDataNumbered.map(function (browserslistPart) {
      return getBrowsersList(browserslistPart.replace(browserDataNumberedNewlineRegExp, '$1'));
    }) : getBrowsersList(text.replace(browserDataNewlineRegExp, '')),
    isNumbered: isNumbered
  };
};

var browserDataMutliRegExp = /(\n \* \d+\. (?:[^\n]+|\n \* {4,})+)/g;
var browserDataNewlineRegExp = /^\*\n \* ?|\n \*/g;
var browserDataNumberedNewlineRegExp = /\n \* (?:( )\s*)?/g; // returns a browserlist from comment text

var getBrowsersList = function getBrowsersList(text) {
  return text.split(getBrowsersListInSplitRegExp).slice(1).map(function (part) {
    return part.split(getBrowsersListAndSplitRegExp).filter(function (part2) {
      return part2;
    });
  }).reduce(function (acc, val) {
    return acc.concat(val);
  }, []).map(function (part) {
    return part.replace(getBrowsersListQueryRegExp, function ($0, browser, query) {
      return browser === 'all' ? '> 0%' : "".concat(browser).concat(query ? /^((?:\d*\.)?\d+)-$/.test(query) ? " <= ".concat(query.slice(0, -1)) : " ".concat(query) : ' > 0');
    }).toLowerCase();
  });
};

var getBrowsersListInSplitRegExp = /\s+in\s+/;
var getBrowsersListAndSplitRegExp = /(?: and|, and|,)/;
var getBrowsersListQueryRegExp = /^\s*(\w+)(?: ((?:(?:\d*\.)?\d+-)?(?:\d*\.)?\d+[+-]?))?.*$/;
var _default = index;
exports["default"] = _default;