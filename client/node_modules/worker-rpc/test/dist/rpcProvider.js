"use strict";
/// <reference path="../typings/index.d.ts"/>
exports.__esModule = true;
var assert = require("assert");
var RpcProvider_1 = require("../src/RpcProvider");
suite('RPC provider', function () {
    var local, remote, transferLocalToRemote, transferRemoteToLocal, errorLocal, errorRemote;
    setup(function () {
        local = new RpcProvider_1["default"](function (message, transfer) { return (transferLocalToRemote = transfer, remote.dispatch(message)); }, 50);
        local.error.addHandler(function (err) { return errorLocal = err; });
        remote = new RpcProvider_1["default"](function (message, transfer) { return (transferRemoteToLocal = transfer, local.dispatch(message)); }, 50);
        remote.error.addHandler(function (err) { return errorRemote = err; });
        transferLocalToRemote = transferRemoteToLocal = undefined;
        errorRemote = errorLocal = undefined;
    });
    suite('signals', function () {
        test('Signals are propagated', function () {
            var x = -1;
            remote.registerSignalHandler('action', function (value) { return x = value; });
            local.signal('action', 5);
            assert(!errorLocal);
            assert(!errorRemote);
            assert.strictEqual(x, 5);
        });
        test('Unregistered signals raise an error', function () {
            local.signal('action', 10);
            assert(errorLocal);
            assert(errorRemote);
        });
        test('Multiple signals do not interfere', function () {
            var x = -1, y = -1;
            remote.registerSignalHandler('setx', function (value) { return x = value; });
            remote.registerSignalHandler('sety', function (value) { return y = value; });
            local.signal('setx', 5);
            local.signal('sety', 6);
            assert(!errorLocal);
            assert(!errorRemote);
            assert.strictEqual(x, 5);
            assert.strictEqual(y, 6);
        });
        test('Multiple handlers can be bound to one signal', function () {
            var x = -1;
            remote.registerSignalHandler('action', function (value) { return x = value; });
            local.signal('action', 1);
            local.signal('action', 2);
            assert(!errorLocal);
            assert(!errorRemote);
            assert.strictEqual(x, 2);
        });
        test('Handlers can be deregistered', function () {
            var x = -1;
            var handler = function (value) { return x = value; };
            remote.registerSignalHandler('action', handler);
            remote.deregisterSignalHandler('action', handler);
            local.signal('action', 5);
            assert(!errorLocal);
            assert(!errorRemote);
            assert.strictEqual(x, -1);
        });
        test('Transfer is honored', function () {
            var x = -1;
            var transfer = [1, 2, 3];
            remote.registerSignalHandler('action', function (value) { return x = value; });
            local.signal('action', 2, transfer);
            assert(!errorLocal);
            assert(!errorRemote);
            assert.strictEqual(x, 2);
            assert.strictEqual(transferLocalToRemote, transfer);
            assert(!transferRemoteToLocal);
        });
    });
    suite('RPC', function () {
        test('RPC handlers can return values', function () {
            remote.registerRpcHandler('action', function () { return 10; });
            return local
                .rpc('action')
                .then(function (result) { return (assert.strictEqual(result, 10),
                assert(!errorLocal),
                assert(!errorRemote)); });
        });
        test('RPC handlers can return promises', function () {
            remote.registerRpcHandler('action', function () { return new Promise(function (r) { return setTimeout(function () { return r(10); }, 15); }); });
            return local
                .rpc('action')
                .then(function (result) { return (assert.strictEqual(result, 10),
                assert(!errorLocal),
                assert(!errorRemote)); });
        });
        test('Promise rejection is transferred', function () {
            remote.registerRpcHandler('action', function () { return new Promise(function (resolve, reject) { return setTimeout(function () { return reject(10); }, 15); }); });
            return local
                .rpc('action')
                .then(function () { return Promise.reject('should have been rejected'); }, function (result) { return (assert.strictEqual(result, 10),
                assert(!errorLocal),
                assert(!errorRemote)); });
        });
        test('Invalid RPC calls are rejected', function () {
            return local
                .rpc('action')
                .then(function () { return Promise.reject('should have been rejected'); }, function () { return undefined; });
        });
        test('Invalid RPC calls throw on both ends', function () {
            return local
                .rpc('action')
                .then(function () { return Promise.reject('should have been rejected'); }, function () { return undefined; })
                .then(function () { return (assert(errorLocal),
                assert(errorRemote)); });
        });
        test('RPC calls time out', function () {
            remote.registerRpcHandler('action', function () { return new Promise(function (r) { return setTimeout(function () { return r(10); }, 100); }); });
            return local
                .rpc('action')
                .then(function () { return Promise.reject('should have been rejected'); }, function () { return (assert(errorLocal), new Promise(function (r) { return setTimeout(r, 100); })); })
                .then(function () { return assert(errorRemote); });
        });
        test('Multiple RPC handlers do not interfere', function () {
            remote.registerRpcHandler('a1', function (value) { return new Promise(function (r) { return setTimeout(function () { return r(value); }, 30); }); });
            remote.registerRpcHandler('a2', function (value) { return 2 * value; });
            return Promise
                .all([
                local.rpc('a1', 10),
                local.rpc('a2', 20)
            ])
                .then(function (_a) {
                var r1 = _a[0], r2 = _a[1];
                return (assert.strictEqual(r1, 10),
                    assert.strictEqual(r2, 40),
                    assert(!errorLocal),
                    assert(!errorRemote));
            });
        });
        test('RPC handler can be deregistered', function () {
            var handler = function () { return 10; };
            remote.registerRpcHandler('action', handler);
            remote.deregisterRpcHandler('action', handler);
            return local
                .rpc('action')
                .then(function () { return Promise.reject('should have been rejected'); }, function () { return (assert(errorLocal),
                assert(errorRemote)); });
        });
        test('Transfer is honored', function () {
            var transfer = [1, 2, 3];
            remote.registerRpcHandler('action', function () { return 10; });
            return local
                .rpc('action', undefined, transfer)
                .then(function (x) { return (assert.strictEqual(transferLocalToRemote, transfer),
                assert.strictEqual(x, 10),
                assert(!errorLocal),
                assert(!errorRemote)); });
        });
    });
});
