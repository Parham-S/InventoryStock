"use strict";
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.Queue = void 0;
var WorkboxError_js_1 = require("workbox-core/_private/WorkboxError.js");
var logger_js_1 = require("workbox-core/_private/logger.js");
var assert_js_1 = require("workbox-core/_private/assert.js");
var getFriendlyURL_js_1 = require("workbox-core/_private/getFriendlyURL.js");
var QueueStore_js_1 = require("./lib/QueueStore.js");
var StorableRequest_js_1 = require("./lib/StorableRequest.js");
require("./_version.js");
var TAG_PREFIX = 'workbox-background-sync';
var MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes
var queueNames = new Set();
/**
 * Converts a QueueStore entry into the format exposed by Queue. This entails
 * converting the request data into a real request and omitting the `id` and
 * `queueName` properties.
 *
 * @param {Object} queueStoreEntry
 * @return {Object}
 * @private
 */
var convertEntry = function (queueStoreEntry) {
    var queueEntry = {
        request: new StorableRequest_js_1.StorableRequest(queueStoreEntry.requestData).toRequest(),
        timestamp: queueStoreEntry.timestamp
    };
    if (queueStoreEntry.metadata) {
        queueEntry.metadata = queueStoreEntry.metadata;
    }
    return queueEntry;
};
/**
 * A class to manage storing failed requests in IndexedDB and retrying them
 * later. All parts of the storing and replaying process are observable via
 * callbacks.
 *
 * @memberof module:workbox-background-sync
 */
var Queue = /** @class */ (function () {
    /**
     * Creates an instance of Queue with the given options
     *
     * @param {string} name The unique name for this queue. This name must be
     *     unique as it's used to register sync events and store requests
     *     in IndexedDB specific to this instance. An error will be thrown if
     *     a duplicate name is detected.
     * @param {Object} [options]
     * @param {Function} [options.onSync] A function that gets invoked whenever
     *     the 'sync' event fires. The function is invoked with an object
     *     containing the `queue` property (referencing this instance), and you
     *     can use the callback to customize the replay behavior of the queue.
     *     When not set the `replayRequests()` method is called.
     *     Note: if the replay fails after a sync event, make sure you throw an
     *     error, so the browser knows to retry the sync event later.
     * @param {number} [options.maxRetentionTime=7 days] The amount of time (in
     *     minutes) a request may be retried. After this amount of time has
     *     passed, the request will be deleted from the queue.
     */
    function Queue(name, _a) {
        var _b = _a === void 0 ? {} : _a, onSync = _b.onSync, maxRetentionTime = _b.maxRetentionTime;
        this._syncInProgress = false;
        this._requestsAddedDuringSync = false;
        // Ensure the store name is not already being used
        if (queueNames.has(name)) {
            throw new WorkboxError_js_1.WorkboxError('duplicate-queue-name', { name: name });
        }
        else {
            queueNames.add(name);
        }
        this._name = name;
        this._onSync = onSync || this.replayRequests;
        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;
        this._queueStore = new QueueStore_js_1.QueueStore(this._name);
        this._addSyncListener();
    }
    Object.defineProperty(Queue.prototype, "name", {
        /**
         * @return {string}
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Stores the passed request in IndexedDB (with its timestamp and any
     * metadata) at the end of the queue.
     *
     * @param {Object} entry
     * @param {Request} entry.request The request to store in the queue.
     * @param {Object} [entry.metadata] Any metadata you want associated with the
     *     stored request. When requests are replayed you'll have access to this
     *     metadata object in case you need to modify the request beforehand.
     * @param {number} [entry.timestamp] The timestamp (Epoch time in
     *     milliseconds) when the request was first added to the queue. This is
     *     used along with `maxRetentionTime` to remove outdated requests. In
     *     general you don't need to set this value, as it's automatically set
     *     for you (defaulting to `Date.now()`), but you can update it if you
     *     don't want particular requests to expire.
     */
    Queue.prototype.pushRequest = function (entry) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (process.env.NODE_ENV !== 'production') {
                            assert_js_1.assert.isType(entry, 'object', {
                                moduleName: 'workbox-background-sync',
                                className: 'Queue',
                                funcName: 'pushRequest',
                                paramName: 'entry'
                            });
                            assert_js_1.assert.isInstance(entry.request, Request, {
                                moduleName: 'workbox-background-sync',
                                className: 'Queue',
                                funcName: 'pushRequest',
                                paramName: 'entry.request'
                            });
                        }
                        return [4 /*yield*/, this._addRequest(entry, 'push')];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stores the passed request in IndexedDB (with its timestamp and any
     * metadata) at the beginning of the queue.
     *
     * @param {Object} entry
     * @param {Request} entry.request The request to store in the queue.
     * @param {Object} [entry.metadata] Any metadata you want associated with the
     *     stored request. When requests are replayed you'll have access to this
     *     metadata object in case you need to modify the request beforehand.
     * @param {number} [entry.timestamp] The timestamp (Epoch time in
     *     milliseconds) when the request was first added to the queue. This is
     *     used along with `maxRetentionTime` to remove outdated requests. In
     *     general you don't need to set this value, as it's automatically set
     *     for you (defaulting to `Date.now()`), but you can update it if you
     *     don't want particular requests to expire.
     */
    Queue.prototype.unshiftRequest = function (entry) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (process.env.NODE_ENV !== 'production') {
                            assert_js_1.assert.isType(entry, 'object', {
                                moduleName: 'workbox-background-sync',
                                className: 'Queue',
                                funcName: 'unshiftRequest',
                                paramName: 'entry'
                            });
                            assert_js_1.assert.isInstance(entry.request, Request, {
                                moduleName: 'workbox-background-sync',
                                className: 'Queue',
                                funcName: 'unshiftRequest',
                                paramName: 'entry.request'
                            });
                        }
                        return [4 /*yield*/, this._addRequest(entry, 'unshift')];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes and returns the last request in the queue (along with its
     * timestamp and any metadata). The returned object takes the form:
     * `{request, timestamp, metadata}`.
     *
     * @return {Promise<Object>}
     */
    Queue.prototype.popRequest = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._removeRequest('pop')];
            });
        });
    };
    /**
     * Removes and returns the first request in the queue (along with its
     * timestamp and any metadata). The returned object takes the form:
     * `{request, timestamp, metadata}`.
     *
     * @return {Promise<Object>}
     */
    Queue.prototype.shiftRequest = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._removeRequest('shift')];
            });
        });
    };
    /**
     * Returns all the entries that have not expired (per `maxRetentionTime`).
     * Any expired entries are removed from the queue.
     *
     * @return {Promise<Array<Object>>}
     */
    Queue.prototype.getAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allEntries, now, unexpiredEntries, _i, allEntries_1, entry, maxRetentionTimeInMs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._queueStore.getAll()];
                    case 1:
                        allEntries = _a.sent();
                        now = Date.now();
                        unexpiredEntries = [];
                        _i = 0, allEntries_1 = allEntries;
                        _a.label = 2;
                    case 2:
                        if (!(_i < allEntries_1.length)) return [3 /*break*/, 6];
                        entry = allEntries_1[_i];
                        maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
                        if (!(now - entry.timestamp > maxRetentionTimeInMs)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._queueStore.deleteEntry(entry.id)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        unexpiredEntries.push(convertEntry(entry));
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 2];
                    case 6: return [2 /*return*/, unexpiredEntries];
                }
            });
        });
    };
    /**
     * Adds the entry to the QueueStore and registers for a sync event.
     *
     * @param {Object} entry
     * @param {Request} entry.request
     * @param {Object} [entry.metadata]
     * @param {number} [entry.timestamp=Date.now()]
     * @param {string} operation ('push' or 'unshift')
     * @private
     */
    Queue.prototype._addRequest = function (_a, operation) {
        var request = _a.request, metadata = _a.metadata, _b = _a.timestamp, timestamp = _b === void 0 ? Date.now() : _b;
        return __awaiter(this, void 0, void 0, function () {
            var storableRequest, entry;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, StorableRequest_js_1.StorableRequest.fromRequest(request.clone())];
                    case 1:
                        storableRequest = _c.sent();
                        entry = {
                            requestData: storableRequest.toObject(),
                            timestamp: timestamp
                        };
                        // Only include metadata if it's present.
                        if (metadata) {
                            entry.metadata = metadata;
                        }
                        return [4 /*yield*/, this._queueStore[operation + "Entry"](entry)];
                    case 2:
                        _c.sent();
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.log("Request for '" + getFriendlyURL_js_1.getFriendlyURL(request.url) + "' has " +
                                ("been added to background sync queue '" + this._name + "'."));
                        }
                        if (!this._syncInProgress) return [3 /*break*/, 3];
                        this._requestsAddedDuringSync = true;
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.registerSync()];
                    case 4:
                        _c.sent();
                        _c.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes and returns the first or last (depending on `operation`) entry
     * from the QueueStore that's not older than the `maxRetentionTime`.
     *
     * @param {string} operation ('pop' or 'shift')
     * @return {Object|undefined}
     * @private
     */
    Queue.prototype._removeRequest = function (operation) {
        return __awaiter(this, void 0, Promise, function () {
            var now, entry, maxRetentionTimeInMs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        now = Date.now();
                        return [4 /*yield*/, this._queueStore[operation + "Entry"]()];
                    case 1:
                        entry = _a.sent();
                        if (entry) {
                            maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
                            if (now - entry.timestamp > maxRetentionTimeInMs) {
                                return [2 /*return*/, this._removeRequest(operation)];
                            }
                            return [2 /*return*/, convertEntry(entry)];
                        }
                        else {
                            return [2 /*return*/, undefined];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Loops through each request in the queue and attempts to re-fetch it.
     * If any request fails to re-fetch, it's put back in the same position in
     * the queue (which registers a retry for the next sync event).
     */
    Queue.prototype.replayRequests = function () {
        return __awaiter(this, void 0, void 0, function () {
            var entry, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.shiftRequest()];
                    case 1:
                        if (!(entry = _a.sent())) return [3 /*break*/, 7];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 6]);
                        return [4 /*yield*/, fetch(entry.request.clone())];
                    case 3:
                        _a.sent();
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.log("Request for '" + getFriendlyURL_js_1.getFriendlyURL(entry.request.url) + "'" +
                                ("has been replayed in queue '" + this._name + "'"));
                        }
                        return [3 /*break*/, 6];
                    case 4:
                        error_1 = _a.sent();
                        return [4 /*yield*/, this.unshiftRequest(entry)];
                    case 5:
                        _a.sent();
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.log("Request for '" + getFriendlyURL_js_1.getFriendlyURL(entry.request.url) + "'" +
                                ("failed to replay, putting it back in queue '" + this._name + "'"));
                        }
                        throw new WorkboxError_js_1.WorkboxError('queue-replay-failed', { name: this._name });
                    case 6: return [3 /*break*/, 0];
                    case 7:
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.log("All requests in queue '" + this.name + "' have successfully " +
                                "replayed; the queue is now empty!");
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Registers a sync event with a tag unique to this instance.
     */
    Queue.prototype.registerSync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!('sync' in self.registration)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, self.registration.sync.register(TAG_PREFIX + ":" + this._name)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        // This means the registration failed for some reason, possibly due to
                        // the user disabling it.
                        if (process.env.NODE_ENV !== 'production') {
                            logger_js_1.logger.warn("Unable to register sync event for '" + this._name + "'.", err_1);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * In sync-supporting browsers, this adds a listener for the sync event.
     * In non-sync-supporting browsers, this will retry the queue on service
     * worker startup.
     *
     * @private
     */
    Queue.prototype._addSyncListener = function () {
        var _this = this;
        if ('sync' in self.registration) {
            self.addEventListener('sync', function (event) {
                if (event.tag === TAG_PREFIX + ":" + _this._name) {
                    if (process.env.NODE_ENV !== 'production') {
                        logger_js_1.logger.log("Background sync for tag '" + event.tag + "'" +
                            "has been received");
                    }
                    var syncComplete = function () { return __awaiter(_this, void 0, void 0, function () {
                        var syncError, error_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this._syncInProgress = true;
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, 4, 7]);
                                    return [4 /*yield*/, this._onSync({ queue: this })];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 7];
                                case 3:
                                    error_2 = _a.sent();
                                    syncError = error_2;
                                    // Rethrow the error. Note: the logic in the finally clause
                                    // will run before this gets rethrown.
                                    throw syncError;
                                case 4:
                                    if (!(this._requestsAddedDuringSync &&
                                        !(syncError && !event.lastChance))) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.registerSync()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6:
                                    this._syncInProgress = false;
                                    this._requestsAddedDuringSync = false;
                                    return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    }); };
                    event.waitUntil(syncComplete());
                }
            });
        }
        else {
            if (process.env.NODE_ENV !== 'production') {
                logger_js_1.logger.log("Background sync replaying without background sync event");
            }
            // If the browser doesn't support background sync, retry
            // every time the service worker starts up as a fallback.
            this._onSync({ queue: this });
        }
    };
    Object.defineProperty(Queue, "_queueNames", {
        /**
         * Returns the set of queue names. This is primarily used to reset the list
         * of queue names in tests.
         *
         * @return {Set}
         *
         * @private
         */
        get: function () {
            return queueNames;
        },
        enumerable: false,
        configurable: true
    });
    return Queue;
}());
exports.Queue = Queue;
